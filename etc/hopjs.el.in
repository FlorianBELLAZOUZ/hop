;; -*- mode: lisp -*-
;*=====================================================================*/
;*    serrano/prgm/project/hop/3.0.x/etc/hopjs.el.in                   */
;*    -------------------------------------------------------------    */
;*    Author      :  Manuel Serrano                                    */
;*    Creation    :  Sun May 25 13:05:16 2014                          */
;*    Last change :  Fri Oct 23 08:41:45 2015 (serrano)                */
;*    Copyright   :  2014-15 Manuel Serrano                            */
;*    -------------------------------------------------------------    */
;*    HOPJS customization of the standard js-mode                      */
;*=====================================================================*/

;*---------------------------------------------------------------------*/
;*    The package                                                      */
;*---------------------------------------------------------------------*/
(provide 'hopjs)
(require 'json)
(require 'js)

;*---------------------------------------------------------------------*/
;*    configuration                                                    */
;*---------------------------------------------------------------------*/
(defcustom hopjs-indent-level-html 2
  "Number of spaces for each indentation step in `js-mode'."
  :type 'integer
  :safe 'integerp
  :group 'js)

(defcustom hopjs-balloon-binding
  (if (featurep 'xemacs) [(button1)] [(down-mouse-1)])
  "*The mouse binding for the pseudo-balloon event."
  :group 'ude
  :type 'vector)

(defcustom hopjs-doc-dir "@DOCDIR@"
  "The json directory containing the documentation indexes"
  :type 'string
  :safe 'stringp
  :group 'js)

(defcustom hopjs-navigator "firefox"
  "The navigator to access the documentation"
  :type 'string
  :safe 'stringp
  :group 'js)

(defcustom hopjs-special-tags '("link" "LINK" "input" "INPUT")
  "The special HTML tag that have no close tag"
  :type '(repeat (string))
  :group 'js)
  
;*---------------------------------------------------------------------*/
;*    Highlighting                                                     */
;*---------------------------------------------------------------------*/
(defface hopjs-nomatch-face
  '((((class color)) (:background "Red"))
    (t (:weight bold)))
  "Face used for marking a nomatched tag."
  :group 'hopjs)

(defface hopjs-match-face
  '((((class color)) (:background "Green"))
    (t (:weight bold)))
  "Face used for marking a matched tag."
  :group 'hopjs)

(defvar hopjs-tag-overlays nil)

;*---------------------------------------------------------------------*/
;*    global state                                                     */
;*---------------------------------------------------------------------*/
(defvar hopjs-doc-index-table
  (make-vector 27 '()))

;*---------------------------------------------------------------------*/
;*    hopjs-mode-hook ...                                              */
;*---------------------------------------------------------------------*/
(defun hopjs-mode-hook ()
  ;; syntax
  (hopjs-syntax)
  ;; key bindings
  (hopjs-key-bindings)
  ;; font lock
  (font-lock-add-keywords nil hopjs-font-lock-keywords)
  ;; custom beginning of defun
  ;; (setq beginning-of-defun-function 'hopjs-beginning-of-defun)      */
  ;; (setq end-of-defun-function 'hopjs-end-of-defun)
  ;; index
  (hopjs-load-index (concat hopjs-doc-dir "/idx.json") hopjs-doc-index-table)
  ;; balloons
;*   (hopjs-balloon-start)                                             */
;*   ;; (setq l (json-read-file "toto.json"))                          */
;*   (hopjs-add-balloon-action                                         */
;*    "popup"                                                          */
;*    '(lambda (point win)                                             */
;*       (save-excursion                                               */
;* 	(goto-char point)                                              */
;* 	(let* ((beg (progn (backward-word ) (point)))                  */
;* 	       (end (progn (forward-word 1) (point)))                  */
;* 	       (str (buffer-substring-no-properties beg end)))         */
;* 	  (message "point=%s beg=%s end=%sstr=[%s]" point beg end str) */
;* 	  nil)))                                                       */
;*    '(lambda ()                                                      */
;*       (message "action")))                                          */
  ;; tag matching
  (message "installating post-command-hook...")
  (add-hook 'post-command-hook (function hopjs-tag-matching) t t)
  ;; user hooks
  (run-hooks 'hopjs-mode-hook))

;*---------------------------------------------------------------------*/
;*    hopjs-syntax ...                                                 */
;*---------------------------------------------------------------------*/
(defun hopjs-syntax ()
  "Syntax table for `hopjs-mode'."
  (let ((table (syntax-table)))
    (modify-syntax-entry ?\` "\"    " table)
    table))

;*---------------------------------------------------------------------*/
;*    font-lock ...                                                    */
;*---------------------------------------------------------------------*/
(defconst hopjs-font-lock-keywords
  (list (list "^\\s-*\\(service\\)\\(?:\\s-+\\|(\\)" 1 'font-lock-keyword-face)
	(cons ".post\\(Sync\\|Message\\)?" 'font-lock-face-2)
	(cons "</?[a-zA-Z0-9_.]+[ ]*>\\|[ ]*/>\\|<[^ /]*/>" 'font-lock-face-9)
	(list "\\(</?[a-zA-Z0-9_.:]+\\)[ ]+[a-zA-Z0-9_]" 1 'font-lock-face-9)
	(cons "<!--\\([^-]\\|-[^-]\\|--[^>]\\)+-[-]+>" 'font-lock-comment-face)
	(list "[}\"][ ]*\\(>\\)" 1 'font-lock-face-9)
	(cons "$\{[^ \t\r\n{}]*\}" 'font-lock-face-2)
	(list "\\([$]\\){" 1 'font-lock-face-2)
	(list "\\([~]\\){" 1 'font-lock-face-3)
	(cons "[0-9a-zA-Z_-]*:" 'font-lock-face-10)
	(list (concat "^\\s-*\\(?:service\\)\\s-+\\(" js--name-re "\\)") 1 'font-lock-function-name-face)))

;*---------------------------------------------------------------------*/
;*    hopjs-key-bindings ...                                           */
;*---------------------------------------------------------------------*/
(defun hopjs-key-bindings ()
  (let ((map (current-local-map)))
    (define-key map "\C-m" 'hopjs-return)
    (define-key map "\e\C-m" 'newline)
    (local-unset-key "\ee")
    (define-key map "\e\C-q" 'hopjs-indent-statement)
    (local-unset-key "}")
    (define-key map "}" 'hopjs-electric-brace)
    (local-unset-key ")")
    (define-key map ")" 'hopjs-electric-paren)
    (local-unset-key ">")
    (define-key map ">" 'hopjs-electric-abra)))

;*---------------------------------------------------------------------*/
;*    hopjs-re-open-tag ...                                            */
;*---------------------------------------------------------------------*/
(defconst hopjs-re-open-tag
  "<[ \t]*\\([a-zA-Z_$][a-zA-Z0-9_.:$!]*[^<>/{ \t]*\\)")
(defconst hopjs-re-close-tag
  "</[ \t]*\\([a-zA-Z_$][a-zA-Z0-9_.:$!]*\\)[ \t]*>")
(defconst hopjs-re-end-tag
  "/>")
(defconst hopjs-re-code
  "{")
(defconst hopjs-re-tag
  (concat hopjs-re-open-tag
	  "\\|" hopjs-re-close-tag
	  "\\|" hopjs-re-end-tag
	  "\\|" hopjs-re-code))

(defconst hopjs-re-standalone-tag
  "<\\([^>/\n]\\|/[^>]\\)*/>")

(defconst hopjs-re-entering-var
  (concat "\\(?:var[ \t ]*\\)?[a-zA-Z_$][:.0-9a-zA-Z_$]*[ \t]*=[ \t]*"
	  hopjs-re-open-tag))

(defconst hopjs-re-entering-retun
  (concat "return[ \t]+" hopjs-re-open-tag))

(defconst hopjs-re-entering
  (concat hopjs-re-entering-var "\\|" hopjs-re-entering-retun))

(defconst hopjs-re-entering-html
  "\\(?:var[ \t ]*\\)?[a-zA-Z_$][:.0-9a-zA-Z_$]*[ \t]*[(= ]?[ \t]*<\\(?:[^> \n/]+\\|[^/]>\\)")

(defconst hopjs-re-entering-attr-html
  "\\(?:var[ \t ]*\\)?[a-zA-Z_$][:.0-9a-zA-Z_$]*[ \t]*[(= ]?[ \t]*<\\(?:[^> \n/]+\\)[ \t]+\\([^\n<>]+\\)$")

(defconst hopjs-re-special-tag
  "<\\(link\\|LINK\\)")

(defconst hopjs-re-attribute
  "[a-zA-Z0-9_-]+[ \t]*=")

(defconst hopjs-re-any-tag
  (concat hopjs-re-open-tag "\\|" hopjs-re-close-tag "\\|" hopjs-re-end-tag))

;*---------------------------------------------------------------------*/
;*    debugging                                                        */
;*---------------------------------------------------------------------*/
(defun hopjs-debug (fmt &rest l)
  (when hopjs-debug (apply 'message fmt l)))

(defconst hopjs-debug t)

;*---------------------------------------------------------------------*/
;*    call-sans-debug ...                                              */
;*---------------------------------------------------------------------*/
(defun call-sans-debug (f &rest l)
  (let ((dbg hopjs-debug))
    (setq hopjs-debug nil)
    (let ((tmp (apply f l)))
      (setq hopjs-debug dbg)
      tmp)))

;*---------------------------------------------------------------------*/
;*    hopjs-electric-brace ...                                         */
;*---------------------------------------------------------------------*/
(defun hopjs-electric-brace ()
  "Insert and indent line."
  (interactive)
  (insert "}")
  (indent-for-tab-command))

;*---------------------------------------------------------------------*/
;*    hopjs-electric-paren ...                                         */
;*---------------------------------------------------------------------*/
(defun hopjs-electric-paren ()
  "Insert and indent line."
  (interactive)
  (insert ")")
  (indent-for-tab-command))

;*---------------------------------------------------------------------*/
;*    hopjs-electric-abra ...                                          */
;*---------------------------------------------------------------------*/
(defun hopjs-electric-abra ()
  "Insert and indent line."
  (interactive)
  (insert ">")
  (indent-for-tab-command))

;*---------------------------------------------------------------------*/
;*    hopjs-indent-statement ...                                       */
;*---------------------------------------------------------------------*/
(defun hopjs-indent-statement ()
  "Indent curent statement."
  (interactive)
  (save-excursion
    (c-beginning-of-statement
     0
     (save-excursion
       (hopjs-beginning-of-defun)
       (point))
     nil)
    (let ((start (point)))
      (c-forward-sexp)
      (let ((end (point)))
	(indent-region start end)))))

;*---------------------------------------------------------------------*/
;*    hopjs-return ...                                                 */
;*---------------------------------------------------------------------*/
(defun hopjs-return (&optional dummy)
   "On indent automatiquement sur un RET.
usage: (js-return)  -- [RET]"
   (interactive)
   (if (= (point) 1)
       (newline)
     (newline-and-indent)))

;* {*---------------------------------------------------------------------*} */
;* {*    hopjs-beginning-of-defun ...                                     *} */
;* {*---------------------------------------------------------------------*} */
;* (defun hopjs-beginning-of-defun (pos)                               */
;*   (interactive "d")                                                 */
;*   (let ((res 'loop))                                                */
;*     (while (eq res 'loop)                                           */
;*       (beginning-of-defun)                                          */
;*       (let ((defpos (point)))                                       */
;* 	(cond                                                          */
;* 	 ((<= defpos (point-min))                                      */
;* 	  (setq res nil))                                              */
;* 	 ((search-forward "{" pos t)                                   */
;* 	  (forward-char -1)                                            */
;* 	  (condition-case nil                                          */
;* 	      (progn                                                   */
;* 		(forward-sexp 1)                                       */
;* 		(if (> (point) pos)                                    */
;* 		    (progn                                             */
;* 		      (goto-char defpos)                               */
;* 		      (setq res t))                                    */
;* 		  (goto-char defpos)))                                 */
;* 	    (error                                                     */
;* 	     (progn                                                    */
;* 	       (goto-char defpos)                                      */
;* 	       (setq res t)                                            */
;* 	       nil))))                                                 */
;* 	 (t                                                            */
;* 	  (setq res nil)))))                                           */
;*     res))                                                           */
	      
;*---------------------------------------------------------------------*/
;*    hopjs--indent-operator-re ...                                    */
;*---------------------------------------------------------------------*/
(defconst hopjs--indent-operator-re 
  (concat "[-+*/%=&^|?:.]\\([^-+*/]\\|$\\)\\|^<$\\|^>$\\|"
          (js--regexp-opt-symbol '("in" "instanceof")))
  "Regexp matching operators that affect indentation of continued expressions.")

(defun js--looking-at-operator-p ()
  "Return non-nil if point is on a JavaScript operator, other than a comma."
  (save-match-data
    (and (looking-at hopjs--indent-operator-re)
         (or (not (looking-at ":"))
             (save-excursion
               (and (js--re-search-backward "[?:{]\\|\\_<case\\_>" nil t)
                    (looking-at "?")))))))

(defun js--proper-indentation (parse-status)
  "Return the proper indentation for the current line."
  (save-excursion
    (back-to-indentation)
    (cond ((nth 4 parse-status)    ; inside comment
           (js--get-c-offset 'c (nth 8 parse-status)))
          ((nth 3 parse-status) 0) ; inside string
          ((eq (char-after) ?#) 0)
          ((save-excursion (js--beginning-of-macro)) 4)
          ;; Indent array comprehension continuation lines specially.
          ((let ((bracket (nth 1 parse-status))
                 beg)
             (and bracket
                  (not (js--same-line bracket))
                  (setq beg (js--indent-in-array-comp bracket))
                  ;; At or after the first loop?
                  (>= (point) beg)
                  (js--array-comp-indentation bracket beg))))
	  ((js--html-statement-indentation))
          ((js--ctrl-statement-indentation))
          ((js--multi-line-declaration-indentation))
          ((nth 1 parse-status)
	   ;; A single closing paren/bracket should be indented at the
	   ;; same level as the opening statement. Same goes for
	   ;; "case" and "default".
           (let ((same-indent-p (looking-at "[]})]"))
                 (switch-keyword-p (looking-at "default\\_>\\|case\\_>[^:]"))
                 (continued-expr-p (js--continued-expression-p)))
             (goto-char (nth 1 parse-status)) ; go to the opening char
             (if (looking-at "[({[]\\s-*\\(/[/*]\\|$\\)")
                 (progn ; nothing following the opening paren/bracket
                   (skip-syntax-backward " ")
                   (when (eq (char-before) ?\)) (backward-list))
                   (back-to-indentation)
                   (let* ((in-switch-p (unless same-indent-p
                                         (looking-at "\\_<switch\\_>")))
                          (same-indent-p (or same-indent-p
                                             (and switch-keyword-p
                                                  in-switch-p)))
                          (indent
                           (cond (same-indent-p
                                  (current-column))
                                 (continued-expr-p
                                  (+ (current-column) (* 2 js-indent-level)
                                     js-expr-indent-offset))
                                 (t
                                  (+ (current-column) js-indent-level
                                     (pcase (char-after (nth 1 parse-status))
                                       (?\( js-paren-indent-offset)
                                       (?\[ js-square-indent-offset)
                                       (?\{ js-curly-indent-offset)))))))
                     (if in-switch-p
                         (+ indent js-switch-indent-offset)
                       indent)))
               ;; If there is something following the opening
               ;; paren/bracket, everything else should be indented at
               ;; the same level.
               (unless same-indent-p
                 (forward-char)
                 (skip-chars-forward " \t"))
               (current-column))))

          ((js--continued-expression-p)
           (+ js-indent-level js-expr-indent-offset))
          (t 0))))

;*---------------------------------------------------------------------*/
;*    hopjs-in-string-comment-p ...                                    */
;*---------------------------------------------------------------------*/
(defun hopjs-in-string-comment-p (pos)
  (memq (get-text-property pos 'face)
	'(font-lock-comment-face font-lock-string-face)))

;*---------------------------------------------------------------------*/
;*    hopjs-eol-pos ...                                                */
;*---------------------------------------------------------------------*/
(defun hopjs-eol-pos ()
  (save-excursion
    (end-of-line)
    (point)))
  
;*---------------------------------------------------------------------*/
;*    hopjs-parse-html-token ...                                       */
;*---------------------------------------------------------------------*/
(defun hopjs-parse-html-token ()
  ;; parse the HTML token at point
  (cond
   ((looking-at hopjs-re-open-tag)
    (let* ((tagname (buffer-substring-no-properties
		     (match-beginning 1) (match-end 1)))
	   (type (if (member tagname hopjs-special-tags)
		     'tag
		   'otag)))
      (vector type
	      (match-beginning 0) (match-end 0)
	      (match-beginning 1) (match-end 1))))
   ((looking-at hopjs-re-close-tag)
    (vector 'ctag
	    (match-beginning 0) (match-end 0)))
   ((looking-at hopjs-re-entering-html)
    (vector 'entering
	    (match-beginning 0) (match-end 0)))
   ((looking-at hopjs-re-attribute)
    (vector 'attribute
	    (match-beginning 0) (match-end 0)))
   ((looking-at hopjs-re-end-tag)
    (vector 'end-tag
	    (match-beginning 0) (match-end 0)))
   ((looking-at ">")
    (vector 'end-otag
	    (match-beginning 0) (match-end 0)))
   (t
    (let ((eol (hopjs-eol-pos))
	  (beg (point)))
      (cond
       ((or (re-search-forward hopjs-re-open-tag eol t)
	    (re-search-forward hopjs-re-close-tag eol t)
	    (re-search-forward hopjs-re-end-tag eol t))
	(vector 'blob beg (match-beginning 0)))
       (t
	nil))))))
    
(defun hopjs-pht ()
  (interactive)
  (message "%s" (hopjs-parse-html-token)))

;*---------------------------------------------------------------------*/
;*    hopjs-parse-html-attribute-value ...                             */
;*---------------------------------------------------------------------*/
(defun hopjs-parse-html-attribute-value ()
  ;; parse the HTML attribute value at point
  (cond
   ((looking-at "\"[^\"\n]*\"")
    (vector 'attr-value (match-beginning 0) (match-end 0)))
   ((looking-at "\"[^\"\n]*")
    (vector 'attr-value (match-beginning 0) (match-end 0)))
   ((looking-at "[a-zA-Z0-9_]+")
    (vector 'attr-value (match-beginning 0) (match-end 0)))
   ((looking-at "[$~]{")
    (let ((eol (hopjs-eol-pos))
	  (beg (match-beginning 0))
	  (end (match-end 0)))
      (goto-char (1+ beg))
      (condition-case nil
	  (save-excursion
	    (let ((forward-sexp-function nil))
	      (forward-sexp 1)
	      (if (> (point) eol)
		  (vector 'attr-value beg eol)
		(vector 'attr-value beg (point)))))
	(error
	 (vector 'attr-value beg eol)))))))

(defun hopjs-pha ()
  (interactive)
  (message "%s" (hopjs-parse-html-attribute-value)))

;*---------------------------------------------------------------------*/
;*    hopjs-parse-html-line ...                                        */
;*---------------------------------------------------------------------*/
(defun hopjs-parse-html-line ()
  ;; parse all HTML tokens of line at point
  (back-to-indentation)
  (let ((res '())
	(tok (hopjs-parse-html-token)))
    (while tok
      (setq res (cons tok res))
      (goto-char (aref tok 2))
      (if (looking-at "[ \t]*")
	  (progn
	    (goto-char (match-end 0))
	    (case (aref tok 0)
	      ((attribute)
	       (setq tok (hopjs-parse-html-attribute-value)))
	      (t
	       (setq tok (hopjs-parse-html-token)))))
	(setq tok nil)))
    res))

(defun hopjs-phl ()
  (interactive)
  (message "%s" (hopjs-parse-html-line)))

;*---------------------------------------------------------------------*/
;*    hopjs-html-p ...                                                 */
;*---------------------------------------------------------------------*/
(defun hopjs-html-p (pos)
  (interactive "d")
  (hopjs-debug ">>> hopjs-html-p pos=%d" pos)
  (save-excursion
    (let ((loop 'loop)
	  (open 0)
	  (be (progn (hopjs-beginning-of-defun) (point))))
      (hopjs-debug "~~~ hopjs-html-p be=%s" be)
      (hopjs-debug "~~~ hopjs-html-p, loop=%s be=%d" loop be)
      (when (eq loop 'loop)
	(goto-char be)
	(while (eq loop 'loop)
	  (if (re-search-forward hopjs-re-tag pos t)
	      (let ((next (match-end 0)))
		(hopjs-debug "--- hopjs-html-p open=%d point=%s next=%d match=\"%s\""
			     open (point) next
			 (buffer-substring-no-properties
			  (match-beginning 0) (match-end 0)))
		(goto-char (match-beginning 0))
		(cond
		 ((hopjs-in-string-comment-p (point))
		  (hopjs-debug "     (in-comment/string)")
		  (goto-char next))
		 ((looking-at hopjs-re-code)
		  (condition-case ()
		      (let ((p (save-excursion (forward-sexp 1) (point))))
			(hopjs-debug "    (re-code p=%s pos=%s)" p pos)
			(if (> p pos)
			    (progn
			      (setq open 0)
			      (forward-char 1))
			  (goto-char p)))
		    (error
		     (forward-char 1))))
		 ((looking-at hopjs-re-open-tag)
		  (setq open (+ open 1))
		  (hopjs-debug "    (re-open-tag)")
		  (goto-char next))
		 ((looking-at hopjs-re-close-tag)
		  (hopjs-debug "    (re-close-tag)")
		  (setq open (- open 1))
		  (goto-char next))
		 ((looking-at hopjs-re-end-tag)
		  (hopjs-debug "    (re-end-tag)")
		  (setq open (- open 1))
		  (goto-char next))
		 (t
		  (forward-char 1)
		  (forward-sexp 1)
		  (hopjs-debug "!!! hopjs-html-p forward=%s" (point)))))
	    (setq loop nil))))
      (hopjs-debug "<<< hopjs-html-p pos=%d open=%s %s -> %s" pos open hopjs-debug
		   (> open 0))
      (> open 0))))

;*---------------------------------------------------------------------*/
;*    hopjs-html-line-type ...                                         */
;*---------------------------------------------------------------------*/
(defun hopjs-html-line-type ()
  (interactive)
  (save-excursion
    (beginning-of-line)
    (back-to-indentation)
    (cond
     ((looking-at "$")
      ;; empty
      'newline)
     ((looking-at "[ \t]+$")
      ;; empty line
      'blank)
     ((looking-at hopjs-re-entering-attr-html)
      ;; entering-attr
      'entering-attr)
     ((looking-at hopjs-re-entering-html)
      ;; entering
      'entering)
     ((looking-at "<\\([^>/\n]\\|/[^>]\\)*/>[ \t]*$")
      ;; standlone tag
      'tag)
     ((looking-at "<[a-zA-Z_$][:.0-9a-zA-Z_$]*[ ]+\\([^>\n]\\)[^>]*$")
      ;; open tag + attribute
      (if (looking-at hopjs-re-special-tag) 'tag 'otag-attr))
     ((looking-at "<[a-zA-Z_$][:.0-9a-zA-Z_$]*[ ]*$")
      ;; open tag - attribute
      (if (looking-at hopjs-re-special-tag) 'tag 'otag-sans))
     ((looking-at "\\([^<>\n=]+=[^<>\n=]+[ \t]*\\)+/>[ \t]*$")
      ;; attribute + closing
      'attr-tag)
     ((looking-at "\\([^<>\n=]+=[^<>\n=]+[ \t]*\\)+>[ \t]*$")
      ;; attribute + tag
      'attr-otag)
     ((looking-at "\\([^<> [\n]+=[^<>\n]+[ \t]*\\)+$")
      ;; attribute
      'attr)
     ((looking-at "\\(</[^>]*>\\)+[ \t;)}]*$")
      ;; closing
      'ctag)
     ((looking-at "<\\([a-zA-Z_$][:.0-9a-zA-Z_$]*\\).*</\\1>[ \t]*$")
      ;; single line open/closing
      'tag)
     ((looking-at "<!--\\([^-]\\|-[^-]\\|--[^>]\\)+-->[ \t]*$")
      ;; comment
      'comment)
     ((looking-at "<!--")
      ;; open comment
      'ocomment)
     ((looking-at "-->[ \t]*$")
      ;; close comment
      'comment)
     ((looking-at "<\\([^/<>]\\|/[^>]\\)+\\(>\\| \\)$")
      ;; opening
      (if (looking-at hopjs-re-special-tag) 'tag 'otag))
     ((looking-at "<\\([^/<>]\\|/[^>]\\)+>\\([^/]\\|/[^>]\\)*$")
      ;; opening with content
      (if (looking-at hopjs-re-special-tag) 'tag 'otag))
     ((looking-at "~{")
      ;; script code
      'script)
     (t
      (save-excursion
	(let ((min (point)))
	  (end-of-line)
	  (if (re-search-backward "<" min t)
	      (progn
		;; check of a closing tag at eol
		(goto-char (match-beginning 0))
		(cond
		 ((looking-at "</[^>]*>[ \t;]*$") 'ctag)
		 (t 'text)))
	    ;; plain text
	    'text)))))))

;*---------------------------------------------------------------------*/
;*    hopjs-goto-html-line ...                                         */
;*---------------------------------------------------------------------*/
(defun hopjs-goto-html-line (types pmin attr-or-tag goto-prev in-attr-tag)
  (hopjs-debug "  ### hopjs-goto-html-line point=%s pmin=%s attr-or-tag=%s types=%s"
	       (point) pmin attr-or-tag types)
  (if (> (point) pmin)
      (progn
	(when goto-prev (previous-line))
	(beginning-of-line)
	(back-to-indentation)
	(cond
	 ((call-sans-debug 'hopjs-html-p (point))
	  (let ((type (hopjs-html-line-type)))
	    (hopjs-debug "  ###### hopjs-goto-html-line.1 type=%s point=%s attr-or-tag=%s"
			 type (point) attr-or-tag)
	    (cond
	     ((memq type types)
	      (goto-char (match-beginning attr-or-tag))
	      (if (and in-attr-tag (memq type '(otag otag-attr otag-sans)))
		  'tag type))
	     ((eq type 'attr-tag)
	      (hopjs-goto-html-line types pmin attr-or-tag t t))
	     ((eq type 'attr-otag)
	      (hopjs-goto-html-line types pmin 0 t t))
	     (t
	      (hopjs-goto-html-line types pmin attr-or-tag t in-attr-tag)))))
	 ((eq (hopjs-html-line-type) 'entering-attr)
	  (hopjs-debug "  ###### hopjs-goto-html-line.2 type=entering-attr attr-or-tag=%s beg=%s"
		       attr-or-tag (match-beginning attr-or-tag))
	  (if (memq 'entering-attr types)
	      (progn
		(goto-char (match-beginning attr-or-tag))
		'entering-attr)
	    (hopjs-goto-html-line types pmin attr-or-tag t nil)))
	 ((eq (hopjs-html-line-type) 'entering)
	  (hopjs-debug "  ###### hopjs-goto-html-line.3 type-entering attr-or-tag=%s beg=%s"
		       attr-or-tag (match-beginning attr-or-tag))
	  (if (memq 'entering types)
	      (progn
		(goto-char (match-beginning attr-or-tag))
		'entering)
	    (hopjs-goto-html-line types pmin attr-or-tag t nil)))
	 (t
	  (hopjs-debug "  ###### hopjs-goto-html-line.4 else... %s" (point))
	  (let ((p (point)))
	    (condition-case nil
		(progn
		  (end-of-line)
		  (backward-sexp 1)
		  (if (< (point) p)
		      (hopjs-goto-html-line types pmin attr-or-tag nil nil)
		    'text))
	      (error
	       (hopjs-debug "  !!!hopjs-goto-html-line: cannot forward sexp %s" (point))
	       'text))))))
    'text))

;*---------------------------------------------------------------------*/
;*    hopjs-html-statement-indentation-text ...                        */
;*---------------------------------------------------------------------*/
(defun hopjs-html-statement-indentation-text ()
  (save-excursion
    (beginning-of-line)
    (previous-line)
    (back-to-indentation)
    (current-column)))

;*---------------------------------------------------------------------*/
;*    hopjs-html-statement-indentation-tag ...                         */
;*---------------------------------------------------------------------*/
(defun hopjs-html-statement-indentation-tag (ptype pmin)
  (case ptype
    ((attr-tag)
     (hopjs-goto-html-line '(otag otag-attr otag-sans entering) pmin 0 t nil)
     (current-column))
    ((ctag tag)
     (current-column))
    ((entering-attr)
     (goto-char (match-beginning 1))
     (current-column))
    (t
     (+ (current-column) hopjs-indent-level-html))))

;*---------------------------------------------------------------------*/
;*    hopjs-column-at ...                                              */
;*---------------------------------------------------------------------*/
(defun hopjs-column-at (pos)
  (goto-char pos)
  (current-column))

;*---------------------------------------------------------------------*/
;*    js--html-statement-indentation ...                               */
;*---------------------------------------------------------------------*/
(defun js--html-statement-indentation ()
  (when (call-sans-debug 'hopjs-html-p (point))
    (message "> js--html-statement-indentation point=%s" (point))
    (let ((pmin (save-excursion (hopjs-beginning-of-defun) (point))))
      (let ((col (save-excursion
		   (beginning-of-line)
		   (back-to-indentation)
		   (hopjs-indent-new-line pmin nil 0)))
	    (col0 (current-column)))
	(message ">> js--html-statement-indentation col=%s" col)
	(if (looking-at "[ \t]*$")
	    ;; empty line
	    col
	  (let ((tokens (last (hopjs-parse-html-line))))
	    (message ">> js--html-statement-indentation tokens=%s" tokens)
	    (if (consp tokens)
		(case (aref (car tokens) 0)
		  ((otag tag attribute)
		   col)
		  ((ctag)
		   (if (hopjs-find-opening-tag (aref (car tokens) 1))
		       (let ((pos (match-beginning 0)))
			 (save-excursion
			   (goto-char pos)
			   (let ((tok (last (hopjs-parse-html-line))))
			     (if (and (consp tok)
				      (eq (aref (car tok) 0) 'entering))
				 (hopjs-column-at (aref (car tok) 1))
			       (hopjs-column-at pos)))))
		     col0))
		  ((attr)
		   col)
		  (t
		   col0))
	      col0)))))))

;*---------------------------------------------------------------------*/
;*    hopjs-indent-new-line ...                                        */
;*---------------------------------------------------------------------*/
(defun hopjs-indent-new-line (pmin intag depth)
  (let ((pinit (point)))
    (message ">>> hopjs-indent-new-line point=%s" pinit)
    (beginning-of-line)
    (previous-line)
    (if (or (< (point) pmin) (= (point) pinit))
	0
      (let ((tokens (hopjs-parse-html-line))
	    (col nil)
	    (candidate nil)
	    (intag intag)
	    (depth depth))
	(message ">>>> hopjs-indent-new-line tokens=%s" tokens)
	(while (not col)
	  (if (consp tokens)
	      (let ((tok (car tokens)))
		(message ">>>>> hopjs-indent-new-line tok=%s intag=%s"
			 tok intag)
		(case (aref tok 0)
		  ((entering)
		   (let ((ocol (hopjs-column-at (aref tok 1))))
		     (setq col (+ ocol hopjs-indent-level-html))))
		  ((end-otag)
		   (setq intag t)
		   (setq tokens (cdr tokens)))
		  ((end-otag end-tag)
		   (setq intag t)
		   (setq depth (- depth 1))
		   (setq tokens (cdr tokens)))
		  ((attribute)
		   (if intag
		       (setq tokens (cdr tokens))
		     (if (and (consp (cdr tokens))
			      (eq (aref (cadr tokens) 0) 'attr-value))
			 (setq tokens (cdr tokens))
		       (setq col (hopjs-column-at (aref tok 1))))))
		  ((attr-value)
		   (if intag
		       (setq tokens (cdr tokens))
		     (if (and (consp (cdr tokens))
			      (eq (aref (cadr tokens) 0) 'attribute))
			 (setq tokens (cdr tokens))
		       (setq col (hopjs-column-at (aref tok 1))))))
		  ((otag)
		   (let ((c (if (= depth 0)
				(+ (hopjs-column-at (aref tok 1))
				   hopjs-indent-level-html)
			      (hopjs-column-at (aref tok 1)))))
		     (setq intag nil)
		     (if (consp (cdr tokens))
			 (progn
			   (setq candidate c)
			   (setq tokens (cdr tokens)))
		       (setq col c))))
		  ((tag)
		   (setq intag nil)
		   (let ((c (hopjs-column-at (aref tok 1))))
		     (if (consp (cdr tokens))
			 (progn
			   (setq candidate c)
			   (setq tokens (cdr tokens)))
		       (setq col c))))
		  ((ctag)
		   (let ((c (hopjs-column-at (aref tok 1))))
		     (setq depth (- depth 1))
		     (if (consp (cdr tokens))
			 (progn
			   (setq candidate c)
			   (setq tokens (cdr tokens)))
		       (setq col c))))
		  (t
		   (cond
		    ((consp (cdr tokens))
		     (setq tokens (cdr tokens)))
		    (candidate
		     (setq col candidate))
		    (t
		     (setq col (hopjs-indent-new-line pmin intag depth)))))))
	    (if candidate
		(setq col candidate)
	      (setq col (hopjs-indent-new-line pmin intag depth)))))
	(message "<<< hopjs-indent-new-line point=%s --> col=%s" pinit col)
	col))))

(defun hopjs-inl ()
  (interactive)
  (let ((pmin (save-excursion (hopjs-beginning-of-defun) (point))))
    (message "%s" (hopjs-indent-new-line pmin nil 0))))

(defun js--html-statement-indentation-old ()
  (hopjs-debug ">>> js--html-statement-indentation %s" (point))
  (when (call-sans-debug 'hopjs-html-p (point))
    (let ((pmin (save-excursion (hopjs-beginning-of-defun) (point))))
      (save-excursion
	(let ((ltype (hopjs-html-line-type)))
	  (hopjs-debug "--- js--html-statement-indentation... in HTML %s type=%s"
		       (point) ltype)
	  (case ltype
	    ((text blank entering)
	     (back-to-indentation)
	     (hopjs-debug "<<<.1 js--html-statement-indentation... text -> %s"
			  (current-column))
	     (current-column))
	    ((newline)
	     (let ((ptype (hopjs-goto-html-line
			   '(otag otag-attr attr-otag otag-sans entering entering-attr ctag ctag-attr tag text)
			   pmin 0 t nil)))
	       (hopjs-debug "<<<.2 js--html-statement-indentation... ltype=%s ptype=%s col=%s:%s"
			    ltype ptype (current-column) (point))
	       (cond
		((eq ptype 'text)
		 ;; a newline after plain text
		 (hopjs-html-statement-indentation-text))
		((eq ptype 'attr-otag)
		 (let ((ptype (hopjs-goto-html-line
			       '(otag entering-attr)
			       pmin 0 t nil)))
		   (+ (current-column) hopjs-indent-level-html)))
		(t
		 (hopjs-html-statement-indentation-tag ptype pmin)))))
	    ((tag otag otag-attr otag-sans script)
	     (let ((ptype (hopjs-goto-html-line
			   '(ctag otag otag-attr otag-sans tag
				  entering entering-attr attr-tag)
			   pmin 0 t nil)))
	       (hopjs-debug "<<<.3 js--html-statement-indentation... ltype=%s ptype=%s col=%s:%s"
			    ltype ptype (current-column) (point))
	       (case ptype
		 ((entering-attr entering)
		  (+ (current-column) hopjs-indent-level-html))
		 (t
		  (hopjs-html-statement-indentation-tag ptype pmin)))))
	    ((ctag)
	     (let ((ptype (hopjs-goto-html-line
			   '(otag otag-attr otag-sans entering entering-attr
				  ctag ctag-attr tag)
			   pmin 0 t nil)))
	       (hopjs-debug "<<<.4 js--html-statement-indentation... ltype=%s ptype=%s col=%s:%s"
			    ltype ptype (current-column) (point))
	       (case ptype
		 ((tag ctag ctag-attr tag)
		  (- (current-column) hopjs-indent-level-html))
		 ((otag otag-attr otag-sans)
		  (current-column))
		 (t
		  (current-column)))))
	    ((comment ocomment)
	     (let ((ptype (hopjs-goto-html-line
			   '(otag otag-attr otag-sans entering entering-attr ctag attr-tag ctag-attr tag
				  comment ocomment comment)
			   pmin 0 t nil)))
	       (hopjs-debug "<<<.5 js--html-statement-indentation... ltype=%s ptype=%s col=%s:%s"
			    ltype ptype (current-column) (point))
	       (case ptype
		 ((comment ocomment tag)
		  (current-column))
		 ((otag attr-tag)
		  (+ (current-column) hopjs-indent-level-html))
		 (else
		  (current-column)))))
	    ((attr attr-tag)
	     (let ((ptype (hopjs-goto-html-line
			   '(otag-attr otag-sans attr-tag attr entering-attr)
			   pmin 1 t nil)))
	       (hopjs-debug "<<<.6 js--html-statement-indentation... ltype=%s ptype=%s col=%s:%s"
			    ltype ptype (current-column) (point))
	       (case ptype
		 ((attr attr-tag entering-attr)
		  (current-column))
		 ((otag-sans)
		  (+ (current-column) hopjs-indent-level-html))
		 ((otag-attr)
		  (goto-char (match-beginning 1))
		  (current-column))
		 (else
		  (current-column)))))
	    ((attr-otag)
	     (let ((ptype (hopjs-goto-html-line
			   '(otag otag-attr attr-tag attr
				  entering entering-attr)
			   pmin 1 t nil)))
	       (hopjs-debug "<<<.7 js--html-statement-indentation... ltype=%s ptype=%s col=%s:%s"
			    ltype ptype (current-column) (point))
	       (case ptype
		 ((entering-attr)
		  (goto-char (match-beginning 1))
		  (current-column))
		 ((entering)
		  (+ (current-column) hopjs-indent-level-html))
		 (t
		  (current-column)))))
	    (t
	     (current-column))))))))

;*---------------------------------------------------------------------*/
;*    hopjs-search-code-regexp ...                                     */
;*---------------------------------------------------------------------*/
(defun hopjs-search-code-regexp (regexp search key)
  (save-excursion
    (let ((res '_)
	  (pos (point)))
      (while (eq res '_)
	(if (funcall search regexp nil t)
	    (let ((beg (match-beginning 0)))
	      (cond
	       ((eq (get-text-property beg 'face) key)
		(setq res t))
	       ((> pos (point))
		;; backward search
		(if (> (point) (point-min))
		    (goto-char (1- beg))
		  (setq res nil)))
	       (t
		;; forward search
		(if (< (point) (point-max))
		    (forward-char)
		  (setq res nil)))))
	  (setq res nil)))
      res)))
      
;*---------------------------------------------------------------------*/
;*    hopjs-search-previous-function ...                               */
;*---------------------------------------------------------------------*/
(defun hopjs-search-previous-function ()
  (when (hopjs-search-code-regexp
	 "\\_<\\(function\\|service\\)\\_>"
	 're-search-backward 
	 'font-lock-keyword-face)
    (let ((beg (match-beginning 0)))
      (goto-char beg)
      (if (hopjs-search-code-regexp "{" 're-search-forward nil)
	  ;; and we have found a open bracket
	  (condition-case nil
	      (progn
		(goto-char (match-beginning 0))
		(forward-sexp 1)
		(cons beg (point)))
	    (error
	     (cons beg beg)))
	;; no bracket found...
	nil))))

;*---------------------------------------------------------------------*/
;*    hopjs-goto-defun ...                                             */
;*---------------------------------------------------------------------*/
(defun hopjs-goto-defun (ref pos)
  (let ((loop t))
    (while loop
      (let ((fun (hopjs-search-previous-function)))
	(cond
	 ((not fun)
	  (goto-char (point-min))
	  (setq loop nil))
	 ((> (cdr fun) pos)
	  (progn
	    (setq loop nil)
	    (goto-char (funcall ref fun))))
	 ((> (car fun) (point-min))
	  (goto-char (1- (car fun))))
	 (t
	  (setq loop nil)))))))

;*---------------------------------------------------------------------*/
;*    hopjs-beginning-of-defun ...                                     */
;*---------------------------------------------------------------------*/
(defun hopjs-beginning-of-defun (&optional arg)
  (unless arg (setq arg 1))
  (while (> arg 0)
    (setq arg (1- arg))
    (hopjs-goto-defun 'car (point))))

;*---------------------------------------------------------------------*/
;*    hopjs-end-of-defun ...                                           */
;*---------------------------------------------------------------------*/
(defun hopjs-end-of-defun (&optional arg)
  (unless arg (setq arg 1))
  (while (> arg 0)
    (setq arg (1- arg))
    (hopjs-goto-defun 'cdr (point))))

;*---------------------------------------------------------------------*/
;*    hopjs-load-index ...                                             */
;*---------------------------------------------------------------------*/
(defun hopjs-load-index (file table)
  (when (file-exists-p file)
    (let* ((i 0)
	   (v (json-read-file file))
	   (len (length v)))
      (while (< i len)
	(let* ((en (aref v i))
	       (k (assq 'key en))
	       (n (string-match (cdr k) "[^.]+$"))
	       (c (aref (cdr k) (or n 0)))
	       (m (cond
		   ((and (>= c ?A) (<= c ?Z)) (- c ?A))
		   ((and (>= c ?a) (<= c ?z)) (- c ?a))
		   (else 27))))
	  (aset table m (cons (cons (cdr k) en) (aref table m)))
	  (setq i (+ i 1)))))))
	
;*---------------------------------------------------------------------*/
;*    hopjs-unhighlight-tags ...                                       */
;*---------------------------------------------------------------------*/
(defun hopjs-unhighlight-tags ()
  (while (consp hopjs-tag-overlays)
    (delete-overlay (car hopjs-tag-overlays))
    (setq hopjs-tag-overlays (cdr hopjs-tag-overlays))))

;*---------------------------------------------------------------------*/
;*    hopjs-highlight-tag ...                                          */
;*---------------------------------------------------------------------*/
(defun hopjs-highlight-tag (face beg end)
  (let ((ov (make-overlay beg end nil t nil)))
    (overlay-put ov 'face face)
    (overlay-put ov 'hopjs-tag-overlay t)
    (overlay-put ov 'evaporate t)
    (setq hopjs-tag-overlays (cons ov hopjs-tag-overlays))))

;*---------------------------------------------------------------------*/
;*    hopjs-closing-tag-p ...                                          */
;*---------------------------------------------------------------------*/
(defun hopjs-closing-tag-p (pos)
  (when (and (eq (char-after pos) ?>)
	     (> pos (+ 1 (point-min)))
	     (not (eq (char-after (1- pos)) ?/)))
    (save-excursion
      (when (search-backward "<" nil t 1)
	(and (looking-at hopjs-re-close-tag)
	     (= (match-end 0) (1+ pos)))))))

;*---------------------------------------------------------------------*/
;*    hopjs-opening-tag-p ...                                          */
;*---------------------------------------------------------------------*/
(defun hopjs-opening-tag-p (pos)
  (when (and (eq (char-after pos) ?<) (< pos (- (point-max) 1)))
    (save-excursion
      (when (looking-at hopjs-re-open-tag)
	(let ((tag (buffer-substring-no-properties
		    (match-beginning 1) (match-end 1))))
	  (not (member tag hopjs-special-tags)))))))

;*---------------------------------------------------------------------*/
;*    hopjs-find-opening-tag ...                                       */
;*---------------------------------------------------------------------*/
(defun hopjs-find-opening-tag (pos)
  (save-excursion
    (goto-char pos)
    (let ((depth 1)
	  (res 'loop))
      (while (eq res 'loop)
	(if (re-search-backward hopjs-re-any-tag nil t 1)
	    (progn
	      (unless (hopjs-in-string-comment-p (match-beginning 0))
		(cond
;* 		 ((looking-at hopjs-re-standalone-tag)                 */
;* 		  (message "hopjs-find-opening-tag, standalone [%s]"   */
;* 			   (buffer-substring-no-properties             */
;* 			    (match-beginning 0) (match-end 0)))        */
;* 		  nil)                                                 */
		 ((looking-at hopjs-re-end-tag)
		  (setq depth (1+ depth)))
		 ((looking-at hopjs-re-close-tag)
		  (setq depth (1+ depth)))
		 (t
		  (looking-at hopjs-re-open-tag)
		  (unless (member (buffer-substring-no-properties
				   (match-beginning 1) (match-end 1))
				  hopjs-special-tags)
		    (if (= depth 1)
			(setq res 
			      (buffer-substring-no-properties
			       (match-beginning 1) (match-end 1)))
		      (setq depth (1- depth))))))))
	  (setq res nil)))
      res)))

;*---------------------------------------------------------------------*/
;*    hopjs-find-closing-tag ...                                       */
;*---------------------------------------------------------------------*/
(defun hopjs-find-closing-tag (pos)
  (save-excursion
    (goto-char pos)
    (let ((depth 1)
	  (res 'loop))
      (while (eq res 'loop)
	(if (re-search-forward hopjs-re-any-tag nil t 1)
	    (let ((beg (match-beginning 0))
		  (end (match-end 0)))
	      (unless (hopjs-in-string-comment-p beg)
		(goto-char beg)
		(cond
;* 		 ((looking-at hopjs-re-standalone-tag)                 */
;* 		  nil)                                                 */
		 ((looking-at hopjs-re-open-tag)
		  (unless (member (buffer-substring-no-properties
				   (match-beginning 1) (match-end 1))
				  hopjs-special-tags)
		    (setq depth (1+ depth))))
		 ((looking-at hopjs-re-end-tag)
		  (if (= depth 1)
		      (setq res 'tag)
		    (setq depth (1- depth))))
		 (t
		  (if (= depth 1)
		      (progn
			(looking-at hopjs-re-close-tag)
			(setq res 
			      (buffer-substring-no-properties
			       (match-beginning 1) (match-end 1))))
		    (setq depth (1- depth))))))
	      (goto-char end))
	  (setq res nil)))
      res)))

;*---------------------------------------------------------------------*/
;*    hopjs-tag-matching ...                                           */
;*---------------------------------------------------------------------*/
(defun hopjs-tag-matching ()
  (interactive)
  (hopjs-unhighlight-tags)
  (cond
   ((hopjs-closing-tag-p (1- (point)))
    (if (> (point) 3)
	(let* ((tag (buffer-substring-no-properties
		     (match-beginning 1) (match-end 1)))
	       (beg (match-beginning 1))
	       (end (match-end 1))
	       (otag (hopjs-find-opening-tag (match-beginning 0))))
	  (cond
	   ((not otag)
	    (hopjs-highlight-tag 'hopjs-nomatch-face beg end))
	   ((string-equal tag otag)
	    (hopjs-highlight-tag
	     'hopjs-match-face beg end)
	    (hopjs-highlight-tag
	     'hopjs-match-face (match-beginning 1) (match-end 1)))
	   (t
	    (hopjs-highlight-tag
	     'hopjs-nomatch-face beg end)
	    (hopjs-highlight-tag
	     'hopjs-nomatch-face (match-beginning 1) (match-end 1)))))
      (hopjs-unhighlight-tags)))
   ((hopjs-opening-tag-p (point))
    (cond
     ((looking-at hopjs-re-standalone-tag)
      (hopjs-unhighlight-tags))
     ((< (point) (- (point-max) 3))
      (let* ((tag (buffer-substring-no-properties
		   (match-beginning 1) (match-end 1)))
	     (beg (match-beginning 1))
	     (end (match-end 1))
	     (otag (hopjs-find-closing-tag (+ 1 (match-end 0)))))
	(cond
	 ((not otag)
	  (hopjs-highlight-tag 'hopjs-nomatch-face beg end))
	 ((eq otag 'tag)
	  t)
	 ((string-equal tag otag)
	  (hopjs-highlight-tag 'hopjs-match-face beg end)
	  (hopjs-highlight-tag
	   'hopjs-match-face (match-beginning 1) (match-end 1)))
	 (t
	  (hopjs-highlight-tag 'hopjs-nomatch-face beg end)
	  (hopjs-highlight-tag
	   'hopjs-nomatch-face (match-beginning 1) (match-end 1))))))
     (t
      (hopjs-unhighlight-tags))))
   (t
    (hopjs-unhighlight-tags))))

;*---------------------------------------------------------------------*/
;*    hopjs-forward-sexp ...                                           */
;*---------------------------------------------------------------------*/
(defun hopjs-forward-sexp ()
  (if (hopjs-opening-tag-p (point))
      (if (looking-at hopjs-re-standalone-tag)
	  (goto-char (match-end 0))
	(let ((otag (hopjs-find-closing-tag (+ 1 (match-end 0)))))
	  (if otag
	      (goto-char (match-end 0))
	    (let ((forward-sexp-function nil))
	      (forward-sexp 1)))))
    (let ((forward-sexp-function nil))
      (forward-sexp 1))))

;*---------------------------------------------------------------------*/
;*    hopjs-backward-sexp ...                                          */
;*---------------------------------------------------------------------*/
(defun hopjs-backward-sexp ()
  (if (hopjs-closing-tag-p (1- (point)))
      (let ((otag (hopjs-find-opening-tag (match-beginning 0))))
	(if otag
	    (goto-char (match-beginning 0))
	  (let ((backward-sexp-function nil))
	    (forward-sexp -1))))
    (let ((forward-sexp-function nil))
      (forward-sexp -1))))

;*---------------------------------------------------------------------*/
;*    forward-sexp-function ...                                        */
;*---------------------------------------------------------------------*/
(make-variable-buffer-local 'forward-sexp-function)

(setq forward-sexp-function
      #'(lambda (arg)
	  (interactive)
	  (cond
	   ((= arg 1)
	    (hopjs-forward-sexp))
	   ((= arg -1)
	    (hopjs-backward-sexp))
	   (t 
	    (let ((forward-sexp-function nil))
	      (forward-sexp arg))))))

;*---------------------------------------------------------------------*/
;*    hopjs-balloon-started-p ...                                      */
;*    -------------------------------------------------------------    */
;*    A buffer local variable that tells if balloon is already all     */
;*    set on the requesting buffer.                                    */
;*---------------------------------------------------------------------*/
(defvar hopjs-balloon-started-p nil)
(make-variable-buffer-local 'hopjs-balloon-started-p)
(defvar hopjs-balloon-old-binding nil)
(make-variable-buffer-local 'hopjs-balloon-old-binding)
(defvar hopjs-balloon-old-global-binding nil)

;*---------------------------------------------------------------------*/
;*    hopjs-balloon-start ...                                          */
;*---------------------------------------------------------------------*/
(defun hopjs-balloon-start ()
  (unless hopjs-balloon-started-p
    (setq hopjs-balloon-started-p t)
    (setq hopjs-balloon-old-binding
	  (global-key-binding hopjs-balloon-binding))
    (unless hopjs-balloon-old-global-binding
      (setq hopjs-balloon-old-global-binding 
	    hopjs-balloon-old-binding)))
  (local-set-key hopjs-balloon-binding
		 #'(lambda (event)
		     (interactive "e")
		     (hopjs-balloon-mouse-hook event)
		     (cond
		      (hopjs-balloon-old-binding
		       (funcall hopjs-balloon-old-binding event))
		      (hopjs-balloon-old-global-binding
		       (funcall hopjs-balloon-old-global-binding event))))))

;*---------------------------------------------------------------------*/
;*    hopjs-balloon-stop ...                                           */
;*---------------------------------------------------------------------*/
(defun hopjs-balloon-stop ()
  (local-unset-key hopjs-balloon-binding)
  (if hopjs-balloon-old-binding
      (local-set-key hopjs-balloon-binding hopjs-balloon-old-binding)))

;*---------------------------------------------------------------------*/
;*    hopjs-balloon-actions ...                                        */
;*---------------------------------------------------------------------*/
(defvar hopjs-balloon-actions '())

;*---------------------------------------------------------------------*/
;*    hopjs-add-balloon-action ...                                     */
;*---------------------------------------------------------------------*/
(defun hopjs-add-balloon-action (label pred action)
  (setq hopjs-balloon-actions
	(cons (cons label (cons pred action))
	      hopjs-balloon-actions)))

;*---------------------------------------------------------------------*/
;*    hopjs-remove-balloon-action ...                                  */
;*---------------------------------------------------------------------*/
(defun hopjs-remove-balloon-action (label)
  (let ((cell (assq label hopjs-balloon-actions)))
    (when (consp cell)
      (setq hopjs-balloon-actions (delq cell hopjs-balloon-actions)))
    (when (null hopjs-balloon-actions)
      (hopjs-balloon-stop))))

;*---------------------------------------------------------------------*/
;*    hopjs-balloon-mouse-point ...                                    */
;*---------------------------------------------------------------------*/
(defvar hopjs-balloon-mouse-point nil)
(defvar hopjs-balloon-mouse-buffer nil)

;*---------------------------------------------------------------------*/
;*    hopjs-balloon-get-buffer ...                                     */
;*---------------------------------------------------------------------*/
(defun hopjs-balloon-get-buffer ()
  hopjs-balloon-mouse-buffer)

;*---------------------------------------------------------------------*/
;*    hopjs-balloon-get-point ...                                      */
;*---------------------------------------------------------------------*/
(defun hopjs-balloon-get-point ()
  hopjs-balloon-mouse-point)

;*---------------------------------------------------------------------*/
;*    hopjs-balloon-mouse-hook ...                                     */
;*---------------------------------------------------------------------*/
(defun hopjs-balloon-mouse-hook (event)
  (when (eventp event)
    (let ((point (event-closest-point event))
	  (win (event-window event))
	  (l hopjs-balloon-actions)
	  (found nil))
      (setq hopjs-balloon-mouse-buffer (event-buffer event))
      (setq hopjs-balloon-mouse-point point)
      (while (and (not found) (consp l))
	(if (funcall (car (cdr (car l))) point win)
	    (setq found (car l))
	  (setq l (cdr l))))
      (when found (funcall (cdr (cdr found)))))))

;*---------------------------------------------------------------------*/
;*    hopjs-word-at-point ...                                          */
;*---------------------------------------------------------------------*/
(defun hopjs-word-at-point (pos)
  (let ((beg (progn (backward-word) (point)))
	(end (progn (forward-word 1) (point))))
    (buffer-substring-no-properties beg end)))

;*---------------------------------------------------------------------*/
;*    hopjs-doc-index-find ...                                         */
;*---------------------------------------------------------------------*/
(defun hopjs-doc-index-find (word table)
  (when (> (length word) 0)
    (let* ((key (aref word 0))
	   (idx (if (and (>= key ?a) (<= key ?z)) (- key ?a) 26))
	   (bucket (aref table idx)))
      (assoc word bucket))))
      
;*---------------------------------------------------------------------*/
;*    hopjs-doc-at-point ...                                           */
;*---------------------------------------------------------------------*/
(defun hopjs-doc-at-point (pos)
  (interactive "d")
  (let* ((word (downcase (hopjs-word-at-point pos)))
	 (entry (hopjs-doc-index-find word hopjs-doc-index-table)))
    (when entry
      (let ((url (assq 'url (cdr entry))))
	(when url
	  (start-process "system" nil "sh" "-c"
			 (format "%s file://%s/%s" hopjs-navigator hopjs-doc-dir
				 (cdr url))))))))

;*---------------------------------------------------------------------*/
;*    init                                                             */
;*---------------------------------------------------------------------*/
;; (autoload 'hopjs-mode-hook "hopjs" "Hop.js javascript mode hook" t)
;; (add-hook 'js-mode-hook 'hopjs-mode-hook)
