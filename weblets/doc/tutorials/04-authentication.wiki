<doc> Access control

== Description ==

This tutorial shows how accesses can be controlled in HOP. It teaches
how to protect local resources and how to request authentication from
clients. This tutorial mainly shows how to use the facilities
described in the ,(<APIREF> (<I> "Access Control") "authentication.wiki")
page.

== Users ==

Unless at least one user is declared, no HOP authentication and access
control can take place. The RC file that is loaded on startup is
generally a good place to declare users. Users are declared
by the means of the ++add-user!++ function. A function may be granted the
permission to read directories and to execute services. A user is refereed to
by a name. It is authenticated by a password. It carries attributes that
specified his granted authorization. 

~~ When HOP authenticates the requests it intercepts. For that,
it uses three complementary techniques.
  - The first one uses an extension of URLs. The host component of a URL 
 may be augmented with a //user authentication//. The syntax of this extension
 is the following: the host destination is prefixed with 
 ++<name>:<password>@++. For instance, when the HTTP request:
 ++http://user:456789@foo.nowhere.org/tmp++ is intercepted by HOP, the
 following authenticate the request as belonging to user named ++user++,
 whose unencrypted password is ++456789++.
  - The header of an [[http://www.w3.org/Protocols/rfc2616/rfc2616.html|HTTP]]
 request may contains two authentication fields:
   * authorization:
   * proxy-authorization:
 theses contain unencrypted user authentication.
  - //Cookies// may hold users authentication.


The authenticated user is stored in the ++user++ field of the instance
of the class ::http-request that represents the request. It can be
used by service for implementing access restriction.

== Implementing access restriction in services ==

Let's imagine a weblet ++weblet-1++ that restricts its execution to
users granted the permission to execute a service named
++service-1++. A possible implementation of that weblet could be:

<code>
  (define-service (weblet-1)
     (if (authorized-service? (the-current-request) 'service-1)
         ... the actual implementation ...
         (user-access-denied (the-current-request))))
</code>

If the authentication fails, the server sends back a //request for 
authentication// to the client. The general behavior of web browser
when intercepting such requests is to pop up a window prompting a user
and a password and to send back this information to the server.

== Implementing authentication with cookies ==

More elaborated access controls can be programmed with //cookies//. For the
sake of the example, let us study the implementation of the authentication of 
,(<A> :href (format "http://localhost:~a/hop/hz" (hop-port))
       (<SPAN> :style "font-variant: small-caps" "Hz")) weblets manager.

~~ Here is the declaration of the ++hz++ service:

<code>
  (define-service (hz)
     (let ((req (the-current-request)))
        (if (users-added?)
            (let ((user (hz-get-access req)))
	       (if (and (user? user)
		        (user-authorized-service? user 'hz))
		   (hz-main req user)
		   (hz-authenticate req)))
            (hz-main req #f 'local))))
</code>

When users have been added, the main 
,(<SPAN> :style "font-variant: small-caps" "Hz") functions invokes the
function ++hz-get-access++ that checks if the received request contains
user authentication. Its implementation is:

<code>
  (define (hz-get-access req)
     (let ((cookie (http-cookie-get req "hop_hz")))
        (if (string? cookie)
	    (let ((exp (with-input-from-string (base64-decode cookie) read)))
	       (and (pair? exp) (find-user-cookie exp))))))
</code>

That function search the request ++req++ in order to find the value
of the cookie named ++hop_hz++. When this cookie is found, ++hz-get-access++
parses its value using the regular ++read++ function. This returns a list
that is inspected with the function ++find-user-cookie++. Its definition is:

<code>
  (define (find-user-cookie exp)
     (let* ((user (memq :user exp))
	    (passwd (memq :passwd exp)))
        (and (pair? user) (pair? (cdr user)) (symbol? (cadr user))
	     (pair? passwd) (pair? (cdr passwd)) (symbol? (cadr passwd))
	     (find-user/encrypt (symbol->string (cadr user))
		  	        (symbol->string (cadr passwd))
			        hz-encrypt-password))))
</code>

An encrypted password is contained in that list. It is associated with
the keyword :passwd. Because that password can be read by anyhow that
has access to the cookies stored on the client that has emitted the request,
HOP restrict the extent of the password. The password is encoded
by the function ++hz-encrypt-password++ whose implementation is:

<code>
  (define (hz-encrypt-password p)
     (string-append (hz-session-key) p))
</code>

Because password are encrypted, if that cookie is stolen by a malicious user,
it cannot be used on another instance of HOP and it is valid until the
++hz-session-key++ changes. This is up to the 
,(<SPAN> :style "font-variant: small-caps" "Hz") to change its key 
frequently enough. For instance, it may change it when the number
of requests handled by HOP exceeded a limit.

~~ The function ++login++ is used to let users log in. It
implementation is:

<code>
  (define (login req name pass local)
     ~(let ((svc ($hz/setcookie $(begin name).value
	  		        $(begin pass).value
			        (if $(begin local).checked "local" "share")))
	    (cback (lambda (http)
		      (let ((date (new Date)))
		         (date.setMinutes
			   (+ (date.getMinutes) $(hz-auto-logout-minute)))
		         (cookie-set! "hop_hz"
                                      http
                                      $(http-request-path req)
                                      #f
                                      date)
		         (set! location $(http-request-path req))))))
         (with-hop svc cback)))
</code>

It relies on the service ++hz/setcookie++ that stores a cookie on the client.
That cookie will be automatically transmitted to server by client on further
requests to ,(<SPAN> :style "font-variant: small-caps" "Hz"). It implementation
is:

<code>
  (define-service (hz/setcookie name passwd mode)
     (let* ((pd (hz-encrypt-password
	         (md5sum (string-append name " " passwd))))
	    (cookie `(user: ,name passwd: ,pd mode: ,mode))
	    (p (open-output-string)))
        (display cookie p)
        (let ((s (close-output-port p)))
	   (instantiate::http-response-string
	      (body (base64-encode s))))))
</code>

In order to log out, users use:

<code>
  (define (logout req)
     (let ((path (http-request-path req)))
        ~(let ((path $path))
	    (cookie-remove! "hop_hz" path)
	    (set! location path))))
</code>

</doc>
