;; part of compile-module
(define (infix-op nb-operands-min nb-operands-max infix-operator . Ldefault-val)
   (lambda (operands)
      (let ((nb-operands (length operands)))
	 (and (>=fx nb-operands nb-operands-min)
	      (or (not nb-operands-max)
		  (<=fx nb-operands nb-operands-max))
	      (if (=fx nb-operands 0)
		  (car Ldefault-val)
		  (let ((comp-operands (map-node-compile operands)))
		     (let loop ((res (car comp-operands))
				(rest (cdr comp-operands)))
			(if (null? rest)
			    (string-append "(" res ")")
			    (loop (string-append res infix-operator (car rest))
				  (cdr rest))))))))))

(define (postfix-op postfix-operator)
   (lambda (operands)
      (and (pair? operands)
	   (null? (cdr operands))
	   (string-append "(" ((car operands).compile) postfix-operator ")"))))

(define (prefix-op prefix-operator)
   (lambda (operands)
      (and (pair? operands)
	   (null? (cdr operands))
	   (string-append "(" prefix-operator ((car operands).compile) ")"))))

(define (hole-op nb-holes . pattern)
   (lambda (operands)
      (and (=fx (length operands) nb-holes)
	   (let ((comp-operands (map-node-compile operands)))
	      (let loop ((res "")
			 (pattern pattern)
			 (operands comp-operands))
		 (cond
		    ((null? pattern) (string-append "(" res ")"))
		    ((string? (car pattern))
		     (loop (string-append res (car pattern))
			   (cdr pattern)
			   operands))
		    ((number? (car pattern))
		     (loop (string-append res (list-ref comp-operands
							(car pattern)))
			   (cdr pattern)
			   operands))
		    (else
		     (loop (string-append res (car operands))
			   (cdr pattern)
			   (cdr operands)))))))))

(define (minus-op operands)
   (cond
      ((null? operands) #f)
      ((null? (cdr operands))
       (string-append "(-" ((car operands).compile) ")"))
      (else
       ((infix-op 1 #f "-") operands))))

(define (div-op operands)
   (cond
      ((null? operands) #f)
      ((null? (cdr operands))
       (string-append "(1/" ((car operands).compile) ")"))
      (else
       ((infix-op 1 #f "/") operands))))

(define (vector-op operands)
   (let ((args (separated-list (map-node-compile operands) ", ")))
      (string-append "[" args "]")))
		  
(define (id operand)
   (and (pair? operand)
	(null? (cdr operand))
	(operand.compile)))

(define (jsNew-op operands)
   (and (not (null? operands))
	(let* ((c ((car operands).compile))
	       (args (separated-list (map-node-compile (cdr operands))
				     ", ")))
	   (string-append "new " c "(" args ")"))))

(define (jsCall-op operands)
   (and (not (null? operands))
	(not (null? (cdr operands)))
	(let* ((o ((car operands).compile))
	       (f ((cadr operands).compile))
	       (args-w/ ((infix-op 0 #f ", " "") (cddr operands))) ;; with parenthesis
	       (args (substring args-w/ 1 (- (string-length args-w/) 1))))
	   (string-append f ".call(" o ", " args ")"))))

(define (jsMethodCall-op operands)
   (and (not (null? operands))
	(not (null? (cdr operands)))
	(let* ((o ((car operands).compile))
	       (field ((cadr operands).compile))
	       (args (separated-list (map-node-compile (cddr operands))
				     ", ")))
	   (string-append o "[" field "](" args ")"))))
	   
(define *optimizable-operators*
   `(
    (sci_isEq ,(infix-op 2 2 "==="))
    (sci_isEqv ,(infix-op 2 2 "==="))

    (sci_equal ,(infix-op 2 2 "==="))
    (sci_less ,(infix-op 2 2 "<"))
    (sci_greater  ,(infix-op 2 2 ">"))
    (sci_lessEqual ,(infix-op 2 2 "<="))
    (sci_greaterEqual ,(infix-op 2 2 ">="))
    (sci_isPositive ,(postfix-op "> 0"))
    (sci_isNegative ,(postfix-op "< 0"))
    (sci_plus ,(infix-op 0 #f "+" "0"))
    (sci_multi ,(infix-op 0 #f "*" "1"))
    (sci_minus ,minus-op)
    (sci_div ,div-op)
    (sci_modulo ,(infix-op 2 2 "%"))
    
    (sci_exact2inexact ,id)
    (sci_inexact2exact ,id)
    
    (sci_not ,(prefix-op "!"))
    
    (sci_cons ,(hole-op 2 "new sc_Pair(" 'car ", " 'cdr ")"))
    (sci_isPair ,(postfix-op " instanceof sc_Pair"))
    (sci_car ,(postfix-op ".car"))
    (sci_cdr ,(postfix-op ".cdr"))
    (sci_setCar ,(hole-op 2 'p ".car = " 'val))
    (sci_setCdr ,(hole-op 2 'p ".cdr = " 'val))
    
    (sci_caar ,(postfix-op ".car.car"))
    (sci_cadr ,(postfix-op ".cdr.car"))
    (sci_cdar ,(postfix-op ".car.cdr"))
    (sci_cddr ,(postfix-op ".cdr.cdr"))
    (sci_caaar ,(postfix-op ".car.car.car"))
    (sci_cadar ,(postfix-op ".car.cdr.car"))
    (sci_caadr ,(postfix-op ".cdr.car.car"))
    (sci_caddr ,(postfix-op ".cdr.cdr.car"))
    (sci_cdaar ,(postfix-op ".car.car.cdr"))
    (sci_cdadr ,(postfix-op ".cdr.car.cdr"))
    (sci_cddar ,(postfix-op ".car.cdr.cdr"))
    (sci_cdddr ,(postfix-op ".cdr.cdr.cdr"))
    (sci_caaaar ,(postfix-op ".car.car.car.car"))
    (sci_caadar ,(postfix-op ".car.cdr.car.car"))
    (sci_caaadr ,(postfix-op ".cdr.car.car.car"))
    (sci_caaddr ,(postfix-op ".cdr.cdr.car.car"))
    (sci_cdaaar ,(postfix-op ".car.car.car.cdr"))
    (sci_cdadar ,(postfix-op ".car.cdr.car.cdr"))
    (sci_cdaadr ,(postfix-op ".cdr.car.car.cdr"))
    (sci_cdaddr ,(postfix-op ".cdr.cdr.car.cdr"))
    (sci_cadaar ,(postfix-op ".car.car.cdr.car"))
    (sci_caddar ,(postfix-op ".car.cdr.cdr.car"))
    (sci_cadadr ,(postfix-op ".cdr.car.cdr.car"))
    (sci_cadddr ,(postfix-op ".cdr.cdr.cdr.car"))
    (sci_cddaar ,(postfix-op ".car.car.cdr.cdr"))
    (sci_cdddar ,(postfix-op ".car.cdr.cdr.cdr"))
    (sci_cddadr ,(postfix-op ".cdr.car.cdr.cdr"))
    (sci_cddddr ,(postfix-op ".cdr.cdr.cdr.cdr"))

    (sci_isNull ,(postfix-op " === null"))

    (sci_isSymbol ,(hole-op 1 "typeof " 'hole " === 'string'"))

    (sci_isString ,(postfix-op " instanceof sc_String"))
    (sci_isStringEqual ,(hole-op 2 'str1 ".val === " 'str2 ".val"))
    (sci_isStringLess ,(hole-op 2 'str1 ".val < " 'str2 ".val"))
    (sci_isStringGreater ,(hole-op 2 'str1 ".val > " 'str2 ".val"))
    (sci_isStringLessEqual ,(hole-op 2 'str1 ".val <= " 'str2 ".val"))
    (sci_isStringGreaterEqual ,(hole-op 2 'str1 ".val >= " 'str2 ".val"))
    (sci_symbolAppend ,(infix-op 0 #f "+" "''"))

    (sci_isVector ,(postfix-op " instanceof sc_Vector"))
    (sci_vector ,vector-op)
    (sci_vectorLength ,(postfix-op ".length"))
    (sci_vectorRef ,(hole-op 2 'vector "[" 'index "]"))
    (sci_vectorSet ,(hole-op 3 'vector "[" 'index "] = " 'val))

    (sci_isProcedure ,(hole-op 1 "typeof " 'hole " === 'function'"))

    (sci_makeStruct ,(hole-op 1 "new sc_Struct(" 'name ")"))
    (sci_isStruct ,(postfix-op " instanceof sc_Struct"))
    (sci_isStructNamed ,(hole-op 2 "(" 1 " instanceof sc_Struct) &&"
				 " (" 1 ".name === " 0 ")"))
    (sci_getStructField ,(hole-op 3 0 "[" 2 "]"))
    (sci_setStructField ,(hole-op 4 0 "[" 2 "] = " 3))

    ;; scheme2js extension
    (sci_jsField ,(hole-op 2 'o "[" 'field "]"))
    (sci_setJsField ,(hole-op 3 'o "[" 'field "] = " 'val))
    (sci_deleteJsField ,(hole-op 2 "delete " 'o "[" 'field "]"))
    (sci_jsNew ,jsNew-op)
    (sci_jsCall ,jsCall-op)
    (sci_jsMethodCall ,jsMethodCall-op)
))

(define (compile-optimized-call operator::pobject
				operands::pair-nil)
   (if (inherits-from? operator Var-ref)
       (let* ((var operator.var)
	      (id var.js-id)
	      (optimize-fun (and (not operator.var.muted)
				 id
				 (assq id *optimizable-operators*))))
	  (and optimize-fun ((cadr optimize-fun) operands)))))
