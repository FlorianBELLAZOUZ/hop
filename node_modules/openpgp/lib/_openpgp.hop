;*=====================================================================*/
;*    .../prgm/project/hop/hop/node_modules/openpgp/lib/_openpgp.hop   */
;*    -------------------------------------------------------------    */
;*    Author      :  Manuel Serrano                                    */
;*    Creation    :  Thu Sep  6 15:19:35 2018                          */
;*    Last change :  Mon Mar  9 10:03:25 2020 (serrano)                */
;*    Copyright   :  2018-21 Manuel Serrano                            */
;*    -------------------------------------------------------------    */
;*    Openpgp Hop binding                                              */
;*=====================================================================*/

;*---------------------------------------------------------------------*/
;*    The module                                                       */
;*---------------------------------------------------------------------*/
(module openpgp
   (library hopscript hop hopwidget nodejs web openpgp)
   (export (hopscript %this this %scope %module)))

;*---------------------------------------------------------------------*/
;*    define-javascript ...                                            */
;*---------------------------------------------------------------------*/
(define-macro (define-javascript proto . body)
   (let* ((id (car proto))
	  (len (-fx (length proto) 2))
	  (name (symbol->string id)))
      `(js-put! exports (& ,name)
	  (js-make-function %this
	     (lambda ,(cdr proto) ,@body)
	     (js-function-arity ,len 0)
	     (js-function-info :name ,name :len ,len))
	  #f %this)))

;*---------------------------------------------------------------------*/
;*    js-pgp-key? ...                                                  */
;*---------------------------------------------------------------------*/
(define (js-pgp-key? this)
   (when (isa? this JsWrapper)
      (with-access::JsWrapper this (obj)
	 (pgp-key? obj))))
   
;*---------------------------------------------------------------------*/
;*    js-pgp-subkey? ...                                               */
;*---------------------------------------------------------------------*/
(define (js-pgp-subkey? this)
   (when (isa? this JsWrapper)
      (with-access::JsWrapper this (obj)
	 (pgp-subkey? obj))))

;*---------------------------------------------------------------------*/
;*    js-pgp-keyring? ...                                              */
;*---------------------------------------------------------------------*/
(define (js-pgp-keyring? this)
   (when (isa? this JsWrapper)
      (with-access::JsWrapper this (obj)
	 (pgp-key-db? obj))))
   
;*---------------------------------------------------------------------*/
;*    js-pgp-composition? ...                                          */
;*---------------------------------------------------------------------*/
(define (js-pgp-composition? this)
   (when (isa? this JsWrapper)
      (with-access::JsWrapper this (obj)
	 (pgp-composition? obj))))
   
;*---------------------------------------------------------------------*/
;*    hopscript ...                                                    */
;*    -------------------------------------------------------------    */
;*    This is the function called by JavaScript when the Hop module    */
;*    is required. It binds the exports field of the newly             */
;*    allocated module                                                 */
;*---------------------------------------------------------------------*/
(define (hopscript %this this %scope %module)
   (&with!
      
      (define (not-a-key this)
	 (js-raise-type-error %this
	    (format "not a key (~a)" (typeof this)) this))
      
      (define (not-a-subkey this)
	 (js-raise-type-error %this
	    (format "not a subkey (~a)" (typeof this)) this))
      
      (define (not-a-composition this)
	 (js-raise-type-error %this
	    (format "not a composition (~a)" (typeof this)) this))
      
      (define (not-a-keyring this)
	 (js-raise-type-error %this
	    (format "not a key ring (~a)" (typeof this)) this))
      
      (define (jskey->key this)
	 (if (isa? this JsWrapper)
	     (with-access::JsWrapper this (obj)
		(if (pgp-key? obj)
		    obj
		    (not-a-key this)))
	     (not-a-key this)))
      
      (define (js-jssubkey->subkey this)
	 (if (isa? this JsWrapper)
	     (with-access::JsWrapper this (obj)
		(if (pgp-subkey? obj)
		    obj
		    (not-a-subkey this)))
	     (not-a-subkey this)))
      
      (define (js-composition->composition this)
	 (if (isa? this JsWrapper)
	     (with-access::JsWrapper this (obj)
		(if (pgp-composition? obj)
		    obj
		    (not-a-composition this)))
	     (not-a-composition this)))

      (define (js-pgp-signature-message this)
	 (if (js-pgp-composition? this)
	     (with-access::JsWrapper this (obj)
		(let ((r (pgp-signature-message obj)))
		   (if (string? r)
		       (js-string->jsstring r)
		       r)))
	     (not-a-composition this)))
      
      (define (js-pgp-verify this kmanager msg)
	 (cond
	    ((and (not (isa? kmanager JsProcedure))
		  (not (js-pgp-keyring? kmanager)))
	     (js-raise-type-error %this
		(format "Illegal keyManager provider (~a)" (typeof kmanager)) kmanager))
	    (else
	     (let ((r (pgp-verify (js-composition->composition this)
			 (if (js-pgp-keyring? kmanager)
			     (lambda (kid)
				(with-access::JsWrapper kmanager ((db obj))
				   (pgp-resolve-key db kid)))
			     (lambda (kid)
				(let ((r (js-call1-jsprocedure %this kmanager
					    (js-undefined) (js-string->jsstring kid))))
				   (if (isa? r JsArray)
				       (map! jskey->key (jsarray->list r %this))
				       '()))))
			 :msg (if (not (js-totest msg)) #f (js-tostring msg %this)))))
		(if (not r)
		    r
		    (js-vector->jsarray
		       (list->vector (map! subkey->jssubkey r))
		       %this))))))

      (define (js-pgp-decrypt this o)
	 (let* ((pkprovider (js-get o (& "passkeyProvider") %this))
		(pwprovider (js-get o (& "passwordProvider") %this))
		(kmanager (js-get o (& "keyManager") %this))
		(halgo (js-get o (& "hashAlgo") %this))
		(r (pgp-decrypt (js-composition->composition this)
		      :passkey-provider
		      (if (isa? pkprovider JsProcedure)
			  (lambda ()
			     (let ((r (js-call0-jsprocedure %this pkprovider
					 (js-undefined))))
				(if (eq? r #f)
				    r
				    (js-tostring r %this))))
			  (lambda ()
			     #f))
		      :password-provider
		      (if (isa? pwprovider JsProcedure)
			  (lambda (key)
			     (let ((r (js-call1-jsprocedure %this pwprovider
					 (js-undefined)
					 (key->jskey key))))
				(if (eq? r #f)
				    r
				    (js-tostring r %this))))
			  (lambda (key)
			     #f))
		      :key-manager
		      (cond
			 ((js-pgp-keyring? kmanager)
			  (lambda (kid)
			     (with-access::JsWrapper kmanager ((db obj))
				(pgp-resolve-key db kid))))
			 ((isa? kmanager JsProcedure)
			  (lambda (kid)
			     (let ((r (js-call1-jsprocedure %this kmanager
					 (js-undefined) (js-string->jsstring kid))))
				(if (isa? r JsArray)
				    (map! jskey->key (jsarray->list r %this))
				    '()))))
			 (else
			  (lambda (kid) '())))
		      :hash-algo
		      (if (js-totest halgo)
			  (string->symbol (js-tostring halgo %this))
			  'sha256))))
	    (if (eq? r #f)
		r
		(js-string->jsstring r))))
      
      (define key-prototype
	 (with-access::JsGlobalObject %this (js-object)
	    (let ((obj (js-new0 %this js-object)))
	       ;; toString
	       (js-bind! %this obj (& "toString")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (js-pgp-key? this)
				   (with-access::JsWrapper this (obj)
				      (js-string->jsstring
					 (pgp-key->string obj)))
				   (not-a-key this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "toString" :len 0)))
	       ;; subkeys
	       (js-bind! %this obj (& "subkeys")
		  :value (js-make-function %this
			   (lambda (this)
			      (if (js-pgp-key? this)
				  (with-access::JsWrapper this (obj)
				     (js-vector->jsarray
					(list->vector
					   (map! subkey->jssubkey (pgp-subkeys obj)))
					%this))
				  (not-a-key this)))
			   (js-function-arity 0 0)
			   (js-function-info :name "subkeys" :len 0)))
	       ;; the prototype
	       obj)))
      
      (define subkey-prototype
	 (with-access::JsGlobalObject %this (js-object)
	    (let ((obj (js-new0 %this js-object)))
	       ;; toString
	       (js-bind! %this obj (& "toString")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (js-pgp-subkey? this)
				   (with-access::JsWrapper this (obj)
				      (js-string->jsstring
					 (pgp-subkey->string obj)))
				   (not-a-key this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "toString" :len 0)))
	       ;; id
	       (js-bind! %this obj (& "id")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (js-pgp-subkey? this)
				   (with-access::JsWrapper this (obj)
				      (js-string->jsstring
					 (pgp-key-id obj)))
				   (not-a-key this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "id" :len 0)))
	       ;; fingerprint
	       (js-bind! %this obj (& "fingerprint")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (js-pgp-subkey? this)
				   (with-access::JsWrapper this (obj)
				      (js-string->jsstring
					 (pgp-key-fingerprint obj)))
				   (not-a-key this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "fingerprint" :len 0)))
	       ;; the prototype
	       obj)))
      
      (define composition-prototype
	 (with-access::JsGlobalObject %this (js-object)
	    (let ((obj (js-new0 %this js-object)))
	       ;; toString
	       (js-bind! %this obj (& "toString")
		  :value (js-make-function %this
			    (lambda (this format)
			       (if (js-pgp-composition? this)
				   (with-access::JsWrapper this (obj)
				      (js-string->jsstring
					 (pgp-write-string obj
					    :format (if (string=? "binary" (js-tostring format %this))
							'binary
							'armored))))
				   (not-a-composition this)))
			    (js-function-arity 1 0)
			    (js-function-info :name "toString" :len 1)))
	       ;; signatureMessage
	       (js-bind! %this obj (& "signatureMessage")
		  :value (js-make-function %this
			    js-pgp-signature-message
			    (js-function-arity 0 0)
			    (js-function-info :name "signatureMessage" :len 0)))
	       ;; verify
	       (js-bind! %this obj (& "verify")
		  :value (js-make-function %this
			    js-pgp-verify
			    (js-function-arity 2 0)
			    (js-function-info :name "verify" :len 2)))
	       ;; decrypt
	       (js-bind! %this obj (& "decrypt")
		  :value (js-make-function %this
			    js-pgp-decrypt
			    (js-function-arity 2 0)
			    (js-function-info :name "decrypt" :len 2)))
	       ;; the prototype
	       obj)))

      ;; keyring-add-key
      (define (keyring-add-key this key)
	 (cond
	    ((not (js-pgp-keyring? this))
	     (not-a-keyring this))
	    ((not (js-pgp-key? key))
	     (not-a-key this))
	    (else
	     (with-access::JsWrapper this ((db obj))
		(with-access::JsWrapper key (obj)
		   (pgp-add-key-to-db db obj))))))

      ;; keyring-add-keys
      (define (keyring-add-keys this keys)
	 (cond
	    ((not (js-pgp-keyring? this))
	     (not-a-keyring this))
	    (else
	     (with-access::JsWrapper this ((db obj))
		(js-array-maybe-foreach-procedure keys
		   (lambda (this key idx arr)
		      (with-access::JsWrapper key (obj)
			 (pgp-add-key-to-db db obj)))
		   (js-undefined)
		   %this
		   #f)))))

      ;; keyring-prototype
      (define keyring-prototype
	 (with-access::JsGlobalObject %this (js-object)
	    (let ((obj (js-new0 %this js-object)))
	       ;; toString
	       (js-bind! %this obj (& "toString")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (js-pgp-keyring? this)
				   (with-access::JsWrapper this (obj)
				      (js-stringlist->jsstring
					 (cons "keyring:"
					    (map (lambda (k)
						    (string-append (pgp-key->string k) " "))
					       (cdr obj)))))
				   (not-a-keyring this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "toString" :len 0)))
	       ;; addKey
	       (js-bind! %this obj (& "addKey")
		  :value (js-make-function %this
			    keyring-add-key
			    (js-function-arity 1 0)
			    (js-function-info :name "addKey" :len 1)))
	       ;; addKeys
	       (js-bind! %this obj (& "addKeys")
		  :value (js-make-function %this
			    keyring-add-keys
			    (js-function-arity 1 0)
			    (js-function-info :name "addKeys" :len 1)))
	       ;; resolve
	       (js-bind! %this obj (& "resolve")
		  :value (js-make-function %this
			    (lambda (this id)
			       (if (js-pgp-keyring? this)
				   (with-access::JsWrapper this ((db obj))
				      (let ((r (pgp-resolve-key db (js-tostring id %this))))
					 (if (not r)
					     r
					     (key->jskey r))))
				   (not-a-keyring this)))
			    (js-function-arity 1 0)
			    (js-function-info :name "resolve" :len 1)))
	       ;; the prototype
	       obj)))
      
      ;; js-key-alloc
      (define (js-key-alloc)
	 (with-access::JsGlobalObject %this (js-object)
	    (instantiateJsWrapper
	       (__proto__ key-prototype)
	       (obj #unspecified)
	       (data #unspecified))))
      
      ;; key->jskey
      (define (key->jskey key)
	 (let ((this (js-key-alloc)))
	    (with-access::JsWrapper this (obj)
	       (set! obj key)
	       this)))
      
      ;; subkey->jssubkey
      (define (subkey->jssubkey subkey)
	 (with-access::JsGlobalObject %this (js-object)
	    (instantiateJsWrapper
	       (__proto__ subkey-prototype)
	       (obj subkey)
	       (data #unspecified))))
      
      ;; js-pgp-key-construct
      (define (js-pgp-key-construct this str)
	 (let ((obj (if (js-pgp-key? this) this (js-key-alloc))))
	    (with-access::JsWrapper obj (key)
	       (pgp-read-string (js-tostring str %this)))
	    obj))
      
      ;; js-pgp-key
      (define js-pgp-key
	 (js-make-function %this
	    js-pgp-key-construct
	    (js-function-arity 1 0)
	    (js-function-info :name "Key" :len 1)
	    :prototype key-prototype
	    :alloc js-key-alloc))
      
      ;; js-keyring-alloc
      (define (js-keyring-alloc)
	 (with-access::JsGlobalObject %this (js-object)
	    (instantiateJsWrapper
	       (__proto__ keyring-prototype)
	       (obj #unspecified)
	       (data #unspecified))))
      
      ;; js-pgp-keyring-construct
      (define (js-pgp-keyring-construct this key)
	 (let ((kr (if (js-pgp-keyring? this) this (js-keyring-alloc))))
	    (with-access::JsWrapper kr (obj)
	       (set! obj (pgp-make-key-db))
	       (cond
		  ((isa? key JsArray) (keyring-add-keys kr key))
		  ((js-pgp-key? key) (keyring-add-key kr key))))
	    kr))
      
      ;; js-pgp-keyring
      (define js-pgp-keyring
	 (js-make-function %this
	    js-pgp-keyring-construct
	    (js-function-arity 1 0)
	    (js-function-info :name "KeyRing" :len 1)
	    :prototype keyring-prototype
	    :alloc js-keyring-alloc))
      
      ;; js-pgp-composition
      (define (js-pgp-composition compo)
	 (with-access::JsGlobalObject %this (js-object)
	    (instantiateJsWrapper
	       (__proto__ composition-prototype)
	       (obj compo)
	       (data #unspecified))))
      
      (with-access::JsGlobalObject %this (js-object js-error)
	 (let ((exports (js-new0 %this js-object)))
	    (js-put! %module (& "exports") exports #f %this)
	    ;; Key
	    (js-bind! %this exports (& "Key")
	       :value js-pgp-key :writable #f :enumerable #t)
	    ;; KeyRing
	    (js-bind! %this exports (& "KeyRing")
	       :value js-pgp-keyring :writable #f :enumerable #t)
	    ;; readKey
	    (define-javascript (readKey this obj)
	       (let ((file (js-tostring obj %this)))
		  (if (file-exists? file)
		      (js-vector->jsarray
			 (list->vector
			    (map! key->jskey (pgp-read-file file)))
			 %this)
		      (js-raise
			 (js-new %this js-error
			    (js-string->jsstring
			       (format "File not found ~s" file)))))))
	    ;; encrypt
	    (define-javascript (encrypt this msg keys passwords halgo salgo)
	       (cond
		  ((and (not (isa? keys JsArray)) (js-totest keys))
		   (js-raise-type-error %this
		      (format "Illegal keys (~a)" (typeof keys)) keys))
		  ((and (not (isa? passwords JsArray)) (js-totest passwords))
		   (js-raise-type-error %this
		      (format "Illegal passwords (~a)" (typeof passwords)) password))
		  (else
		   (js-pgp-composition
		      (pgp-encrypt (js-tostring msg %this)
			 (if (js-totest keys)
			     (map! jskey->key (jsarray->list keys %this))
			     '())
			 (if (js-totest password)
			     (map! (lambda (s) (js-tostring s %this)) (jsarray->list passwords %this))
			     '())
			 :hash-algo (string->symbol (js-tostring halgo %this))
			 :symmetric-algo (string->symbol (js-tostring salgo %this)))))))
	    ;; sign
	    (define-javascript (sign this msg key pprovider detached onep halgo)
	       (cond
		  ((not (js-pgp-key? key))
		   (js-raise-type-error %this
		      (format "sign: illegal key (~a)" (typeof key)) key))
		  ((not (isa? pprovider JsProcedure))
		   (js-raise-type-error %this
		      (format "sign: illegal password provider (~a)" (typeof pprovider)) pprovider))
		  (else
		   (js-pgp-composition
		      (pgp-sign (js-tostring msg %this)
			 (jskey->key key)
			 (lambda (key)
			    (js-tostring
			       (js-call1-jsprocedure %this pprovider
				  (js-undefined) (subkey->jssubkey key))
			       %this))
			 :detached-signature? detached
			 :one-pass? onep
			 :hash-algo (string->symbol (js-tostring halgo %this)))))))
	    ;; the module exports
	    exports
	    ))))

;*---------------------------------------------------------------------*/
;*    The module                                                       */
;*---------------------------------------------------------------------*/
hopscript
