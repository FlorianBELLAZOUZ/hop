;*=====================================================================*/
;*    .../hop/3.0.x/node_modules/markdown/lib/_markdown.hop            */
;*    -------------------------------------------------------------    */
;*    Author      :  Manuel Serrano                                    */
;*    Creation    :  Sun Jul  6 06:15:53 2014                          */
;*    Last change :  Wed Jul 29 17:13:23 2015 (serrano)                */
;*    Copyright   :  2014-15 Manuel Serrano                            */
;*    -------------------------------------------------------------    */
;*    MARKDOWN hop parser                                              */
;*=====================================================================*/

;*---------------------------------------------------------------------*/
;*    The module                                                       */
;*---------------------------------------------------------------------*/
(module _markdown

   (include "token.sch")
   
   (library hopscript hop hopwidget nodejs)
   
   (static  (class MDState
	       tag::symbol
	       ctor::procedure
	       (elements::pair-nil (default '()))
	       (attributes::pair-nil (default '()))
	       (value::obj (default #f))
	       (wrapper::obj (default #f))
	       (parent (default #f)))

	    (class MDBlock::MDState
	       (bob::bool (default #t)))
	    
	    (class MDSpan::MDState))
   
   (import markdown_md)
   
   (export (hopscript ::JsGlobalObject ::JsObject ::JsObject ::JsObject)
	   
	   <MARKDOWN:PARSE-ERROR>
	   <MARKDOWN:H1>
	   <MARKDOWN:H2>
	   <MARKDOWN:H3>
	   <MARKDOWN:H4>
	   <MARKDOWN:H5>
	   <MARKDOWN:CODE>
	   <MARKDOWN:PRE>
	   <MARKDOWN:LI>
	   <MARKDOWN:UL>
	   <MARKDOWN:OL>
	   <MARKDOWN:HR>
	   <MARKDOWN:EM>
	   <MARKDOWN:STRONG>
	   <MARKDOWN:P>
	   <MARKDOWN:A>
	   <MARKDOWN:IMG>
	   
	   (parse ip charset ctx)
	   (xml->markdown ::obj ::pair-nil)))

;*---------------------------------------------------------------------*/
;*    js-bind-tag! ...                                                 */
;*---------------------------------------------------------------------*/
(define-macro (js-bind-tag! %this obj tag)
   `(begin
       (js-bind! ,%this ,obj ',tag
	  :value (js-make-function ,%this
		    (lambda (this attrs . nodes)
		       (if (isa? attrs JsObject)
			   (if (null? nodes)
			       (apply ,(symbol-append '< tag '>)
				  (js-object->keyword-arguments attrs ,%this))
			       (apply ,(symbol-append '< tag '>)
				  (append
				     (js-object->keyword-arguments attrs ,%this)
				     nodes)))
			   (apply ,(symbol-append '< tag '>)
			      nodes)))
		    2 ',tag)
	  :writable #f
	  :enumerable #f)))

;*---------------------------------------------------------------------*/
;*    js-bind-tags! ...                                                */
;*---------------------------------------------------------------------*/
(define-macro (js-bind-tags! %this obj . tags)
   `(begin
       ,@(map (lambda (tag)
		 `(js-bind-tag! ,%this ,obj ,tag))
	    tags)))
   
;*---------------------------------------------------------------------*/
;*    hopscript ...                                                    */
;*---------------------------------------------------------------------*/
(define (hopscript %this this scope module)
   (with-access::JsGlobalObject %this (__proto__)
      
      (define js-markdown-prototype
	 (instantiate::JsObject
	    (__proto__ __proto__)
	    (extensible #t)))
      
      (define exports (js-get module 'exports %this))

      ;; bind the module in the markdown scope
      (js-put! scope 'module module #f %this)
      
      ;; XML tags
      (js-bind-tags! %this exports
	 MARKDOWN:H1 MARKDOWN:H2 MARKDOWN:H3 MARKDOWN:H4 MARKDOWN:H5
	 MARKDOWN:PRE MARKDOWN:CODE MARKDOWN:LI MARKDOWN:UL MARKDOWN:OL
	 MARKDOWN:HR MARKDOWN:EM MARKDOWN:STRONG MARKDOWN:P MARKDOWN:A
	 MARKDOWN:IMG)
      
      ;; parseFile
      (js-bind! %this exports 'parseFile
	 :value (js-make-function %this
		   (lambda (this file charset fontifier)
		      (let ((scope (nodejs-new-scope-object %this))
			    (root (js-string->jsstring
				     (dirname (js-tostring file %this)))))
			 ;; bind global properties in the document scope
			 (js-put! scope 'file file #f %this)
			 (js-put! scope 'ROOT root #f %this)
			 (js-put! scope 'module module #f %this)
			 ;; parse the markdown file
			 (let* ((xml (parse-file (js-tostring file %this)
					(if (eq? charset (js-undefined))
					    (hop-locale)
					    (js-tostring charset %this))
					scope
					fontifier))
				(res (instantiate::JsObject
					(__proto__ js-markdown-prototype))))
			    (js-put! res 'file file #f %this)
			    (js-put! res 'charset charset #f %this)
			    (js-put! res 'XML xml #f %this)
			    res)))
		   3 'parseFile)
	 :writable #f
	 :enumerable #f)
      ;; toMarkdown
      (js-bind! %this js-markdown-prototype 'toMarkdown
	 :value (js-make-function %this
		   (lambda (this)
		      (xml->markdown (js-get this 'XML %this) #f))
		   0 'toMarkdown)
	 :writable #f
	 :enumerable #f)))

;*---------------------------------------------------------------------*/
;*    eval-markdown ...                                                */
;*---------------------------------------------------------------------*/
(define (eval-markdown exp ctx)
   (if (pair? ctx)
       (eval `(let (,ctx) ,exp))
       (eval exp)))

;*---------------------------------------------------------------------*/
;*    flatten ...                                                      */
;*---------------------------------------------------------------------*/
(define (flatten l)
   (cond
      ((null? l) l)
      ((pair? l) (append (flatten (car l)) (flatten (cdr l))))
      (else (list l))))

;*---------------------------------------------------------------------*/
;*    MDState-tag ...                                                  */
;*---------------------------------------------------------------------*/
(define (MDState-tag s)
   (with-access::MDState s (tag)
      tag))

;*---------------------------------------------------------------------*/
;*    markdown-debug ...                                               */
;*---------------------------------------------------------------------*/
(define markdown-debug
   (let ((env (getenv "NODE_DEBUG")))
      (and (string? env) (string-contains env "markdown"))))

;*---------------------------------------------------------------------*/
;*    <MARKDOWN:PARSE-ERROR> ...                                       */
;*---------------------------------------------------------------------*/
(define (<MARKDOWN:PARSE-ERROR> str)
   (<SPAN> :hssclass "hop-parse-error"
      str))

;*---------------------------------------------------------------------*/
;*    markdown-name ...                                                */
;*---------------------------------------------------------------------*/
(define (markdown-name expr)
   (let* ((s (with-output-to-string
		(lambda ()
		   (let loop ((e expr))
		      (cond
			 ((pair? e)
			  (for-each loop e))
			 ((isa? e xml-markup)
			  (with-access::xml-markup e (body)
			     (loop body)))
			 ((null? e)
			  #unspecified)
			 (else
			  (display e)))))))
	  (s2 (pregexp-replace* "  |\n" s " ")))
      (pregexp-replace* "^ +| +$" s2 "")))

;*---------------------------------------------------------------------*/
;*    markdown-read-error ...                                          */
;*---------------------------------------------------------------------*/
(define (markdown-read-error msg obj port)
   (raise
      (instantiate::&io-read-error
	 (fname (input-port-name port))
	 (location (input-port-position port))
	 (proc "markdown-parser")
	 (msg msg)
	 (obj obj))))

;*---------------------------------------------------------------------*/
;*    markdown-parse-error ...                                         */
;*---------------------------------------------------------------------*/
(define (markdown-parse-error msg obj ctx)
   (match-case ctx
      ((at ?fname ?loc)
       (raise
	  (instantiate::&io-parse-error
	     (fname fname)
	     (location loc)
	     (proc "markdown-parser")
	     (msg msg)
	     (obj obj))))
      ((? input-port?)
       (raise
	  (instantiate::&io-parse-error
	     (fname (input-port-name ctx))
	     (location (input-port-position ctx))
	     (proc "markdown-parser")
	     (msg msg)
	     (obj obj))))
      (else
       (raise
	  (instantiate::&io-parse-error
	     (proc "markdown-parser")
	     (msg msg)
	     (obj obj))))))

;*---------------------------------------------------------------------*/
;*    Markdown tags                                                    */
;*---------------------------------------------------------------------*/
(define-macro (define-markdown-tag id)
   `(define-tag ,(symbol-append '|<MARKDOWN:| id '>)
       ((class #f)
	(attrs)
	body)
       (apply ,(symbol-append '< id '>)
	  :class (cond
		    ((string? class)
		     (string-append "markdown " class))
		    ((isa? class JsStringLiteral)
		     (string-append "markdown " (js-jsstring->string class)))
		    (else
		     "markdown"))
	  attrs body)))

(define-markdown-tag H1)
(define-markdown-tag H2)
(define-markdown-tag H3)
(define-markdown-tag H4)
(define-markdown-tag H5)
(define-markdown-tag CODE)
(define-markdown-tag PRE)
(define-markdown-tag LI)
(define-markdown-tag UL)
(define-markdown-tag OL)
(define-markdown-tag HR)
(define-markdown-tag EM)
(define-markdown-tag STRONG)
(define-markdown-tag P)
(define-markdown-tag A)
(define-markdown-tag IMG)

;*---------------------------------------------------------------------*/
;*    normalize-string ...                                             */
;*---------------------------------------------------------------------*/
(define (normalize-string str)
   (let ((b (string-skip str " \t"))
	 (e (string-skip-right str " \t")))
      (cond
	 ((not b)
	  "")
	 ((=fx b 0)
	  (if (=fx e (-fx (string-length str) 1))
	      str
	      (string-shrink! str (+fx 1 e))))
	 ((=fx e (-fx (string-length str) 1))
	  (substring str b))
	 (else
	  (substring str b (+fx 1 e))))))

;*---------------------------------------------------------------------*/
;*    remove-surrounding-spaces ...                                    */
;*---------------------------------------------------------------------*/
(define (remove-surrounding-spaces l)
   (let loop ((l l)
	      (mode 'all))
      (cond
	 ((string? l)
	  (case mode
	     ((all)
	      (normalize-string l))
	     ((head)
	      (let ((b (string-skip l " \t")))
		 (if b
		     (substring l b)
		     l)))
	     ((tail)
	      (let ((b (string-skip-right l " \t")))
		 (if b
		     (string-shrink! l (+fx b 1))
		     "")))
	     (else
	      l)))
	 ((pair? l)
	  (if (null? (cdr l))
	      (list (loop (car l) mode))
	      (cons (loop (car l) 'head)
		    (let liip ((l (cdr l)))
		       (if (null? (cdr l))
			   (list (loop (car l) 'tail))
			   (cons (car l) (liip (cdr l))))))))
	 (else
	  l))))


;*---------------------------------------------------------------------*/
;*    section-tag ...                                                  */
;*---------------------------------------------------------------------*/
(define (section-tag depth)
   (case depth
      ((5) <MARKDOWN:H5>)
      ((4) <MARKDOWN:H4>)
      ((3) <MARKDOWN:H3>)
      ((2) <MARKDOWN:H2>)
      ((1) <MARKDOWN:H1>)
      (else #f)))
   
;*---------------------------------------------------------------------*/
;*    *comment-grammar* ...                                            */
;*---------------------------------------------------------------------*/
(define *comment-grammar*
   (regular-grammar ()
      ((: (* (out "-\n")))
       (ignore))
      ((: (* (out "-\n")) #\Newline)
       #f)
      ("-"
       (ignore))
      ((: "-*-" (* all) #\Newline)
       (let ((s (the-string)))
	  (let ((i (string-contains s "-*-" 3)))
	     (when (fixnum? i)
		(let ((j (string-contains-ci s "coding:" 3)))
		   (when (and (fixnum? j) (<fx j i))
		      (let ((n (string-skip s " \t"
				  (+fx j (string-length "coding:")))))
			 (when (fixnum? n)
			    (let ((m (string-index s " " n)))
			       (when (fixnum? m)
				  (string->symbol
				     (substring s n m))))))))))))))

;*---------------------------------------------------------------------*/
;*    *tab-code-block-grammar* ...                                     */
;*---------------------------------------------------------------------*/
(define *tab-code-block-grammar*
   (regular-grammar ((line (or (* (out "\n,*_"))
			       (: (* (out "\n,*_")) ",")
			       (+ (: (* (out "\n,*_")) (: "," (out "({"))))))
		     (crlf (or "\n" "\r\n"))
		     indent lines conv ctx)
      
      (define (the-html-substring start end)
         (html-string-encode (conv (the-substring start end))))

      ;; newline
      ((: (+ crlf) (: (or "\t" "    ") line crlf))
       (let* ((s (the-string))
	      (i (string-skip s "\r\n")))
	  (set! lines
	     (cons* (substring s (+fx i indent) (the-length))
		(substring s 0 i)
		lines)))
       (rgc-context)
       (ignore))
      ;; plain line of code
      ((bol (: (or "\t" "    ") line crlf))
       (set! lines (cons (the-html-substring indent (the-length)) lines))
       (rgc-context)
       (ignore))
      ((context hop line)
       (set! lines (cons (the-html-substring indent (the-length)) lines))
       (rgc-context)
       (ignore))
      ;; embedded hop
      (",(" 
       (rgc-buffer-unget-char (the-port) (char->integer #\())
       (with-handler
	  (lambda (e)
	     (exception-notify e)
	     (set! lines
		(cons (<MARKDOWN:PARSE-ERROR> (string (the-failure))) lines)))
	  (let ((expr (hop-read (the-port))))
	     (with-handler
		(lambda (e)
		   (exception-notify e)
		   (set! lines
		      (cons
			 (<SPAN> :hssclass "hop-eval-error"
			    (with-output-to-string
			       (lambda ()
				  (write expr))))
			 lines)))
		(set! lines (cons (eval-markdown expr ctx) lines)))))
       (rgc-context 'hop)
       (ignore))
      ;; embedded hopjs
      ("${"
       (rgc-buffer-unget-char (the-port) (char->integer #\{))
       (with-handler
	  (lambda (e)
	     (exception-notify e)
	     (set! lines (cons (<SPAN> :hssclass "hop-eval-error" e))))
	  (set! lines
	     (cons (%js-eval (the-port) 'repl ctx (js-undefined) ctx) lines)))
       (rgc-context 'hop)
       (ignore))
      (else
       (unless (eof-object? (the-failure))
	  (rgc-buffer-unget-char (the-port) (char->integer (the-failure))))
       (reverse! lines))))

;*---------------------------------------------------------------------*/
;*    fontify-code ...                                                 */
;*---------------------------------------------------------------------*/
(define (fontify-code lines lang ctx fontifier)
   (let ((f (when (isa? fontifier JsObject)
	       (js-get fontifier (string->symbol lang) ctx))))
      (if (isa? f JsFunction)
	  (js-call1 ctx f (js-undefined) (js-stringlist->jsstring lines))
	  lines)))

;*---------------------------------------------------------------------*/
;*    *quote-code-block-grammar* ...                                   */
;*---------------------------------------------------------------------*/
(define *quote-code-block-grammar*
   (regular-grammar ((line (or (: (out "`\n,*_"))
			       (: (* (out "`\n,*_")) ",")
			       (+ (: (* (out "`\n,*_")) (: "," (out "({"))))))
		     (crlf (or "\n" "\r\n"))
		     lines conv ctx)
      ;; newline
      ((+ crlf)
       (set! lines (cons (the-string) lines))
       (rgc-context)
       (ignore))
      ;; punctuation
      ((+ (in "*_"))
       (set! lines (cons (the-string) lines))
       (ignore))
      ((** 1 2 #\`)
       (set! lines (cons (the-string) lines))
       (rgc-context)
       (ignore))
      ((context hop line)
       (set! lines (cons (conv (the-substring 0 (the-length))) lines))
       (rgc-context)
       (ignore))
      ;; plain line of code
      ((: line)
       (set! lines (cons (conv (the-substring 0 (the-length))) lines))
       (rgc-context)
       (ignore))
      ((bol (: "```" (? #\Return) #\Newline))
       (rgc-context)
       (reverse! lines))
      (else
       (if (eof-object? (the-failure))
	   (markdown-read-error "unexpected eof" (the-failure) (the-port))
	   (markdown-read-error "Illegal character" (string (the-failure)) (the-port))))))

;*---------------------------------------------------------------------*/
;*    state-add! ...                                                   */
;*---------------------------------------------------------------------*/
(define (state-add! state::MDState e)
   (with-access::MDState state (elements)
      (set! elements (cons e elements))))

;*---------------------------------------------------------------------*/
;*    *markdown-grammar* ...                                           */
;*---------------------------------------------------------------------*/
(define *markdown-grammar*
   (regular-grammar ((punct (in "+=/-$#%!'\""))
		     (blank (in "<>^|:~;,{} ."))
		     (letter (out "<>+^|*=/_-$#%:~;,\"`'[](){}! \\\n\t0123456789"))
		     (letter+ (or letter digit))
		     (ident (: #\: (+ letter) (in " \t\n")))
		     (crlf (or "\n" "\r\n"))
		     ctx)

      ;; utf-8 bom
      ((bof (: #a239 #a187 #a191))
       (token 'CHARSET 'UTF-8 3))
      
      ;; utf-16 big endian
      ((bof (: #a254 #a255))
       ;; MS 23nov2011: CARE I don't know if ucs-2 is big or little endian
       (token 'CHARSET 'UCS-2 2))
      
      ;; utf-16 little endian
      ((bof (: #a255 #a254))
       ;; MS 23nov2011: CARE I don't know if ucs-2 is big or little endian
       (token 'CHARSET 'UCS-2 2))
      
      ;; comments
      ((bol (or ";*" ";;"))
       (let ((cset (read/rp *comment-grammar* (the-port))))
	  (token 'CHARSET cset (the-length))))
      ;; HTML comments
      ((: "<!--" (+ (or (out #\-) (: #\- (out #\-)) (: "--" (out #\>)))) "-->")
       (ignore))
      
      ;; continuation lines
      ((: #\\ (? #\Return) #\Newline)
       (ignore))

      ;; ident
      ((: "[:" (+ (out "]@")) "]")
       (let ((str (the-substring 2 -1)))
	  (token 'IDENT str (the-length))))
      ;; ident + class
      ((: "[:" (+ (out "]@\n")) "@" (+ (out "]\n@")) "]")
       (let* ((str (the-substring 2 -1))
	      (i (string-index str #\@))
	      (ident (substring str 0 i))
	      (clazz (substring str (+fx i 1) (string-length str))))
	  (token 'IDENT-CLASS (cons ident clazz) (the-length))))
      
      ;; escaped characters
      ((: "\\" (in ".`*_{}[]()#+-!"))
       (token 'TEXT (the-substring 1 2) (the-length)))
      
      ;; single escape characters
      ((or punct blank #\Return #\Newline #\\)
       (token 'TEXT (the-string) (the-length)))

      ;; url
      ((: "<" (+ (out "> \t\n")) ">")
       (token 'URL (the-substring 1 -1) (the-length)))
      
      ;; blank lines, paragraph
      ((: (+ (or (in " \t\n") "\r\n")) (? "\r") "\n")
       (token 'NEWLINE (the-string) (the-length)))
      
      ;; horizontal rules
      ((bol (: (>= 3 (: (in "*-") (* #\space))) crlf))
       (token 'HR (the-string) (the-length)))

      ;; sections
      ((bol (: (+ #\#) (* (in " \t")) (: (out #\#) (* all))))
       (let* ((str (the-string))
	      (len (the-length))
	      (depth (string-skip str "#"))
	      (end (string-skip-right str #\#))
	      (j (string-skip str " \t" depth))
	      (title (substring str j (or end len))))
	  (token 'SECTION (cons depth title) (the-length))))

      ;; second form of sections
      ((bol (: (+ (out #\# #\Newline)) #\Newline (+ #\=) #\Newline))
       (let ((str (the-string)))
	  (let* ((i (string-index str #\Newline))
		 (title (substring str 0 i)))
	     (token 'SECTION (cons 1 title) (the-length)))))
      ((bol (: (+ (out #\# #\Newline)) #\Newline (+ #\-) #\Newline))
       (let ((str (the-string)))
	  (let* ((i (string-index str #\Newline))
		 (title (substring str 0 i)))
	     (token 'SECTION (cons 2 title) (the-length)))))

      ;; code block mode
      ((bol (: (or "    " "\t") (* (in " \t")) (out "*- \t\n")))
       (let ((str (the-string)))
	  (rgc-buffer-unget-char (the-port)
	     (char->integer (string-ref str (-fx (the-length) 1))))
	  (token 'PRE (substring str 0 (the-length)) (the-length))))

      ;; program
      ((bol (: "```" (* (out " \t")) #\Newline))
       (token 'PROG (the-substring 3 -1) (-fx (the-length) 3)))
      
      ;; itemize
      ((bol (: (* " ") (in "*+-") (** 1 3 " ")))
       (let ((str (the-string)))
	  (token 'UL (cons (string-skip str " ") str) (the-length))))
      ;; enumerate
      ((bol (: (* " ") (+ digit) #\. (** 1 3 " ")))
       (let ((str (the-string)))
	  (token 'OL (cons (string-skip str " ") str) (the-length))))

      ;; code
      ("`"
       (token 'CODE "`" 1))
      ("``"
       (token 'CODE2 "``" 2))

      ;; emphasize/strong
      ((: "_" (out " _*\n\t"))
       (let ((str (the-string)))
	  (rgc-buffer-unget-char (the-port)
	     (char->integer (string-ref str (-fx (the-length) 1))))
	  (token 'O_ "_" 1)))
      ((: "__" (out " _*\n\t"))
       (let ((str (the-string)))
	  (rgc-buffer-unget-char (the-port)
	     (char->integer (string-ref str (-fx (the-length) 1))))
	  (token 'O__ "__" 2)))
      ((: "*" (out " *_\n\t"))
       (let ((str (the-string)))
	  (rgc-buffer-unget-char (the-port)
	     (char->integer (string-ref str (-fx (the-length) 1))))
	  (token 'O* "*" 1)))
      ((: "**" (out " *_\n\t"))
       (let ((str (the-string)))
	  (rgc-buffer-unget-char (the-port)
	     (char->integer (string-ref str (-fx (the-length) 1))))
	  (token 'O** "**" 2)))
      
      ("_" 
       (token 'E_ (the-string) 1))
      ("__" 
       (token 'E__ (the-string) 2))
      ("*" 
       (token 'E* (the-string) 1))
      ("**" 
       (token 'E** (the-string) 2))

      ;; links
      (#\[
       (token 'OBRA (the-string) 1))
      (#\]
       (token 'CBRA (the-string) 1))
      (#\(
       (token 'OPAR (the-string) 1))
      (#\)
       (token 'CPAR (the-string) 1))

      ;; image
      ("!["
       (token 'IMAGE (the-string) 2))
       
      ;; embedded hop
      (",("
       (rgc-buffer-unget-char (the-port) (char->integer #\())
       (with-handler
	  (lambda (e)
	     (exception-notify e)
	     (token 'ERROR e 0))
	  (let ((expr (hop-read (the-port))))
	     (with-handler
		(lambda (e)
		   (exception-notify e)
		   (token 'ERROR e 0))
		(token 'HOP (eval-markdown expr ctx) 0)))))

       ;; embedded hopjs
       ("${"
	(rgc-buffer-unget-char (the-port) (char->integer #\{))
	(with-handler
	   (lambda (e)
	      (exception-notify e)
	      (token 'ERROR e 0))
	   (token 'HOP (%js-eval (the-port) 'repl ctx (js-undefined) ctx) 0)))

      ;; simple text
      ((: (? (** 1 3 (in " \t"))) letter (+ (or letter+ (: punct letter+) (: #\space letter+))))
       (token 'TEXT (the-string) (the-length)))
      ((+ digit)
       (token 'TEXT (the-string) (the-length)))
      
      (else
       (let ((c (the-failure)))
	  (cond
	     ((eof-object? c)
	      (token 'EOF c 0))
	     (else
	      (token 'ERROR c 1)))))))

;*---------------------------------------------------------------------*/
;*    parse ...                                                        */
;*---------------------------------------------------------------------*/
(define (parse ip charset ctx fontifier)

   (define unresolved-refs
      '())

   (define definitions
      (make-hashtable))

   (define (resolve-references! dom)
      (for-each (lambda (unresolved)
		   (let* ((id (car unresolved))
			  (node (cadr unresolved))
			  (def (hashtable-get definitions id)))
		      (if def
			  (begin
			     (dom-set-attribute! node "href" (car def))
			     (when (cdr def)
				(dom-set-attribute! node "title" (cdr def))))
			  (parse-token-error "Unbound reference"
			     (caddr unresolved)))))
	 unresolved-refs))
   
   (define (parse-token-error msg token::pair)
      (let ((msg (if (eq? (token-tag token) 'BAD)
		     (cadr token)
		     (format msg (token-tag token))))
	    (obj (if (eq? (token-tag token) 'BAD)
		     (cddr token)
		     (token-value token))))
	 (match-case (token-loc token)
	    ((at ?fname ?loc)
	     (raise
		(instantiate::&io-parse-error
		   (proc "markdown")
		   (msg msg)
		   (obj obj)
		   (fname fname)
		   (location loc))))
	    (else
	     (raise
		(instantiate::&io-parse-error
		   (proc "markdown")
		   (msg msg)
		   (obj obj)))))))
   
   (define (parse-node-error msg node::J2SNode)
      (with-access::J2SNode node (loc)
	 (let ((l (read-line ip)))
	    (match-case loc
	       ((at ?fname ?loc)
		(raise
		   (instantiate::&io-parse-error
		      (proc "markdown")
		      (msg msg)
		      (obj (j2s->list node))
		      (fname fname)
		      (location loc))))
	       (else
		(raise
		   (instantiate::&io-parse-error
		      (proc "markdown")
		      (msg msg)
		      (obj (j2s->list node)))))))))
   
   (define (parse-error msg obj)
      (let ((fname (input-port-name ip))
	    (loc (input-port-position ip)))
	 (raise
	    (instantiate::&io-parse-error
	       (proc "markdown")
	       (msg msg)
	       (obj (read-line ip))
	       (fname fname)
	       (location loc)))))
   
   (define *peeked-tokens* '())
   (define *previous-token-type* #unspecified)
   
   (define (peek-token)
      (if (null? *peeked-tokens*)
	  (begin
	     (set! *peeked-tokens* (list (read/rp *markdown-grammar* ip ctx)))
	     (car *peeked-tokens*))
	  (car *peeked-tokens*)))
   
   (define (token-push-back! token)
      (set! *peeked-tokens* (cons token *peeked-tokens*)))
   
   (define (peek-token-type)
      (car (peek-token)))
   
   (define (peek-token-value)
      (cdr (peek-token)))
   
   (define (consume-token! type)
      (let ((token (consume-any!)))
	 (if (eq? (token-tag token) type)
	     token
	     (parse-token-error 
		(format "expected \"~a\" got \"~a\"" type
		   (token-tag token))
		token))))
   
   (define (consume! type)
      (cdr (consume-token! type)))
   
   (define (consume-any!)
      (let ((res (peek-token)))
	 (set! *previous-token-type* (car res))
	 (set! *peeked-tokens* (cdr *peeked-tokens*))
	 res))
   
   (define conv
      (if (procedure? charset)
	  charset
	  (charset-converter! charset (hop-charset))))

   (define (parse-span-elements state::MDState tag end)
      (cond
	 ((eq? (peek-token-type) end)
	  (consume-any!)
	  (values 'span
	     (apply tag state.attributes (reverse! state.elements))))
	 ((span state)
	  (parse-span-elements state tag end))
	 (else
	  (case (peek-token-type)
	     ((NEWLINE)
	      (values 'unwind state))
	     (else
	      (values 'unwind state))))))

   (define (parse-span state::MDState tag end cleanup #!optional wrapper)
      (let ((sstate::MDState (instantiate::MDState (wrapper wrapper))))
	 (multiple-value-bind (retcode val)
	    (parse-span-elements sstate tag end)
	    (case retcode
	       ((span)
		(state-add! state val))
	       ((unwind)
		(set! state.attributes
		   (append sstate.attributes state.attributes))
		(state-add! state cleanup)
		(for-each (lambda (e)
			     (state-add! state e))
		   sstate.elements))
	       (else
		(tprint "UNKNOWN RETCODE " retcode))))))

   (define (end-subblock state::MDState)
      (let ((el (state.ctor state.attributes (reverse! state.elements))))
	 (state-add! state.parent el)
	 state.parent))
      
   (define (end-blocks state::MDState)
      (let ((el (state.ctor state.attributes (reverse! state.elements))))
	 (if (not state.parent)
	     el
	     (begin
		(state-add! state.parent el)
		(end-blocks state.parent)))))
      
   (define (hr state::MDState)
      (let ((hr (case (peek-token-type)
		   ((IDENT)
		    (<MARKDOWN:HR> :id (token-value (consume-any!))))
		   ((IDENT-CLASS)
		    (let ((v (token-value (consume-any!))))
		       (<MARKDOWN:HR> :id (car v) :class (cdr v))))
		   (else
		    (<MARKDOWN:HR>)))))
	 (if (pair? state.elements)
	     (values 'blocks (list hr (end-blocks state)))
	     (values 'block hr))))

   (define (section state::MDState)
      (let* ((tok (consume-any!))
	     (sec (token-value tok)) 
	     (tag (section-tag (car sec)))
	     (title (cdr sec)))
	 (if tag
	     (let ((s (case (peek-token-type)
			 ((IDENT)
			  (tag :id (token-value (consume-any!))
			     (html-string-encode (conv title))))
			 ((IDENT-CLASS)
			  (let ((v (token-value (consume-any!))))
			     (tag :id (car v) :class (cdr v)
				(html-string-encode (conv title)))))
			 (else
			  (tag (html-string-encode (conv title)))))))
		(if (pair? state.elements)
		    (values 'blocks (list s (end-blocks state)))
		    (values 'block s)))
	     (begin
		(state-add! state (html-string-encode (conv title)))
		(block state #t)))))

   (define (li state::MDState token)
      (let ((li (instantiate::MDState
		   (tag 'LI)
		   (ctor (lambda l
			    (if (eq? state.wrapper 'P)
				(<MARKDOWN:LI> (apply <MARKDOWN:P> l))
				(apply <MARKDOWN:LI> l))))
		   (value (car (token-value token)))
		   (parent state))))
	 (block li #t)))
      
   (define (itemize state::MDState token)
      (let ((ul (instantiate::MDState
		   (tag (car token))
		   (ctor (if (eq? (car token) 'UL) <MARKDOWN:UL> <MARKDOWN:OL>))
		   (value (car (token-value token)))
		   (parent state))))
	 (li ul token)))

   (define (prog state::MDState lang)
      (let* ((lines (read/rp *quote-code-block-grammar* ip
		       '() conv ctx))
	     (body (if (string-null? lang)
		       lines
		       (fontify-code lines lang ctx fontifier))))
	 (values 'block
	    (<MARKDOWN:PRE> :class "fontifier-prog"
	       (apply <MARKDOWN:CODE> body)))))

   (define (pre state::MDState token indent)
      (let ((start (token-value token)))
	 (rgc-buffer-insert-substring! ip start 0 (string-length start)))
      (let ((lines (read/rp *tab-code-block-grammar* ip
		      indent '() conv ctx)))
	 (values 'block (<MARKDOWN:PRE> (apply <MARKDOWN:CODE> lines)))))

   (define (href)
      (let (url (title #f))
	 (case (peek-token-type)
	    ((TEXT)
	     (let loop ((str (list (conv (token-value (consume-any!))))))
		(if (eq? (peek-token-type) 'TEXT)
		    (loop (cons (conv (token-value (consume-any!))) str))
		    (let* ((str (apply string-append (reverse! str)))
			   (i (string-index str #\space)))
		       (if i
			   (begin
			      (set! url (substring str 0 i))
			      (set! title (substring str
					     (+fx i 2)
					     (-fx (string-length str) 1))))
			   (set! url str))))))
	    ((HOP)
	     (set! url (token-value (consume-any!)))
	     (cond
		((memq (peek-token-type) '(HOP TEXT))
		 (set! title (token-value (consume-any!))))
		((eq? (peek-token-type) 'CPAR)
		 #f)
		(else
		 (parse-token-error "Illegal href token \"~a\"" (consume-any!))))))
	 (values url title)))

   (define (lref)
      (case (peek-token-type)
	 ((TEXT)
	  (token-value (consume-any!)))
	 ((HOP)
	  (token-value (consume-any!)))
	 (else
	  (parse-token-error "Illegal lref token \"~a\"" (consume-any!)))))

   (define (skip-spaces)
      (let loop ((res #f))
	 (if (and (eq? (peek-token-type) 'TEXT)
		  (string=? (token-value (peek-token)) " "))
	     (begin
		(consume-any!)
		(loop #t))
	     res)))

   (define (read-string bound)
      (let loop ((acc '()))
	 (let ((tok (consume-token! 'TEXT)))
	    (if (string=? (token-value tok) bound)
		(apply string-append (reverse! acc))
		(loop (cons (token-value tok) acc))))))
   
   (define (definition-url prefix)
      (let loop ((acc (list prefix)))
	 (case (peek-token-type)
	    ((TEXT)
	     (let ((str (token-value (consume-any!))))
		(if (pregexp-match "[ \t\n]" str)
		    (apply string-append (reverse! acc))
		    (loop (cons str acc)))))
	    (else
	     (parse-token-error "Illegal url \"~a\"" (consume-any!))))))

   (define (definition-title)
      (when (skip-spaces)
	 (when (eq? (peek-token-type) 'TEXT)
	    (when (string-index (token-value (peek-token)) "'\"(")
	       (read-string (token-value (consume-any!)))))))
      
   (define (definition link)
      (let loop ()
	 (case (peek-token-type)
	    ((TEXT)
	     (let ((str (token-value (consume-any!))))
		(cond
		   ((pregexp-match "[ \t]{1,3}" str)
		    =>
		    (lambda (m)
		       (if (=fx (string-length (car m)) (string-length str))
			   (loop)
			   (let* ((url (definition-url
					  (substring str (string-length (car m)))))
				  (title (definition-title)))
			      (hashtable-put! definitions link
				 (cons url title)))))))))
	    ((URL HOP)
	     (let* ((url (token-value (consume-any!)))
		    (title (definition-title)))
		(hashtable-put! definitions link url title)))
	    (else
	     (parse-token-error "Illegal definition \"~a\"" (consume-any!))))))
      

   (define (reference state::MDState ctor ctor-body)
      (let ((lstate::MDState (instantiate::MDState
				(tag 'a)
				(parent state)
				(ctor ctor-body))))
	 (if (span lstate)
	     (begin
		(consume-token! 'CBRA)
		(let loop ()
		   (case (peek-token-type)
		      ((OPAR)
		       (consume-any!)
		       (multiple-value-bind (url title)
			  (href)
			  (consume-token! 'CPAR)
			  (state-add! state
			     (ctor url title
				(ctor-body (reverse! lstate.elements))))))
		      ((TEXT)
		       (let ((tok (consume-any!)))
			  (cond
			     ((string=? (token-value tok) " ")
			      (loop))
			     ((string=? (token-value tok) ":")
			      (definition (car lstate.elements)))
			     (else
			      (parse-token-error "Illegal texte reference token \"~a\""
				 tok)))))
		      ((OBRA)
		       (let* ((token (consume-any!))
			      (ref (lref))
			      (el (ctor #f #f
				     (ctor-body (reverse! lstate.elements)))))
			  (set! unresolved-refs
			     (cons (list ref el token) unresolved-refs))
			  (consume-token! 'CBRA)
			  (state-add! state el)))
		      (else
		       (parse-token-error "Illegal reference token \"~a\""
			  (consume-any!))))))
	     (parse-token-error "Illegal reference token \"~a\"" (consume-any!)))))
   
   (define (span state::MDState)
      (case (peek-token-type)
	 ((TEXT OPAR CPAR)
	  (state-add! state
	     (html-string-encode (conv (token-value (consume-any!)))))
	  #t)
	 ((URL)
	  (let ((url (conv (token-value (consume-any!)))))
	     (state-add! state
		(<MARKDOWN:A> :url url (html-string-encode url))))
	  #t)
	 ((O_)
	  (let ((val (token-value (consume-any!))))
	     (parse-span state <MARKDOWN:EM> 'E_ val))
	  #t)
	 ((O*)
	  (let ((val (token-value (consume-any!))))
	     (parse-span state <MARKDOWN:EM> 'E* val))
	  #t)
	 ((O__)
	  (let ((val (token-value (consume-any!))))
	     (parse-span state <MARKDOWN:EM> 'E__ val))
	  #t)
	 ((O**)
	  (let ((val (token-value (consume-any!))))
	     (parse-span state <MARKDOWN:EM> 'E** val))
	  #t)
	 ((CODE)
	  (let ((val (token-value (consume-any!))))
	     (if (eq? state.wrapper 'CODE2)
		 (state-add! state "`")
		 (parse-span state <MARKDOWN:CODE> 'CODE val)))
	  #t)
	 ((CODE2)
	  (let ((val (token-value (consume-any!))))
	     (parse-span state <MARKDOWN:CODE> 'CODE2 val 'CODE2))
	  #t)
	 ((IDENT)
	  (set! state.attributes
	     (cons* :id (token-value (consume-any!)) state.attributes))
	  #t)
	 ((IDENT-CLASS)
	  (let ((v (token-value (consume-any!))))
	     (set! state.attributes
		(cons* :id (car v) :class (cdr v) state.attributes)))
	  #t)
	 ((OBRA)
	  (consume-any!)
	  (reference state
	     (lambda (url title body)
		(<MARKDOWN:A> :href url :title title body))
	     (lambda l l))
	  #t)
	 ((IMAGE)
	  (consume-any!)
	  (reference state
	     (lambda (src title body)
		(<MARKDOWN:IMG> :src src :title title :alt body))
	     (lambda l (caar l)))
	  #t)
	 ((HOP)
	  (state-add! state (token-value (consume-any!)))
	  #t)
	 (else
	  #f)))

   (define (block state::MDState bob)
      (if (span state)
	  (block state #f)
	  (case (peek-token-type)
	     ((HR)
	      (consume-any!)
	      (hr state))
	     ((NEWLINE)
	      (consume-any!)
	      (if (and (eq? state.tag 'LI)
		       (let ((parent::MDState state.parent))
			  (eq? (peek-token-type) parent.tag)))
		  (let ((parent::MDState state.parent))
		     (set! parent.wrapper 'P)
		     (block state #t))
		  (values 'block (end-blocks state))))
	     ((EOF)
	      (if (pair? state.elements)
		  (values 'eof (end-blocks state))
		  (values 'eof #f)))
	     ((SECTION)
	      (section state))
	     ((UL OL)
	      (let ((tok (consume-any!)))
		 (let loop ((state::MDState state))
		    (cond
		       ((eq? state.tag 'LI)
			(let ((parent::MDState state.parent))
			   (cond
			      ((>fx (car (token-value tok)) state.value)
			       (itemize state tok))
			      ((<fx (car (token-value tok)) state.value)
			       (loop (end-subblock (end-subblock state))))
			      ((not (eq? (car tok) parent.tag))
			       (loop (end-subblock (end-subblock state))))
			      ((=fx (car (token-value tok)) state.value)
			       (li (end-subblock state) tok))
			      (else
			       (loop (end-subblock (end-subblock state)))))))
		       ((or (memq state.tag '(hr section))
			    (and bob (eq? state.tag 'P)))
			(itemize state tok))
		       (else
			(state-add! state
			   (html-string-encode (cdr (token-value tok))))
			(block state #f))))))
	     ((PROG)
	      (prog state (token-value (consume-any!))))
	     ((PRE)
	      (let ((tok (consume-any!)))
		 (cond
		    ((and bob (string-prefix? " " (token-value tok)))
		     (pre state tok  4))
		    (bob
		     (pre state tok 1))
		    ((and (eq? state.tag 'LI)
			  (string-prefix? "        " (token-value tok)))
		     (pre state tok 8))
		    ((and (eq? state.tag 'LI)
			  (string-prefix? "\t\t" (token-value tok)))
		     (pre state tok 2))
		    (else
		     (state-add! state
			(html-string-encode (token-value tok)))
		     (block state #f)))))
	     ((HOP)
	      (state-add! state (token-value (consume-any!)))
	      (block state bob))
	     (else
	      (parse-token-error "Illegal block token \"~a\"" (consume-any!))))))

   (define (blocks)
      (let loop ((els '()))
	 (multiple-value-bind (retcode val)
	    (let ((state (instantiate::MDState
			    (tag 'P)
			    (ctor <MARKDOWN:P>))))
	       (block state #t))
	    (case retcode
	       ((eof)
		(reverse! (if val (cons val els) els)))
	       ((block)
		(loop (cons val els)))
	       ((blocks)
		(loop (append val els)))))))
   
   (define (file)
      (when (eq? (peek-token-type) 'CHARSET)
	 (let ((cs (token-value (consume-any!))))
	    (set! conv (charset-converter! cs (hop-charset)))))
      (blocks))

   (let ((m (eval-module))
	 (f (the-loading-file)))
      (unwind-protect
	 (begin
	    (loading-file-set! (input-port-name ip))
	    (let* ((dom (file))
		   (nm (eval-module)))
	       (resolve-references! dom)
	       (unless (eq? m nm) (evmodule-check-unbound nm #f))
	       dom))
	 (begin
	    (eval-module-set! m)
	    (loading-file-set! f)))))
  
;*---------------------------------------------------------------------*/
;*    markdown-jsobj->hop ...                                          */
;*---------------------------------------------------------------------*/
(define (markdown-jsobj->hop jsobj #!key (charset (hop-locale)) %this)
   (let* ((str (cond
		  ((isa? jsobj JsStringLiteral) (js-jsstring->string jsobj))
		  ((isa? jsobj JsFastBuffer) (js-jsfastbuffer->string jsobj))
		  ((isa? jsobj JsSlowBuffer) (js-jsslowbuffer->string jsobj))
		  (else (js-tostring jsobj %this))))
	  (ip (open-input-string str)))
      (unwind-protect
	 (parse ip :charset charset :ctx %this)
	 (close-input-port ip))))

;*---------------------------------------------------------------------*/
;*    markdown-string->hop ...                                         */
;*---------------------------------------------------------------------*/
(define (markdown-string->hop string #!key (charset (hop-locale)) env)
   (let ((ip (open-input-string string)))
      (unwind-protect
	 (parse ip :charset charset :ctx env)
	 (close-input-port ip))))

;*---------------------------------------------------------------------*/
;*    parse-file ...                                                   */
;*---------------------------------------------------------------------*/
(define (parse-file file charset ctx fontifier)
   (hop-load-afile (dirname file))
   (call-with-input-file file
      (lambda (ip)
	 (parse ip charset ctx fontifier))))

;*---------------------------------------------------------------------*/
;*    markdown-generate ...                                            */
;*---------------------------------------------------------------------*/
(define (markdown-generate dom hss generator op)
   (generator dom hss op))

;*---------------------------------------------------------------------*/
;*    xml->markdown ...                                                */
;*---------------------------------------------------------------------*/
(define (xml->markdown dom hss)
   (call-with-output-string
      (lambda (op)
	 (markdown-generate dom hss xml->md op))))
