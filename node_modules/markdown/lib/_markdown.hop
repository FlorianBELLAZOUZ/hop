;*=====================================================================*/
;*    .../hop/3.0.x/node_modules/markdown/lib/_markdown.hop            */
;*    -------------------------------------------------------------    */
;*    Author      :  Manuel Serrano                                    */
;*    Creation    :  Sun Jul  6 06:15:53 2014                          */
;*    Last change :  Wed Jul 15 07:37:57 2015 (serrano)                */
;*    Copyright   :  2014-15 Manuel Serrano                            */
;*    -------------------------------------------------------------    */
;*    MARKDOWN hop parser                                              */
;*=====================================================================*/

;*---------------------------------------------------------------------*/
;*    The module                                                       */
;*---------------------------------------------------------------------*/
(module _markdown
   
   (library hopscript hop hopwidget nodejs)
   
   (static  (class MarkdownState
	       tag::symbol
	       syntax::procedure
	       (expr::pair-nil (default '()))
	       (attr::pair-nil (default '()))
	       value::obj)
	    (class MarkdownExpr::MarkdownState)
	    (class MarkdownBlock::MarkdownState
	       (is-subblock read-only (default #f))))
   
   (import markdown_md)
   
   (export (hopscript ::JsGlobalObject ::JsObject ::JsObject ::JsObject)
	   
	   <MARKDOWN:PARSE-ERROR>
	   <MARKDOWN:H1>
	   <MARKDOWN:H2>
	   <MARKDOWN:H3>
	   <MARKDOWN:H4>
	   <MARKDOWN:H5>
	   <MARKDOWN:CODE>
	   <MARKDOWN:PRE>
	   
	   (parse ip charset ctx)
	   (xml->markdown ::obj ::pair-nil)))

;*---------------------------------------------------------------------*/
;*    hopscript ...                                                    */
;*---------------------------------------------------------------------*/
(define (hopscript %this this scope module)
   (let ((exports (js-get module 'exports %this)))
      (js-bind-tags! %this exports
	 MARKDOWN:H1 MARKDOWN:H2 MARKDOWN:H3 MARKDOWN:H4 MARKDOWN:H5)))

;*---------------------------------------------------------------------*/
;*    flatten ...                                                      */
;*---------------------------------------------------------------------*/
(define (flatten l)
   (cond
      ((null? l) l)
      ((pair? l) (append (flatten (car l)) (flatten (cdr l))))
      (else (list l))))

;*---------------------------------------------------------------------*/
;*    not-subblock? ...                                                */
;*---------------------------------------------------------------------*/
(define (not-subblock? n _)
   (when (isa? n MarkdownBlock)
      (with-access::MarkdownBlock n (is-subblock)
	 (not (is-subblock n)))))

;*---------------------------------------------------------------------*/
;*    MarkdownState-tag ...                                            */
;*---------------------------------------------------------------------*/
(define (MarkdownState-tag s)
   (with-access::MarkdownState s (tag)
      tag))

;*---------------------------------------------------------------------*/
;*    markdown-debug ...                                               */
;*---------------------------------------------------------------------*/
(define markdown-debug
   (let ((env (getenv "NODE_DEBUG")))
      (cond
	 ((not (string? env)) 0)
	 ((string-contains env "markdown") 2)
	 (else 0))))

;*---------------------------------------------------------------------*/
;*    <MARKDOWN:PARSE-ERROR> ...                                       */
;*---------------------------------------------------------------------*/
(define (<MARKDOWN:PARSE-ERROR> str)
   (<SPAN> :hssclass "hop-parse-error"
      str))

;*---------------------------------------------------------------------*/
;*    markdown-name ...                                                */
;*---------------------------------------------------------------------*/
(define (markdown-name expr)
   (let* ((s (with-output-to-string
		(lambda ()
		   (let loop ((e expr))
		      (cond
			 ((pair? e)
			  (for-each loop e))
			 ((isa? e xml-markup)
			  (with-access::xml-markup e (body)
			     (loop body)))
			 ((null? e)
			  #unspecified)
			 (else
			  (display e)))))))
	  (s2 (pregexp-replace* "  |\n" s " ")))
      (pregexp-replace* "^ +| +$" s2 "")))

;*---------------------------------------------------------------------*/
;*    markdown-read-error ...                                          */
;*---------------------------------------------------------------------*/
(define (markdown-read-error msg obj port)
   (raise
      (instantiate::&io-read-error
	 (fname (input-port-name port))
	 (location (input-port-position port))
	 (proc "markdown-parser")
	 (msg msg)
	 (obj obj))))

;*---------------------------------------------------------------------*/
;*    markdown-parse-error ...                                         */
;*---------------------------------------------------------------------*/
(define (markdown-parse-error msg obj port)
   (raise
      (instantiate::&io-parse-error
	 (fname (input-port-name port))
	 (location (input-port-position port))
	 (proc "markdown-parser")
	 (msg msg)
	 (obj obj))))

;*---------------------------------------------------------------------*/
;*    Markdown tags                                                    */
;*---------------------------------------------------------------------*/
(define-macro (define-markdown-tag id)
   `(define-tag ,(symbol-append '|<MARKDOWN:| id '>)
       ((class #f)
	(attrs)
	body)
       (apply ,(symbol-append '< id '>)
	  :class (if (string? class) (string-append "markdown " class) class)
	  attrs body)))

(define-markdown-tag H1)
(define-markdown-tag H2)
(define-markdown-tag H3)
(define-markdown-tag H4)
(define-markdown-tag H5)
(define-markdown-tag CODE)
(define-markdown-tag PRE)

;*---------------------------------------------------------------------*/
;*    js-bind-tag! ...                                                 */
;*---------------------------------------------------------------------*/
(define-macro (js-bind-tag! %this obj tag)
   `(begin
       (js-bind! ,%this ,obj ',tag
	  :value (js-make-function ,%this
		    (lambda (this attrs . nodes)
		       (if (isa? attrs JsObject)
			   (if (null? nodes)
			       (apply ,(symbol-append '< tag '>)
				  (js-object->keyword-arguments attrs ,%this))
			       (apply ,(symbol-append '< tag '>)
				  (append
				     (js-object->keyword-arguments attrs ,%this)
				     nodes)))
			   (apply ,(symbol-append '< tag '>)
			      nodes)))
		    2 ',tag)
	  :writable #f
	  :enumerable #f)))

;*---------------------------------------------------------------------*/
;*    js-bind-tags! ...                                                */
;*---------------------------------------------------------------------*/
(define-macro (js-bind-tags! %this obj . tags)
   `(begin
       ,@(map (lambda (tag)
		 `(js-bind-tag! ,%this ,obj ,tag))
	    tags)))
   
;*---------------------------------------------------------------------*/
;*    markdown-parse-ident ...                                         */
;*---------------------------------------------------------------------*/
(define (markdown-parse-ident str)
   (let ((i (string-index str #\@)))
      (cond
	 ((not i)
	  (values str #f))
	 ((=fx i 0)
	  (values #f (substring str 1 (string-length str))))
	 (else
	  (values (substring str 0 i)
		  (substring str (+fx i 1) (string-length str)))))))

;*---------------------------------------------------------------------*/
;*    normalize-string ...                                             */
;*---------------------------------------------------------------------*/
(define (normalize-string str)
   (let ((b (string-skip str " \t"))
	 (e (string-skip-right str " \t")))
      (cond
	 ((not b)
	  "")
	 ((=fx b 0)
	  (if (=fx e (-fx (string-length str) 1))
	      str
	      (string-shrink! str (+fx 1 e))))
	 ((=fx e (-fx (string-length str) 1))
	  (substring str b))
	 (else
	  (substring str b (+fx 1 e))))))

;*---------------------------------------------------------------------*/
;*    remove-surrounding-spaces ...                                    */
;*---------------------------------------------------------------------*/
(define (remove-surrounding-spaces l)
   (let loop ((l l)
	      (mode 'all))
      (cond
	 ((string? l)
	  (case mode
	     ((all)
	      (normalize-string l))
	     ((head)
	      (let ((b (string-skip l " \t")))
		 (if b
		     (substring l b)
		     l)))
	     ((tail)
	      (let ((b (string-skip-right l " \t")))
		 (if b
		     (string-shrink! l (+fx b 1))
		     "")))
	     (else
	      l)))
	 ((pair? l)
	  (if (null? (cdr l))
	      (list (loop (car l) mode))
	      (cons (loop (car l) 'head)
		    (let liip ((l (cdr l)))
		       (if (null? (cdr l))
			   (list (loop (car l) 'tail))
			   (cons (car l) (liip (cdr l))))))))
	 (else
	  l))))


;*---------------------------------------------------------------------*/
;*    section-tag ...                                                  */
;*---------------------------------------------------------------------*/
(define (section-tag lv loc)
   (case lv
      ((5) <MARKDOWN:H5>)
      ((4) <MARKDOWN:H4>)
      ((3) <MARKDOWN:H3>)
      ((2) <MARKDOWN:H2>)
      ((1) <MARKDOWN:H1>)
      (else (markdown-parse-error "wrong section" obj port))))
   
;*---------------------------------------------------------------------*/
;*    *comment-grammar* ...                                            */
;*---------------------------------------------------------------------*/
(define *comment-grammar*
   (regular-grammar ()
      ((: (* (out "-\n")))
       (ignore))
      ((: (* (out "-\n")) #\Newline)
       #f)
      ("-"
       (ignore))
      ((: "-*-" (* all) #\Newline)
       (let ((s (the-string)))
	  (let ((i (string-contains s "-*-" 3)))
	     (when (fixnum? i)
		(let ((j (string-contains-ci s "coding:" 3)))
		   (when (and (fixnum? j) (<fx j i))
		      (let ((n (string-skip s " \t"
				  (+fx j (string-length "coding:")))))
			 (when (fixnum? n)
			    (let ((m (string-index s " " n)))
			       (when (fixnum? m)
				  (string->symbol
				     (substring s n m))))))))))))))

;*---------------------------------------------------------------------*/
;*    *markdown-grammar* ...                                           */
;*---------------------------------------------------------------------*/
(define *markdown-grammar*
   (regular-grammar ((punct (in "+*=/_-$#%!`'"))
		     (blank (in "<>^|:~;,(){}[] \n"))
		     (letter (out "<>+^|*=/_-$#%:~;,\"`'(){}[]! \\\n"))
		     (ident (: #\: (+ letter) (in " \t\n")))
		     state result trcount dbgcount charset ctx)
      
      ;; eval-markdown
      (define (eval-markdown exp)
         (if (pair? ctx)
	     (eval `(let (,ctx) ,exp))
	     (eval exp)))

      ;; misc
      (define (the-html-string)
         (html-string-encode (charset (the-string))))
      
      (define (the-html-substring start end)
         (html-string-encode (charset (the-substring start end))))
      
      ;; result and expression
      (define (add-expr! str)
         (if (pair? state)
	     (with-access::MarkdownState (car state) (expr)
		(set! expr (cons str expr)))
	     (set! result (cons str result))))
      
      (define (the-result)
         (reverse! result))
      
      ;; state management
      (define (enter-state! st fun value)
         (when markdown-debug
	    (set! dbgcount (+fx 1 dbgcount))
	    (fprint (current-error-port)
	       (make-string (length state) #\space) ">>> " st
	       "." dbgcount " [state] "
	       (map MarkdownState-tag state)))
         (let ((st (instantiate::MarkdownState
		      (tag st)
		      (syntax fun)
		      (expr '())
		      (value value))))
	    (set! state (cons st state))))
      
      (define (enter-expr! st fun value . attr)
         (when markdown-debug
	    (set! dbgcount (+fx 1 dbgcount))
	    (fprint (current-error-port)
	       (make-string (length state) #\space) ">>> " st
	       "." dbgcount " [expr] "
	       (map MarkdownState-tag state)))
         (let ((st (instantiate::MarkdownExpr
		      (tag st)
		      (syntax fun)
		      (expr '())
		      (attr attr)
		      (value value))))
	    (set! state (cons st state))))
      
      (define (enter-block! st fun value s)
         (when markdown-debug
	    (set! dbgcount (+fx 1 dbgcount))
	    (fprint (current-error-port)
	       (make-string (length state) #\space) ">>> " st
	       "." dbgcount " [block] "
	       (map MarkdownState-tag state)))
         (let ((st (instantiate::MarkdownBlock
		      (tag st)
		      (syntax fun)
		      (expr '())
		      (value value)
		      (is-subblock s))))
	    (set! state (cons st state))))
      
      (define (is-state? condition)
         (let ((pred (cond
			((procedure? condition)
			 condition)
			((symbol? condition)
			 (lambda (s _) (eq? (MarkdownState-tag s) condition)))
			((isa? condition state)
			 (lambda (s _) (eq? s condition)))
			(else
			 (lambda (s _) #t)))))
	    (and (pair? state) (pred (car state) (cdr state)))))
      
      (define (%is-in-state states condition)
         (let ((pred (cond
			((procedure? condition)
			 condition)
			((symbol? condition)
			 (lambda (s _) (eq? (MarkdownState-tag s) condition)))
			((isa? condition state)
			 (lambda (s _) (eq? s condition)))
			(else
			 (lambda (s _) #t)))))
	    (let loop ((state states))
	       (and (pair? state)
		    (if (pred (car state) (cdr state))
			(car state)
			(loop (cdr state)))))))
      
      (define (in-state condition)
         (%is-in-state state condition))
      
      (define (in-bottom-up-state condition)
         (%is-in-state (reverse state) condition))
      
      ;; pop one state
      (define (pop-state!)
         (when (pair? state)
	    (unwind-state! (car state))))
      
      ;; unwind the state until the stack is empty or the state is found
      (define (unwind-state! s . args)
         (when markdown-debug
	    (fprint (current-error-port)
	       (make-string (max 0 (- (length state) 1)) #\space) "<<< "
	       (when s (MarkdownState-tag s)) " "
	       (map MarkdownState-tag state)))
         (let loop ((st state)
		    (el #f))
	    (if (null? st)
		(begin
		   (set! state '())
		   (when el (add-expr! el)))
		(with-access::MarkdownState (car st) (tag syntax expr attr)
		   (let ((ar (reverse! (if el (cons el expr) expr))))
		      (if (eq? s (car st))
			  (let ((ne (apply syntax ar attr args)))
			     (set! state (cdr st))
			     (add-expr! ne))
			  (let ((ne (apply syntax ar attr)))
			     (loop (cdr st) ne))))))))

      (define (title->id title)
         title)
      
      ;; sectionning
      (define (mardown-section tag id name title)
         (let ((st (or (in-bottom-up-state
			  (lambda (s _)
			     (with-access::MarkdownState s (tag value)
				(and (eq? tag 'section)
				     (>=fx value lv)))))
		       (in-state
			  (lambda (s n)
			     (let loop ((s s)
					(n n))
				(when (pair? n)
				   (with-access::MarkdownState (car n)
					 (tag value)
				      (and (eq? tag 'section)
					   (<fx value lv))))))))))
	    (when st (unwind-state! st))
	    (enter-state! 'section list lv)
	    (enter-expr! 'section
	       (lambda expr
		  (when markdown-debug
		     (fprint (current-error-port) ";;" name))
		  (list (<A> :name title)
		     (apply tag :id id (remove-surrounding-spaces expr))))
	       #f)
	    (ignore)))
         
      (define (section-tag lv)
      
      
;*       ;; table cell                                                 */
;*       (define (table-first-row-cell char rightp id class)           */
;*        (let ((tc (if (char=? char #\^)                              */
;* 		     <TH>                                              */
;* 		     (<TD>))))                                         */
;* 	    (unless (is-state? 'table)                                 */
;* 	       (set! trcount 0)                                        */
;* 	       (enter-block! 'table                                    */
;* 		  (if (or class id)                                    */
;* 		      (lambda l                                        */
;* 			 (apply <TABLE>                                */
;* 			    :id id :class class                        */
;* 			    l))                                        */
;* 		      <TABLE>)                                         */
;* 		  #f #f))                                              */
;* 	    (enter-expr! 'tr                                           */
;* 	       (lambda exp                                             */
;* 		  (let* ((cl (if (evenfx? trcount)                     */
;* 				 "hopmarkdown-row-even"                */
;* 				 "hopmarkdown-row-odd"))               */
;* 			 (cl (if (string? class)                       */
;* 				 (string-append cl " " class)          */
;* 				 cl)))                                 */
;* 		     (apply (markdown-syntax-tr syn) :class cl exp)))  */
;* 	       #f)                                                     */
;* 	    (enter-expr! 'tc tc rightp)                                */
;* 	    (set! trcount (+fx 1 trcount))                             */
;* 	    (ignore)))                                                 */
;*                                                                     */
;*       (define (table-last-row-cell char leftp cs)                   */
;*          (let ((st (in-state 'tc)))                                 */
;* 	    (if (isa? st MarkdownState)                                */
;* 		(let ((align (cond                                     */
;* 				((MarkdownState-value st)              */
;* 				 (if leftp                             */
;* 				     "text-align:center"               */
;* 				     "text-align: right"))             */
;* 				(leftp "text-align: left")             */
;* 				(else "text-align: center"))))         */
;* 		   (if (and (fixnum? cs) (>fx cs 1))                   */
;* 		       (unwind-state! st :colspan cs :style align)     */
;* 		       (unwind-state! st :style align))                */
;* 		   (pop-state!)                                        */
;* 		   (ignore))                                           */
;* 		(begin                                                 */
;* 		   (add-expr! (the-html-string))                       */
;* 		   (ignore)))))                                        */
;*                                                                     */
;*       (define (table-cell char leftp rightp cs)                     */
;*          (let ((st (in-state 'tc)))                                 */
;* 	    (if (isa? st MarkdownState)                                */
;* 		(let ((align (cond                                     */
;* 				((MarkdownState-value st)              */
;* 				 (if leftp                             */
;* 				     "text-align:center"               */
;* 				     "text-align: right"))             */
;* 				(leftp "text-align: left")             */
;* 				(else "text-align: center")))          */
;* 		      (tc (if (char=? char #\^)                        */
;* 			      (markdown-syntax-th syn)                 */
;* 			      (markdown-syntax-td syn))))              */
;* 		   (if (>fx cs 1)                                      */
;* 		       (unwind-state! st :colspan cs :style align)     */
;* 		       (unwind-state! st :style align))                */
;* 		   (enter-expr! 'tc tc rightp)                         */
;* 		   (ignore))                                           */
;* 		(begin                                                 */
;* 		   (add-expr! (the-html-string))                       */
;* 		   (ignore)))))                                        */
;*                                                                     */
;*       (define include-grammar                                       */
;*        (regular-grammar (end name proc)                             */
;* 	  ((: "</" (+ (out #\>)) ">")                                  */
;* 	   (if (eq? (the-symbol) end)                                  */
;* 	       (let* ((name (apply string-append (reverse! name)))     */
;* 		      (path (cond                                      */
;* 			       ((substring-at? name ",(" 0)            */
;* 				(let ((e (substring name 1 (string-length name)))) */
;* 				   (with-input-from-string e           */
;* 				      (lambda ()                       */
;* 					 (eval-markdown (read))))))    */
;* 			       ((substring-at? name ",{" 0)            */
;* 				(let ((e (substring name 1 (string-length name)))) */
;* 				   (with-input-from-string e           */
;* 				      (lambda ()                       */
;* 					 (extension-markdown (current-input-port)))))) */
;* 			       (else                                   */
;* 				(let ((dir (dirname (input-port-name (the-port))))) */
;* 				   (find-file/path name (list "." dir))))))) */
;* 		  (cond                                                */
;* 		     ((and (string? path) (file-exists? path))         */
;* 		      (proc path))                                     */
;* 		     ((string? path)                                   */
;* 		      (warning "markdown-parser" "Can't find file: " path) */
;* 		      (add-expr! ((markdown-syntax-pre syn)            */
;* 				  "File not found -- " path)))         */
;* 		     (else                                             */
;* 		      (warning "markdown-parser" "Can't find file: " name) */
;* 		      (add-expr! ((markdown-syntax-pre syn)            */
;* 				  "Cannot find file in path -- " name))))))) */
;* 	  ((+ (or (out #\<) (: "<" (out "/"))))                        */
;* 	   (set! name (cons (the-string) name))                        */
;* 	   (ignore))                                                   */
;* 	  ((+ #\<)                                                     */
;* 	   (set! name (cons (the-string) name))                        */
;* 	   (ignore))))                                                 */
;*                                                                     */
;*       (define skip-space-grammar                                    */
;*          (regular-grammar ()                                        */
;* 	    ((+ (in " \t")) #unspecified)                              */
;* 	    (else #unspecified)))                                      */
;*                                                                     */
;*       (define (link-val s)                                          */
;*          (cond                                                      */
;* 	    ((and (>fx (string-length s) 3) (substring-at? s ",(" 0))  */
;* 	     (with-input-from-string (substring s 1 (string-length s)) */
;* 		(lambda ()                                             */
;* 		   (with-handler                                       */
;* 		      (lambda (e)                                      */
;* 			 (exception-notify e)                          */
;* 			 "")                                           */
;* 		      (eval-markdown (hop-read (current-input-port))))))) */
;* 	    ((and (>fx (string-length s) 3) (substring-at? s ",{" 0))  */
;* 	     (with-input-from-string (substring s 1 (string-length s)) */
;* 		(lambda ()                                             */
;* 		   (extension-markdown (current-input-port)))))        */
;* 	    ((and (string? s)                                          */
;* 		  (>fx (string-length s) 0)                            */
;* 		  (not (char=? (string-ref s 0) #\/))                  */
;* 		  (not (char=? (string-ref s 0) #\.)))                 */
;* 	     (string-append (the-loading-dir) "/" s))                  */
;* 	    (else                                                      */
;* 	     s)))                                                      */
      
;*       (define (enumerate s val args)                                */
;*          ;; this is a common mistake so we impose the paragraph ending. */
;*          (when (is-state? 'p) (pop-state!))                         */
;*          (let* ((c (string-ref s 0))                                */
;* 		(id (if (char=? c #\*) 'ul 'ol))                       */
;* 		(st (in-state (lambda (s n)                            */
;* 				 (with-access::MarkdownState s (tag value) */
;* 				    (and (eq? tag 'li)              */
;* 					 (=fx value val)               */
;* 					 (eq? (MarkdownState-tag (car n)) id))))))) */
;* 	    (if st                                                     */
;* 		(unwind-state! st)                                     */
;* 		(let ((st (in-bottom-up-state                          */
;* 			     (lambda (s n)                             */
;* 				(when (pair? n)                        */
;* 				   (with-access::MarkdownState (car n) (tag value) */
;* 				      (when (and (eq? tag 'li)      */
;* 						 (>=fx value val))     */
;* 					 s)))))))                      */
;* 		   (when st (unwind-state! st))                        */
;* 		   (enter-block! id                                    */
;* 		      (if (char=? c #\*)                               */
;* 			  (lambda expr                                 */
;* 			     (apply (markdown-syntax-ul syn) (append args expr))) */
;* 			  (lambda expr                                 */
;* 			     (apply (markdown-syntax-ol syn) (append args expr)))) */
;* 		      #f #f)))                                         */
;* 	    (enter-block! 'li (markdown-syntax-li syn) val #t)))       */
;*                                                                     */
      (define (read-line-safe port)
         (let ((s (read-line port)))
	    (if (eof-object? s)
		""
		s)))
      
      ;; utf-8 bom
      ((bof (: #a239 #a187 #a191))
       (set! charset (charset-converter! 'UTF-8 (hop-charset)))
       (ignore))
      
      ;; utf-16 big endian
      ((bof (: #a254 #a255))
       ;; MS 23nov2011: CARE I don't know if ucs-2 is big or little endian
       (set! charset (charset-converter! 'UCS-2 (hop-charset)))
       (ignore))
      
      ;; utf-16 little endian
      ((bof (: #a255 #a254))
       ;; MS 23nov2011: CARE I don't know if ucs-2 is big or little endian
       (set! charset (charset-converter! 'UCS-2 (hop-charset)))
       (ignore))
      
      ;; continuation lines
      ((: #\\ (? #\Return) #\Newline)
       (ignore))
      
      ((bol (: (>= 2 (in " \t")) (? #\Return) #\Newline))
       (let ((st (or (in-bottom-up-state (lambda (n _) (isa? n MarkdownExpr)))
		     (is-state? 'p))))
	  (when st (unwind-state! st)))
       (add-expr! (the-html-substring 2 (the-length)))
       (ignore))
      
      ;; blank lines
      ((bol (+ #\Newline))
       (case (the-length)
	  ((1)
	   ;; a blank line: end of expr
 	   (let ((st (in-bottom-up-state (lambda (n _) (isa? n MarkdownExpr)))))
	      (cond
		 (st
  	          (unwind-state! st))
   	         ((is-state? 'p)
	          (pop-state!)))))
	  ((2)
	   ;; two consecutive blank lines: end of block
	   (let ((st (in-state not-subblock?)))
	      (when st (unwind-state! st))))
	  (else
	   (unwind-state! #f)))
       (add-expr! (the-html-string))
       (ignore))
      
      ;; blank lines (with CR)
      ((bol (+ (: #\Return #\Newline)))
       (case (the-length)
	  ((2)
	   ;; a blank line: end of expr
 	   (let ((st (in-bottom-up-state (lambda (n _) (isa? n MarkdownExpr)))))
	      (cond
		 (st
  	          (unwind-state! st))
   	         ((is-state? 'p)
	          (pop-state!)))))
	  ((4)
	   ;; two consecutive blank lines: end of block
	   (let ((st (in-state not-subblock?)))
	      (when st (unwind-state! st))))
	  (else
	   (unwind-state! #f)))
       (add-expr! (the-html-string))
       (ignore))
      
      ;; simple text
      ((+ (or letter (: punct letter) (: #\space letter)))
       (add-expr! (the-html-string))
       (ignore))
      
;*       ;; hyphen                                                     */
;*       ((: #\\ #\-)                                                  */
;*        (add-expr! ((markdown-syntax-hyphen syn) "\\-"))             */
;*        (ignore))                                                    */
      
;*       ;; paragraphs                                                 */
;*       ((bol (: "~~" (? (: #\: (+ (out " \t\n"))))))                 */
;*        (when (is-state? 'p) (pop-state!))                           */
;*        (let ((args (if (=fx (the-length) 2)                         */
;* 		       '()                                             */
;* 		       (multiple-value-bind (ident class)              */
;* 			  (markdown-parse-ident (the-substring 3 (the-length))) */
;* 			  `(:class ,class :id ,ident)))))              */
;* 	  (enter-block! 'p                                             */
;* 	     (lambda expr                                              */
;* 		(apply (markdown-syntax-p syn) (append args expr)))    */
;* 	     #f                                                        */
;* 	     #f))                                                      */
;*        (read/rp skip-space-grammar (the-port))                      */
;*        (ignore))                                                    */
;*                                                                     */
      ;; sections
      ((bol (: (+ #\#) (? (: #\: (+ (out " \t\n"))))))
       (let* ((str (the-string))
	      (len (the-length))
	      (i (string-index str #\:))
	      (lv (if i (-fx i 2) (-fx (the-length) 1)))
	      (id #f))
	  (let* ((hx (case lv
			((5) <MARKDOWN:H5>)
			((4) <MARKDOWN:H4>)
			((3) <MARKDOWN:H3>)
			((2) <MARKDOWN:H2>)
			((1) <MARKDOWN:H1>)
			(else (<MARKDOWN:PARSE-ERROR> (the-string)))))
		 (hx (if i
			 (multiple-value-bind (i cla)
			    (markdown-parse-ident (substring str
						     (+fx i 1)
						     (the-length)))
			    (set! id i)
			    (lambda l
			       (apply hx (cons* :id id :class cla l))))
			 hx))
		 (st (or (in-bottom-up-state
			    (lambda (s _)
			       (with-access::MarkdownState s (tag value)
				  (and (eq? tag 'section)
				       (>=fx value lv)))))
			 (in-state
			    (lambda (s n)
			       (let loop ((s s)
					  (n n))
				  (when (pair? n)
				     (with-access::MarkdownState (car n)
					   (tag value)
					(and (eq? tag 'section)
					     (<fx value lv))))))))))
	     (when st (unwind-state! st))
	     (enter-state! 'section list lv)
	     (enter-expr! 'section
		(lambda expr
		   (let ((name (or id (markdown-name expr))))
		      (when markdown-debug
			 (fprint (current-error-port) ";;" name))
		      (list (<A> :name name)
			 (apply hx :data-markdown-name name
			    (remove-surrounding-spaces expr)))))
		#f)
	     (ignore))))
       ((bol (: (+ #\#) (out ":\n") (out " \t\n")))
	(let ((tag (section-tag (the-length))))
       (let* ((str (the-string))
	      (len (the-length))
	      (lv (-fx (the-length) 1)))
	  (let* ((hx )
		 (hx (if i
			 (multiple-value-bind (i cla)
			    (markdown-parse-ident (substring str
						     (+fx i 1)
						     (the-length)))
			    (set! id i)
			    (lambda l
			       (apply hx (cons* :id id :class cla l))))
			 hx))
		 (st (or (in-bottom-up-state
			    (lambda (s _)
			       (with-access::MarkdownState s (tag value)
				  (and (eq? tag 'section)
				       (>=fx value lv)))))
			 (in-state
			    (lambda (s n)
			       (let loop ((s s)
					  (n n))
				  (when (pair? n)
				     (with-access::MarkdownState (car n)
					   (tag value)
					(and (eq? tag 'section)
					     (<fx value lv))))))))))
	     (when st (unwind-state! st))
	     (enter-state! 'section list lv)
	     (enter-expr! 'section
		(lambda expr
		   (let ((name (or id (markdown-name expr))))
		      (when markdown-debug
			 (fprint (current-error-port) ";;" name))
		      (list (<A> :name name)
			 (apply hx :data-markdown-name name
			    (remove-surrounding-spaces expr)))))
		#f)
	     (ignore))))
      
      ((: (* (in " \t")) (+ #\#))
       (let ((st (in-state 'section)))
	  (if st
	      (unwind-state! st)
	      (add-expr! (the-html-string))))
       (ignore))

      ;; second form of sections
      ((bol (: (+ (out #\#)) #\n (+ #\#) #\n))
       (let ((str (the-string)))
	  (let* ((i (string-index str #\n))
		 (title (substring str 0 i)))
	     (markdown-section <MARKDOWN:H1>
		(markdown-id title) (markdown-name title) title))))
      ((bol (: (+ (out #\-)) #\n (+ #\-) #\n))
       (let ((str (the-string)))
	  (let* ((i (string-index str #\n))
		 (title (substring str 0 i)))
	     (markdown-section <MARKDOWN:H2>
		(markdown-id title) (markdown-name title) title))))
      
      ;; code block mode
      ((bol (: (or "    " "\t") (* (in " \t")) (? (: (out "*- \t\n") (* all)))))
       (unless (is-state? 'pre)
	  (enter-block! 'pre
	     (lambda expr
		(let ((rev (reverse! expr)))
		   (<MARKDOWN:PRE>
		      (if (and (pair? rev)
			       (string? (car rev))
			       (string=? (car rev) "\n"))
			  (apply <MARKDOWN:CODE>
			     (reverse! (cdr rev)))
			  (apply <MARKDOWN:CODE>
			     (reverse! rev)))))
		#f
		#f)))
       (add-expr! (the-html-substring 2 (the-length)))
       (ignore))
      
;*       ;; itemize/enumerate                                          */
;*       ((bol (: "  " (* " ") (in "*-")))                             */
;*        ;; if we are in a pre, just add the entire line              */
;*        (if (is-state? 'pre)                                         */
;* 	   (begin                                                      */
;* 	      (add-expr! (the-html-substring 2 (the-length)))          */
;* 	      (add-expr! (html-string-encode (charset (read-line-safe (the-port))))) */
;* 	      (add-expr! "\n"))                                        */
;* 	   (enumerate (the-substring (-fx (the-length) 1) (the-length)) */
;*               (the-length) '()))                                    */
;*        (ignore))                                                    */
;*                                                                     */
;*       ((bol (: "  " (* " ") (in "*-") (: #\: (+ (out " \t\n")))))   */
;*        ;; if we are in a pre, just add the entire line              */
;*        (if (is-state? 'pre)                                         */
;* 	   (begin                                                      */
;* 	      (add-expr! (the-html-substring 2 (the-length)))          */
;* 	      (add-expr! (html-string-encode (charset (read-line-safe (the-port))))) */
;* 	      (add-expr! "\n"))                                        */
;* 	   (let* ((s (the-string))                                     */
;* 		  (i (string-index-right s #\:)))                      */
;* 	      (multiple-value-bind (ident class)                       */
;* 		 (markdown-parse-ident (substring s i))                */
;* 		 (enumerate (substring s (-fx i 1) i)                  */
;*                     i `(:class ,class :id ,ident)))))               */
;*        (ignore))                                                    */
      
      ;; comments
      ((bol (or ";*" ";;"))
       (let ((cset (read/rp *comment-grammar* (the-port))))
	  (when cset
	     (set! charset (charset-converter! cset (hop-charset)))))
       (ignore))
      
;*       ;; tables                                                     */
;*       ((bol (in "^|"))                                              */
;*        (table-first-row-cell (the-character) #f #f #f))             */
;*       ((bol (: (in "^|") (: ":" (+ (out " \t\r\n")))))              */
;*        (multiple-value-bind (id class)                              */
;* 	  (markdown-parse-ident (the-substring 2 (the-length)))        */
;* 	  (table-first-row-cell (the-character) #f id class)))         */
;*                                                                     */
;*       ((bol (: (in "^|") "  "))                                     */
;*        (table-first-row-cell (the-character) #t #f #f))             */
;*       ((bol (: (in "^|") (: ":" (+ (out " \t\r\n"))) "  "))         */
;*        (multiple-value-bind (id class)                              */
;* 	  (markdown-parse-ident (the-substring 2 -2))                  */
;* 	  (table-first-row-cell (the-character) #t id class)))         */
;*                                                                     */
;*       ;; table cells                                                */
;*       ((: (+ (in "^|")) (* (in " \t")) (? #\Return) #\Newline)      */
;*        (let* ((str (the-html-string))                               */
;* 	      (cs (string-index str " \t\r\n")))                       */
;* 	  (table-last-row-cell (the-character) #f cs)))                */
;*                                                                     */
;*       ((: "  " (+ (in "^|")) (* (in " \t")) (? #\Return) #\Newline) */
;*        (let* ((str (the-html-substring 2 (the-length)))             */
;* 	      (cs (string-index str " \t\r\n")))                       */
;* 	  (table-last-row-cell (the-character) #t cs)))                */
;*                                                                     */
;*       ((+ (in "^|"))                                                */
;*        (table-cell (the-character) #f #f (the-length)))             */
;*                                                                     */
;*       ((: (+ (in "^|")) "  ")                                       */
;*        (table-cell (the-character) #f #t (-fx (the-length) 2)))     */
;*                                                                     */
;*       ((: "  " (+ (in "^|")) "  ")                                  */
;*        (table-cell (string-ref (the-html-substring 2 3) 0)          */
;* 	  #t #t (-fx (the-length) 4)))                                 */
;*                                                                     */
;*       ((: "  " (+ (in "^|")))                                       */
;*        (table-cell (string-ref (the-html-substring 2 3) 0)          */
;* 	  #t #f (-fx (the-length) 2)))                                 */
;*                                                                     */
;*       ;; tags                                                    */
;*       ("<<"                                                         */
;*        (enter-expr! '<< (markdown-syntax-note syn) #f)              */
;*        (ignore))                                                    */
;*       (">>"                                                         */
;*        (let ((s (in-state '<<)))                                    */
;* 	  (if s                                                        */
;* 	      (begin                                                   */
;* 		 (unwind-state! s)                                     */
;* 		 (ignore))                                             */
;* 	      (begin                                                   */
;* 		 (add-expr! (the-string))                              */
;* 		 (ignore)))))                                          */
;*                                                                     */
;*       ((: "<" (out #\< #\> #\/) (* (out #\/ #\>)) ">")              */
;*        (let ((id (the-symbol)))                                     */
;* 	  (case id                                                     */
;* 	     ((<del>)                                                  */
;* 	      (enter-expr! '</del> (markdown-syntax-del syn) #f)       */
;* 	      (ignore))                                                */
;* 	     ((<sup>)                                                  */
;* 	      (enter-expr! '</sup> (markdown-syntax-sup syn) #f)       */
;* 	      (ignore))                                                */
;* 	     ((<sub>)                                                  */
;* 	      (enter-expr! '</sub> (markdown-syntax-sub syn) #f)       */
;* 	      (ignore))                                                */
;* 	     ((<include>)                                              */
;* 	      (read/rp include-grammar (the-port)                      */
;* 		 '</include>                                           */
;* 		 '()                                                   */
;* 		 (lambda (path)                                        */
;* 		    (add-expr! (markdown-file->hop path                */
;* 				  :syntax syn                          */
;* 				  :charset charset))))                 */
;* 	      (ignore))                                                */
;* 	     ((<include-pre>)                                          */
;* 	      (read/rp include-grammar (the-port)                      */
;* 		 '</include-pre>                                       */
;* 		 '()                                                   */
;* 		 (lambda (path)                                        */
;* 		    (with-input-from-loading-file path                 */
;* 		       (lambda ()                                      */
;* 			  (add-expr!                                   */
;* 			     ((markdown-syntax-pre syn)                */
;* 			      (html-string-encode                      */
;* 				 (charset (read-string)))))))))        */
;* 	      (ignore))                                                */
;* 	     ((<plugin>)                                               */
;* 	      (let* ((pos (input-port-position (the-port)))            */
;* 		     (pid (string->symbol                              */
;* 			     (string-append "<" (read-line-safe (the-port)) ">"))) */
;* 		     (proc (eval (read (the-port)))))                  */
;* 		 (let loop ((line (read-line (the-port))))             */
;* 		    (cond                                              */
;* 		       ((eof-object? line)                             */
;* 			(raise (instantiate::&io-read-error            */
;* 				  (fname (input-port-name (the-port))) */
;* 				  (location pos)                       */
;* 				  (proc "markdown-parser")             */
;* 				  (msg "premature end of file")        */
;* 				  (obj "<plugin>"))))                  */
;* 		       ((string=? line "</plugin>")                    */
;* 			(with-access::markdown-syntax syn (plugins)    */
;* 			   (let ((old plugins))                        */
;* 			      (set! plugins                            */
;* 				 (lambda (id)                          */
;* 				    (if (eq? id pid)                   */
;* 					proc                           */
;* 					(old id))))))                  */
;* 			(ignore))                                      */
;* 		       (else                                           */
;* 			(loop (read-line (the-port))))))))             */
;* 	     (else                                                     */
;* 	      (let* ((id (the-symbol))                                 */
;* 		     (pproc ((markdown-syntax-plugins syn) id)))       */
;* 		 (if (procedure? pproc)                                */
;* 		     (let* ((/tag (string-append                    */
;* 					"</" (the-substring 1 (the-length)))) */
;* 			    (l/tag (string-length /tag))         */
;* 			    (title (read-line-safe (the-port)))        */
;* 			    (ltitle (string-length title)))            */
;* 			(if (substring-at? title /tag (-fx ltitle l/tag)) */
;* 			    (add-expr!                                 */
;* 			       (pproc (the-port)                       */
;* 				  (normalize-string                    */
;* 				     (substring title 0 (-fx ltitle l/tag))) */
;* 				  #f))                                 */
;* 			    (enter-plugin! id                          */
;* 			       (lambda e                               */
;* 				  (pproc (the-port) (normalize-string title) e)) */
;* 			       #f)))                                   */
;* 		     (let ((sproc ((markdown-syntax-verbatims syn) id))) */
;* 			(if (procedure? sproc)                         */
;* 			    (let* ((/tag (string-append             */
;* 					       "</" (the-substring 1 (the-length)))) */
;* 				   (l/tag (string-length /tag))  */
;* 				   (title (read-line-safe (the-port))) */
;* 				   (ltitle (string-length title)))     */
;* 			       (if (substring-at? title /tag (-fx ltitle l/tag)) */
;* 				   (add-expr!                          */
;* 				      (sproc (the-port)                */
;* 					 (normalize-string             */
;* 					    (substring title 0 (-fx ltitle l/tag))) */
;* 					 #f))                          */
;* 				   ;; read all the lines up to the closing tag */
;* 				   (add-expr!                          */
;* 				      (sproc (the-port)                */
;* 					 (normalize-string title)      */
;* 					 #f))))                        */
;* 			    (add-expr! (the-html-string))))))          */
;* 	      (ignore)))))                                             */
;*                                                                     */
;*       ((: "</" (+ (out #\< #\> #\/)) ">")                           */
;*        (let ((id (the-symbol)))                                     */
;* 	  (case id                                                     */
;* 	     ((</del> </sup> </sub>)                                   */
;* 	      (let ((s (in-state id)))                                 */
;* 		 (when s (unwind-state! s))                            */
;* 		 (ignore)))                                            */
;* 	     (else                                                     */
;* 	      (let* ((s (the-substring 2 (the-length)))                */
;* 		     (id (symbol-append '< (string->symbol s)))        */
;* 		     (proc ((markdown-syntax-plugins syn) id)))        */
;* 		 (if (procedure? proc)                                 */
;* 		     (let ((st (in-state id)))                         */
;* 			(if (isa? st MarkdownState)                    */
;* 			    (unwind-state! st)                         */
;* 			    (add-expr! (the-html-string))))            */
;* 		     (add-expr! (the-html-string)))                    */
;* 		 (ignore))))))                                         */
;*       ((: "<" (+ (out #\< #\> #\/)) "/>")                           */
;*        (let* ((id (string->symbol (string-append "<" (the-substring 1 -2) ">"))) */
;* 	      (proc ((markdown-syntax-plugins syn) id)))               */
;* 	  (if (procedure? proc)                                        */
;* 	      (add-expr! (proc (the-port) #f #f))                      */
;* 	      (add-expr! (the-html-string)))                           */
;* 	  (ignore)))                                                   */
;*                                                                     */
;*       ;; math                                                       */
;*       ((: "$$" (+ (or (out #\$) (: #\$ (out #\$)))) "$$")           */
;*        (add-expr! ((markdown-syntax-math syn) (the-substring 2 -2))) */
;*        (ignore))                                                    */
;*                                                                     */
;*       ;; font style                                                 */
;*       ((: "**" (? ident))                                           */
;*        (let ((s (in-state '**)))                                    */
;* 	  (cond                                                        */
;* 	     (s                                                        */
;* 	      (unwind-state! s)                                        */
;* 	      (ignore))                                                */
;* 	     ((=fx (the-length) 2)                                     */
;* 	      (enter-expr! '** (markdown-syntax-b syn) #f)             */
;* 	      (ignore))                                                */
;* 	     (else                                                     */
;* 	      (multiple-value-bind (ident class)                       */
;* 		 (markdown-parse-ident (the-substring 3 -1))           */
;* 		 (enter-expr! '** (markdown-syntax-b syn) #f           */
;* 		    :class class :id ident)                            */
;* 		 (ignore))))))                                         */
;*                                                                     */
;*       ;; emphasize                                                  */
;*       ((: "//" (? ident))                                           */
;*        (let ((s (in-state '//)))                                    */
;* 	  (cond                                                        */
;* 	     (s                                                        */
;* 	      (unwind-state! s)                                        */
;* 	      (ignore))                                                */
;* 	     ((=fx (the-length) 2)                                     */
;* 	      (enter-expr! '// (markdown-syntax-em syn) #f)            */
;* 	      (ignore))                                                */
;* 	     (else                                                     */
;* 	      (multiple-value-bind (ident class)                       */
;* 		 (markdown-parse-ident (the-substring 3 -1))           */
;* 		 (enter-expr! '// (markdown-syntax-em syn) #f          */
;* 		    :class class :id ident)                            */
;* 		 (ignore))))))                                         */
;*                                                                     */
;*       ;; underline                                                  */
;*       ((: "__" (? ident))                                           */
;*        (let ((s (in-state '__)))                                    */
;* 	  (cond                                                        */
;* 	     (s                                                        */
;* 	      (unwind-state! s)                                        */
;* 	      (ignore))                                                */
;* 	     ((=fx (the-length) 2)                                     */
;* 	      (enter-expr! '__ (markdown-syntax-u syn) #f)             */
;* 	      (ignore))                                                */
;* 	     (else                                                     */
;* 	      (multiple-value-bind (ident class)                       */
;* 		 (markdown-parse-ident (the-substring 3 -1))           */
;* 		 (enter-expr! '__ (markdown-syntax-u syn) #f           */
;* 		    :class class :id ident)                            */
;* 		 (ignore))))))                                         */
;*                                                                     */
;*       ;; tt                                                         */
;*       ((: "++" (? ident))                                           */
;*        (let ((s (in-state 'tt)))                                    */
;* 	  (cond                                                        */
;* 	     (s                                                        */
;* 	      (unwind-state! s)                                        */
;* 	      (ignore))                                                */
;* 	     ((=fx (the-length) 2)                                     */
;* 	      (enter-expr! 'tt (markdown-syntax-tt syn) #f)            */
;* 	      (ignore))                                                */
;* 	     (else                                                     */
;* 	      (multiple-value-bind (ident class)                       */
;* 		 (markdown-parse-ident (the-substring 3 -1))           */
;* 		 (enter-expr! 'tt (markdown-syntax-tt syn) #f          */
;* 		    :class class :id ident)                            */
;* 		 (ignore))))))                                         */
;*       ;; code                                                       */
;*       ((: "%%" (? ident))                                           */
;*        (let ((s (in-state 'code)))                                  */
;* 	  (cond                                                        */
;* 	     (s                                                        */
;* 	      (unwind-state! s)                                        */
;* 	      (ignore))                                                */
;* 	     ((=fx (the-length) 2)                                     */
;* 	      (enter-expr! 'code (markdown-syntax-code syn) #f)        */
;* 	      (ignore))                                                */
;* 	     (else                                                     */
;* 	      (multiple-value-bind (ident class)                       */
;* 		 (markdown-parse-ident (the-substring 3 -1))           */
;* 		 (enter-expr! 'code (markdown-syntax-code syn) #f      */
;* 		    :class class :id ident)                            */
;* 		 (ignore))))))                                         */
;*                                                                     */
;*       ;; strike                                                     */
;*       ((: "--" (? ident))                                           */
;*        (let ((s (in-state 'strike)))                                */
;* 	  (cond                                                        */
;* 	     (s                                                        */
;* 	      (unwind-state! s)                                        */
;* 	      (ignore))                                                */
;* 	     ((=fx (the-length) 2)                                     */
;* 	      (enter-expr! 'strike (markdown-syntax-strike syn) #f)    */
;* 	      (ignore))                                                */
;* 	     (else                                                     */
;* 	      (multiple-value-bind (ident class)                       */
;* 		 (markdown-parse-ident (the-substring 3 -1))           */
;* 		 (enter-expr! 'strike (markdown-syntax-strike syn) #f  */
;* 		    :class class :id ident)                            */
;* 		 (ignore))))))                                         */
;*                                                                     */
;*       ;; quotes                                                     */
;*       (#\"                                                          */
;*        (if (in-state 'code)                                         */
;* 	   (begin                                                      */
;* 	      (add-expr! (the-html-string))                            */
;* 	      (ignore))                                                */
;* 	   (let ((s (in-state 'quotation)))                            */
;* 	      (if s                                                    */
;* 		  (begin                                               */
;* 		     (unwind-state! s)                                 */
;* 		     (ignore))                                         */
;* 		  (begin                                               */
;* 		     (enter-expr! 'quotation (markdown-syntax-q syn) #f) */
;* 		     (ignore))))))                                     */
;*                                                                     */
;*       ;; keywords                                                   */
;*       ((: (in " \t") #\: (out " \t\n:)\"'`;#") (* (out " \t\n)\"'`;#"))) */
;*        (add-expr! " ")                                              */
;*        (add-expr! ((markdown-syntax-keyword syn) (the-html-substring 1 (the-length)))) */
;*        (ignore))                                                    */
;*                                                                     */
;*       ((bol (: #\: (out " \t\n:") (* (out " \t\n(){}[]"))))         */
;*        (add-expr! ((markdown-syntax-keyword syn) (the-html-string))) */
;*        (ignore))                                                    */
;*                                                                     */
;*       ;; types                                                      */
;*       ((: "::" (+ (out " \t\n(){}[]")))                             */
;*        (add-expr! ((markdown-syntax-type syn) (the-html-string)))   */
;*        (ignore))                                                    */
;*                                                                     */
;*       ;; links                                                      */
;*       ((: "[[" (+ (or (out #\]) (: #\] (out #\])))) "]]")           */
;*        (let* ((s (the-substring 2 -2))                              */
;* 	      (i (string-index s "|"))                                 */
;* 	      (href (markdown-syntax-href syn)))                       */
;* 	  (define (link-val s)                                         */
;* 	     (cond                                                     */
;* 		((and (>fx (string-length s) 3) (substring-at? s ",(" 0)) */
;* 		 (with-input-from-string (substring s 1 (string-length s)) */
;* 		    (lambda ()                                         */
;* 		       (with-handler                                   */
;* 			  (lambda (e)                                  */
;* 			     (exception-notify e)                      */
;* 			     "")                                       */
;* 			  (let ((e (eval-markdown (hop-read (current-input-port))))) */
;* 			     (values e e))))))                         */
;* 		((and (>fx (string-length s) 3) (substring-at? s ",{" 0)) */
;* 		 (with-input-from-string (substring s 1 (string-length s)) */
;* 		    (lambda ()                                         */
;* 		       (extension-markdown (current-input-port)))))    */
;* 		((or (=fx (string-length s) 0)                         */
;* 		     (and (not (char=? (string-ref s 0) #\/))          */
;* 			  (not (string-index s #\:))))                 */
;* 		 (values (string-append "#" s) s))                     */
;* 		(else                                                  */
;* 		 (values (html-string-encode s) s))))                  */
;* 	  (add-expr!                                                   */
;* 	     (if (not i)                                               */
;* 		 (multiple-value-bind (h n)                            */
;* 		    (link-val s)                                       */
;* 		    (href h n))                                        */
;* 		 (let ((s2 (substring s (+fx i 1) (string-length s)))) */
;* 		    (multiple-value-bind (h n)                         */
;* 		       (link-val (substring s 0 i))                    */
;* 		       (href h                                         */
;* 			  (markdown-string->hop                        */
;* 			     (substring s (+fx i 1) (string-length s)) */
;* 			     :syntax syn                               */
;* 			     :charset charset))))))                    */
;* 	  (ignore)))                                                   */
;*                                                                     */
;*       ;; anchors                                                    */
;*       ((: "##" (+ (or (out #\#) (: #\# (out #\#)))) "##")           */
;*        (let* ((s (the-substring 2 -2))                              */
;* 	      (i (string-index s "|"))                                 */
;* 	      (href (markdown-syntax-href syn)))                       */
;* 	  (add-expr!                                                   */
;* 	     (if (not i)                                               */
;* 		 (let ((href (link-val s)))                            */
;* 		    (<A> :name href))                                  */
;* 		 (let ((s2 (substring s (+fx i 1) (string-length s)))) */
;* 		    (let ((href (link-val (substring s 0 i)))          */
;* 			  (title (html-string-encode                   */
;* 				    (charset                           */
;* 				       (substring s (+fx i 1) (string-length s)))))) */
;* 		       (<A> :name href :title title title)))))         */
;* 	  (ignore)))                                                   */
;*                                                                     */
;*       ;; images                                                     */
;*       ((: "{{" (+ (or (out #\}) (: #\} (out #\})))) "}}")           */
;*        (let* ((s (the-substring 2 -2))                              */
;* 	      (i (string-index s "|")))                                */
;* 	  (add-expr!                                                   */
;* 	     (if (not i)                                               */
;* 		 (let ((path (link-val s)))                            */
;* 		    (if (or (string-suffix? ".svg" path)               */
;* 			    (string-suffix? ".svgz" path))             */
;* 			(<SVG:IMG> :src path :width "100%")            */
;* 			(<IMG> :src path :alt s)))                     */
;* 		 (let* ((p (substring s 0 i))                          */
;* 			(t (substring s (+fx i 1) (string-length s)))  */
;* 			(path (link-val p)))                           */
;* 		    (multiple-value-bind (id class)                    */
;* 		       (markdown-parse-ident t)                        */
;* 		       (if (or (string-suffix? ".svg" path)            */
;* 			       (string-suffix? ".svgz" path))          */
;* 			   (<SVG:IMG> :id id :class class :src path)   */
;* 			   (let ((title (html-string-encode (charset t)))) */
;* 			      (<IMG> :id id :class class               */
;* 				 :src path :alt p :title title)))))))) */
;*        (ignore))                                                    */
      
      ;; embedded hop
      (",("
	 (rgc-buffer-unget-char (the-port) (char->integer #\())
	 (with-handler
	    (lambda (e)
	       (exception-notify e)
	       (add-expr!
		  (<MARKDOWN:PARSE-ERROR> (string (the-failure)))))
	    (let ((expr (hop-read (the-port))))
	       (with-handler
		  (lambda (e)
		     (exception-notify e)
		     (add-expr!
			(<SPAN> :hssclass "hop-eval-error"
			   (with-output-to-string
			      (lambda ()
				 (write expr))))))
		  (add-expr! (eval-markdown expr)))))
	 (ignore))
      
       ;; embedded hop
       (",{"
	(rgc-buffer-unget-char (the-port) (char->integer #\())
	(with-handler
	   (lambda (e)
	      (exception-notify e)
	      (add-expr!
		 (<SPAN> :hssclass "hop-eval-error"
		    e)))
	   (add-expr!
	      (%js-eval (current-input-port) 'eval ctx (js-undefined) ctx)))
	(ignore))
      
      ;; single escape characters
      ((or punct blank #\\)
       (add-expr! (the-html-string))
       (ignore))
      
      (else
       (let ((c (the-failure)))
	  (if (eof-object? c)
	      (begin
		 (add-expr! (unwind-state! #f))
		 (the-result))
	      (markdown-read-error "Illegal character" (string c) (the-port)))))))

;*---------------------------------------------------------------------*/
;*    markdown-jsobj->hop ...                                          */
;*---------------------------------------------------------------------*/
(define (markdown-jsobj->hop jsobj #!key (charset (hop-locale)) %this)
   (let* ((str (cond
		  ((isa? jsobj JsStringLiteral) (js-jsstring->string jsobj))
		  ((isa? jsobj JsFastBuffer) (js-jsfastbuffer->string jsobj))
		  ((isa? jsobj JsSlowBuffer) (js-jsslowbuffer->string jsobj))
		  (else (js-tostring jsobj %this))))
	  (ip (open-input-string str)))
      (unwind-protect
	 (parse ip :charset charset :ctx %this)
	 (close-input-port ip))))

;*---------------------------------------------------------------------*/
;*    markdown-string->hop ...                                         */
;*---------------------------------------------------------------------*/
(define (markdown-string->hop string #!key (charset (hop-locale)) env)
   (let ((ip (open-input-string string)))
      (unwind-protect
	 (parse ip :charset charset :ctx env)
	 (close-input-port ip))))

;*---------------------------------------------------------------------*/
;*    parse-file ...                                                   */
;*---------------------------------------------------------------------*/
(define (parse-file file charset ctx)
   (hop-load-afile (dirname file))
   (parse file
      (lambda ()
	 (parse (current-input-port) :charset charset :ctx ctx))))

;*---------------------------------------------------------------------*/
;*    parse ...                                                        */
;*---------------------------------------------------------------------*/
(define (parse ip #!key charset ctx)
   (let ((conv (if (procedure? charset)
		   charset
		   (charset-converter! charset (hop-charset))))
	 (m (eval-module))
	 (f (the-loading-file)))
      (unwind-protect
	 (begin
	    (loading-file-set! (input-port-name ip))
	    (let* ((dom (read/rp *markdown-grammar* ip
			   '() '() 0 0 conv ctx))
		   (nm (eval-module)))
	       (unless (eq? m nm) (evmodule-check-unbound nm #f))
	       (flatten dom)
	       dom))
	 (begin
	    (eval-module-set! m)
	    (loading-file-set! f)))))
  
;*---------------------------------------------------------------------*/
;*    markdown-generate ...                                            */
;*---------------------------------------------------------------------*/
(define (markdown-generate dom hss generator)
   (call-with-output-string
      (lambda (op)
	 (generator dom hss op))))

;*---------------------------------------------------------------------*/
;*    xml->markdown ...                                                */
;*---------------------------------------------------------------------*/
(define (xml->markdown dom hss)
   (call-with-output-string
      (lambda (op)
	 (markdown-generate dom hss xml->md op))))
