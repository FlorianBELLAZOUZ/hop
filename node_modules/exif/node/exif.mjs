/*=====================================================================*/
/*    .../project/hop/hop/node_modules/exif/node/exif-module.js        */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Tue Mar 26 07:54:31 2024                          */
/*    Last change :  Thu May  9 13:57:42 2024 (serrano)                */
/*    Copyright   :  2024 Manuel Serrano                               */
/*    -------------------------------------------------------------    */
/*    Exif parser (generated from bigloo:api/multimedia/Llib/exif.scm) */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    The module                                                       */
/*---------------------------------------------------------------------*/
import * as fs from "node:fs";
import { Mmap } from "./mmap.mjs";

/*---------------------------------------------------------------------*/
/*    errors                                                           */
/*---------------------------------------------------------------------*/
const $errnoIoFileNotFoundError = Error.ENOENT;
const $errnoIoParseError = -1;

/*---------------------------------------------------------------------*/
/*    error_errno ...                                                  */
/*---------------------------------------------------------------------*/
function error_errno(errno, proc, msg, obj) {
   const err = new Error(`${proc}: ${msg} -- ${obj}`);
   err.errno = errno;
   throw err;
}

/*---------------------------------------------------------------------*/
/*    $ioParseError ...                                                */
/*---------------------------------------------------------------------*/
function $ioParseError({proc, msg, obj}) {
   throw new Error(`${proc}: ${msg} -- ${obj}`);
}

/*---------------------------------------------------------------------*/
/*    warning ...                                                      */
/*---------------------------------------------------------------------*/
function warning(...vals) {
   console.log.apply(console, vals);
}

/*---------------------------------------------------------------------*/
/*    makeDate ...                                                     */
/*---------------------------------------------------------------------*/
function makeDate({sec, min, hour, day, month, year}) {
   return new Date(year, month - 1, day, hour, min, sec);
}

/*---------------------------------------------------------------------*/
/*    cons ...                                                         */
/*---------------------------------------------------------------------*/
function cons(a, d) {
   return [a, d];
}

/*---------------------------------------------------------------------*/
/*    pairp ...                                                        */
/*---------------------------------------------------------------------*/
function pairp(o) {
   return Array.isArray(o) && o.length === 2;
}

/*---------------------------------------------------------------------*/
/*    car ...                                                          */
/*---------------------------------------------------------------------*/
function car(o) {
   return o[0];
}

/*---------------------------------------------------------------------*/
/*    cdr ...                                                          */
/*---------------------------------------------------------------------*/
function cdr(o) {
   return o[1];
}

/*---------------------------------------------------------------------*/
/*    length ...                                                       */
/*---------------------------------------------------------------------*/
function length(o) {
   if (pairp(o)) {
      return 1 + length(cdr(o));
   } else if (o === null) {
      return 0;
   }
}

/*---------------------------------------------------------------------*/
/*    stringShrink$ ...                                                */
/*---------------------------------------------------------------------*/
function stringShrink$(s, len) {
   return s.substring(0, len);
}
 
/*---------------------------------------------------------------------*/
/*    Exif ...                                                         */
/*---------------------------------------------------------------------*/
export function Exif(file) {
   return jpegExif(file);
}

Exif.prototype = exif.prototype;
// generated by /home2/serrano/hop/master/node_modules/exif/node/mkjast.scm

export function exif(props) {
   this.version = false;
   this.jpegEncoding = false;
   this.jpegCompress = false;
   this.software = false;
   this.comment = false;
   Object.defineProperty(this, "$commentpos", { value: false, enumerable: false, writable: true, configurable: false });
   Object.defineProperty(this, "$commentlen", { value: false, enumerable: false, writable: true, configurable: false });
   this.description = false;
   this.date = false;
   this.offsetTime = false;
   this.offsetTimeOriginal = false;
   this.offsetTimeDigitized = false;
   this.make = false;
   this.model = false;
   this.uniqueCameraModel = false;
   this.cameraSerialNumber = false;
   this.orientation = 'landscape';
   Object.defineProperty(this, "$orientationpos", { value: false, enumerable: false, writable: true, configurable: false });
   this.width = false;
   this.height = false;
   this.iwidth = false;
   this.ilength = false;
   this.ewidth = false;
   this.eheight = false;
   this.xresolution = false;
   this.yresolution = false;
   this.resolutionUnit = false;
   this.focalLength = false;
   this.focalLength35 = false;
   this.customRender = false;
   this.exposureMode = false;
   this.whiteBalance = false;
   this.digitalZoomRatio = false;
   this.lightSource = false;
   this.flash = false;
   this.fnumber = false;
   this.iso = false;
   this.shutterSpeedValue = false;
   this.exposureProgram = false;
   this.exposureTime = false;
   this.exposureBiasValue = false;
   this.aperture = false;
   this.maxAperture = false;
   this.meteringMode = false;
   this.cddWidth = false;
   this.cddHeight = false;
   this.bitsPerSample = false;
   this.samplesPerPixel = false;
   this.focalPlaneXres = false;
   this.focalPlaneYres = false;
   this.focalPlaneUnits = false;
   this.brightnessValue = false;
   this.subjectDistance = false;
   this.colorspace = false;
   this.sensingMethod = false;
   this.compositeImage = false;
   this.lensMake = false;
   this.lensModel = false;
   this.digitalZoomRatio = false;
   this.sceneCaptureType = "???";
   this.gainControl = "???";
   this.contrast = "???";
   this.saturation = "???";
   this.sharpness = "???";
   this.distanceSubjectRange = false;
   this.newSubfileType = false;
   this.YCbCrCoef = false;
   this.YCbCrSubsampling = false;
   this.YCbCrPositioning = false;
   this.refere = false;
   this.rating = false;
   this.ratingPercentage = false;
   this.copyright = false;
   this.artist = false;
   this.makerNote = false;
   this.thumbnail = false;
   Object.defineProperty(this, "$thumbnailPath", { value: false, enumerable: false, writable: true, configurable: false });
   Object.defineProperty(this, "$thumbnailOffset", { value: false, enumerable: false, writable: true, configurable: false });
   Object.defineProperty(this, "$thumbnailLength", { value: false, enumerable: false, writable: true, configurable: false });
   this.endianess = false;
   this.fileSource = "???";
   Object.defineProperty(this, "$gpsTag", { value: false, enumerable: false, writable: true, configurable: false });
   Object.defineProperty(this, "$gpsLatitudeRef", { value: false, enumerable: false, writable: true, configurable: false });
   this.gpsLatitude = false;
   this.gpsLongitude = false;
   Object.defineProperty(this, "$gpsLongitudeRef", { value: false, enumerable: false, writable: true, configurable: false });
   this.gpsAltitude = false;
   Object.defineProperty(this, "$gpsAltitudeRef", { value: false, enumerable: false, writable: true, configurable: false });
   this.gpsSatelites = false;
   this.gpsMeasureMode = false;
   this.gpsStatus = false;
   this.gpsTimeStamp = false;
   this.gpsDateStamp = false;
   this.$class = 'exif';
   Object.assign(this, props);
}
exif.prototype.duplicate = function(props) {
   const o = new exif({});
   Object.assign(o, this);
   Object.assign(o, props);
   return o;
}

// generated by hop2js
export {jpegExif, jpegExifCommentSet$, jpegExifOrientationSet$, parseExifDate}
const exifError = ((proc, msg, obj) => { return error_errno($errnoIoParseError, proc, msg, obj); }
)
const getascii = ((en, bytes, o) => { let stringGetascii = ((bytes, o) => { const loop$ = ((function loop(i) { if (bytes[i] === '\u0000') return bytes.substring(o, i); else return loop((i + 1)); })(o)); return loop$; });let mmapGetascii = ((bytes, o) => { const loop$ = ((function loop(i) { if (bytes.ref(i) === '\u0000') return bytes.substring(o, i); else return loop((i + 1)); })(o)); return loop$; });if (typeof(bytes) === 'string') return stringGetascii(bytes, o); else return mmapGetascii(bytes, o); }
)
const get16u = ((en, bytes, o) => { let stringGet16U = ((en, bytes, o) => { return ((en) ? (((bytes[o].charCodeAt(0) << 8) | bytes[(1 + o)].charCodeAt(0))) : (((bytes[(1 + o)].charCodeAt(0) << 8) | bytes[o].charCodeAt(0)))); }
);let mmapGet16U = ((en, bytes, o) => { return ((en) ? (((bytes.ref(o).charCodeAt(0) << 8) | bytes.ref((1 + o)).charCodeAt(0))) : (((bytes.ref((1 + o)).charCodeAt(0) << 8) | bytes.ref(o).charCodeAt(0)))); }
);if (typeof(bytes) === 'string') return stringGet16U(en, bytes, o); else return mmapGet16U(en, bytes, o); }
)
const get32u = ((en, bytes, o) => { let stringGet32U = ((en, bytes, o) => { let e0 = bytes[o].charCodeAt(0), e1 = bytes[(1 + o)].charCodeAt(0), e2 = bytes[(2 + o)].charCodeAt(0), e3 = bytes[(3 + o)].charCodeAt(0); if (en) return ((e0 << 24) | ((e1 << 16) | ((e2 << 8) | e3))); else return ((e3 << 24) | ((e2 << 16) | ((e1 << 8) | e0))); });let mmapGet32U = ((en, bytes, o) => { let e0 = bytes.ref(o).charCodeAt(0), e1 = bytes.ref((1 + o)).charCodeAt(0), e2 = bytes.ref((2 + o)).charCodeAt(0), e3 = bytes.ref((3 + o)).charCodeAt(0); if (en) return ((e0 << 24) | ((e1 << 16) | ((e2 << 8) | e3))); else return ((e3 << 24) | ((e2 << 16) | ((e1 << 8) | e0))); });if (typeof(bytes) === 'string') return stringGet32U(en, bytes, o); else return mmapGet32U(en, bytes, o); }
)
const getformat = ((en, bytes, o, fmt) => { switch (fmt) { case 1:case 6:case 7:return ((typeof(bytes) === 'string') ? (bytes[o]) : (bytes.ref(o))).charCodeAt(0);break; case 2: return getascii(en, bytes, o); break; case 3:case 8:return get16u(en, bytes, o);break; case 4:case 9:return get32u(en, bytes, o);break; case 5:case 10:{ let num = get32u(en, bytes, o), den = get32u(en, bytes, (o + 4)); return cons(num, den); }break; case 11: return exifError("exif", "Unsupported number format", fmt); break; case 12: return exifError("exif", "Unsupported number format", fmt); break; case 257: return ((typeof(bytes) === 'string') ? (bytes[o]) : (bytes.ref(o))).charCodeAt(0); break; case 258: return ((typeof(bytes) === 'string') ? (bytes[o]) : (bytes.ref(o))).charCodeAt(0); break; default: console.error("unknown format ", fmt);return 0; } }
)
const getformat_fx = ((en, bytes, o, fmt) => { let res = getformat(en, bytes, o, fmt); if (Number.isInteger(res)) return res; else if (Number.isInteger(res)) return res; else return 0; })
const getformatRat3 = ((en, bytes, valptr, fmt) => { { let sz = _exifFormatsSize_[fmt], r0 = getformat(en, bytes, valptr, fmt), r1 = getformat(en, bytes, (valptr + sz), fmt), r2 = getformat(en, bytes, (valptr + (sz + sz)), fmt); return ((car(r0) / cdr(r0)) + ((car(r1) / (60.0 * cdr(r1))) + (car(r2) / (3600.0 * cdr(r2))))); } }
)
let _exifFormatsSize_ = ['_', 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8]
const readJpegMarker = ((p) => { if (!(p.get() === '\u00ff')) return false; else return p.get().charCodeAt(0); }
)
const removeTrailingSpaces$ = ((s) => { let len = s.length; if (len === 0) return s; else { let start = (len - 1); { const loop$ = ((function loop(i) { if (s[i] === ' ') return loop((i - 1)); else if (i === 0) return ""; else if (i === start) return s; else return stringShrink$(s, (i + 1)); })(start)); return loop$; } } })
const processExifDir$ = ((en, bytes, start, base, exif, o0, tagBase, readNext, extension) => { let strncpy = ((o, max) => { let stringStrncpy = ((o, max) => { const loop$ = ((function loop(i) { if (i === max) return bytes.substring(o, (o + i)); else { let c = bytes[(i + o)]; if (c === '\u0000') return bytes.substring(o, (o + i)); else return loop((i + 1)); } })(0)); return loop$; });let mmapStrncpy = ((o, max) => { const loop$ = ((function loop(i) { if (i === max) return bytes.substring(o, (o + i)); else { let c = bytes.ref((i + o)); if (c === '\u0000') return bytes.substring(o, (i + o)); else return loop((i + 1)); } })(0)); return loop$; });if (typeof(bytes) === 'string') return stringStrncpy(o, max); else return mmapStrncpy(o, max); }
);let strncpy2 = ((o, max) => { let stringStrncpy = ((o, max) => { const loop$ = ((function loop(i) { if (i === max) return bytes.substring(o, (o + i)); else { let c = bytes[(i + o)]; if (c === '\u0000') return bytes.substring(o, (o + i)); else return loop((i + 1)); } })(0)); return loop$; });let mmapStrncpy = ((o, max) => { const loop$ = ((function loop(i) { if (i === max) return bytes.substring(o, (o + i)); else { let c = bytes.ref((i + o)); if (c === '\u0000') return bytes.substring(o, (i + o)); else return loop((i + 1)); } })(0)); return loop$; });if (typeof(bytes) === 'string') return stringStrncpy(o, max); else return mmapStrncpy(o, max); }
);{ let dnum = get16u(en, bytes, start); { const loop$ = ((function loop(de) { if ((de < dnum)) { let da = (start + (2 + (12 * de))), tag = get16u(en, bytes, da), fmt = get16u(en, bytes, (2 + da)), cmp = get32u(en, bytes, (4 + da)); { let bcount = (cmp * (((fmt > _exifFormatsSize_.length)) ? (1) : (_exifFormatsSize_[fmt]))), valptr = (((bcount > 4)) ? ((((ov) => { return (base + ov); })(get32u(en, bytes, (8 + da))))) : ((8 + da))); undefined;switch ((tag + tagBase)) { case 1: { let o = strncpy(valptr, bcount); undefined; } break; case 65537: { let obj1004 = exif; obj1004['$gpsLatitudeRef'] = strncpy(valptr, bcount); } break; case 65538: { let obj1005 = exif; obj1005.gpsLatitude = getformatRat3(en, bytes, valptr, fmt); } break; case 65539: { let obj1006 = exif; obj1006['$gpsLongitudeRef'] = strncpy(valptr, bcount); } break; case 65540: { let obj1007 = exif; obj1007.gpsLongitude = getformatRat3(en, bytes, valptr, fmt); } break; case 65541: { let obj1008 = exif; obj1008['$gpsAltitudeRef'] = getformat_fx(en, bytes, valptr, fmt); } break; case 65542: { let obj1009 = exif; obj1009.gpsAltitude = getformat(en, bytes, valptr, fmt); } break; case 65543: { let obj1010 = exif; obj1010.gpsTimeStamp = getformatRat3(en, bytes, valptr, fmt); } break; case 65544: { let obj1011 = exif; obj1011.gpsSatelites = strncpy(valptr, bcount); } break; case 65545: { let obj1012 = exif; obj1012.gpsStatus = strncpy(valptr, bcount); } break; case 65546: { let obj1013 = exif; obj1013.gpsMeasureMode = strncpy(valptr, bcount); } break; case 65563:case 65564:undefined;break; case 65565: { let obj1014 = exif; obj1014.gpsDateStamp = strncpy(valptr, bcount); } break; case 65547: undefined; break; case 65548: undefined; break; case 65549: undefined; break; case 65550: undefined; break; case 65551: undefined; break; case 65552: undefined; break; case 65553: undefined; break; case 254: { let s = getformat_fx(en, bytes, valptr, fmt); undefined;{ let obj1015 = exif; obj1015.newSubfileType = s; } } break; case 255: { let s = getformat_fx(en, bytes, valptr, fmt); undefined; } break; case 256: { let w = getformat_fx(en, bytes, valptr, fmt); { let obj1016 = exif; obj1016.iwidth = w; } } break; case 257: { let l = getformat_fx(en, bytes, valptr, fmt); { let obj1017 = exif; obj1017.ilength = l; } } break; case 258: { let bps = getformat_fx(en, bytes, valptr, fmt); { let obj1018 = exif; obj1018.bitsPerSample = bps; } } break; case 259: { let c = getformat(en, bytes, valptr, fmt); { let obj1019 = exif; obj1019.jpegCompress = c; } } break; case 262: { let c = getformat(en, bytes, valptr, fmt); { let obj1020 = exif; obj1020.jpegCompress = c; } } break; case 270: { let obj1021 = exif; obj1021.description = strncpy(valptr, bcount); } break; case 271: { let obj1022 = exif; obj1022.make = strncpy(valptr, 31); } break; case 272: { let obj1023 = exif; obj1023.model = strncpy(valptr, 39); } break; case 273: undefined; break; case 274: { let o = getformat(en, bytes, valptr, fmt); { let obj1024 = exif; obj1024.orientation = (() => { switch (o) { case 1: return 'landscape'; break; case 6: return 'portrait'; break; case 8: return 'upsidedown'; break; default: return 'seascape'; } })(); } } break; case 277: { let spp = getformat_fx(en, bytes, valptr, fmt); { let obj1025 = exif; obj1025.samplesPerPixel = spp; } } break; case 278: undefined; break; case 279: undefined; break; case 282: { let xr = getformat(en, bytes, valptr, fmt); { let obj1026 = exif; obj1026.xresolution = xr; } } break; case 283: { let yr = getformat(en, bytes, valptr, fmt); { let obj1027 = exif; obj1027.yresolution = yr; } } break; case 284: 'todo'; break; case 296: { let ru = getformat(en, bytes, valptr, fmt); { let obj1028 = exif; obj1028.resolutionUnit = ru; } } break; case 305: { let obj1029 = exif; obj1029.software = strncpy(valptr, bcount); } break; case 306: { let dt = strncpy(valptr, 31); { let obj1030 = exif; obj1030.date = parseExifDate(dt); } } break; case 315: { let obj1031 = exif; obj1031.artist = strncpy(valptr, bcount); } break; case 330: 'ignored'; break; case 346: 'ignored'; break; case 513: { let ol = getformat_fx(en, bytes, valptr, fmt), of = (ol + base); { let obj1032 = exif; obj1032['$thumbnailOffset'] = of; } } break; case 514: { let le = getformat_fx(en, bytes, valptr, fmt); { let obj1033 = exif; obj1033['$thumbnailLength'] = le; } } break; case 515: 'todo'; break; case 517: 'todo'; break; case 518: 'todo'; break; case 519: 'todo'; break; case 520: 'todo'; break; case 520: 'todo'; break; case 529: { let co = getformat(en, bytes, valptr, fmt); { let obj1034 = exif; obj1034.YCbCrCoef = co; } } break; case 530: { let ss = getformat_fx(en, bytes, valptr, fmt); { let obj1035 = exif; obj1035.YCbCrSubsampling = ss; } } break; case 531: { let pos = getformat_fx(en, bytes, valptr, fmt); { let obj1036 = exif; obj1036.YCbCrPositioning = pos; } } break; case 532: { let ref = getformat(en, bytes, valptr, fmt); { let obj1037 = exif; obj1037.refere = ref; } } break; case 18246: { let ra = getformat(en, bytes, valptr, fmt); { let obj1038 = exif; obj1038.rating = ra; } } break; case 18249: { let ra = getformat(en, bytes, valptr, fmt); { let obj1039 = exif; obj1039.ratingPercentage = ra; } } break; case 33432: { let obj1040 = exif; obj1040.copyright = strncpy(valptr, bcount); } break; case 33434: { let et = getformat(en, bytes, valptr, fmt); { let obj1041 = exif; obj1041.exposureTime = et; } } break; case 33437: { let fn = getformat(en, bytes, valptr, fmt); { let obj1042 = exif; obj1042.fnumber = fn; } } break; case 34665: { let ss = (base + get32u(en, bytes, valptr)); processExifDir$(en, bytes, ss, base, exif, o0, 0, true, extension); } break; case 34850: { let e = getformat(en, bytes, valptr, fmt); { let obj1043 = exif; obj1043.exposureProgram = e; } } break; case 34853: { let t = getformat_fx(en, bytes, valptr, fmt); { let obj1044 = exif; obj1044['$gpsTag'] = t; } } break; case 34855: { let is = getformat(en, bytes, valptr, fmt); { let obj1045 = exif; obj1045.iso = is; } } break; case 36864: { let obj1046 = exif; obj1046.version = strncpy2(valptr, bcount); } break; case 36867:case 36868:{ let obj1047 = exif; obj1047.date = parseExifDate(strncpy(valptr, 19)); }break; case 36880: { let obj1048 = exif; obj1048.offsetTime = strncpy(valptr, bcount); } break; case 36881: { let obj1049 = exif; obj1049.offsetTimeOriginal = strncpy(valptr, bcount); } break; case 36882: { let obj1050 = exif; obj1050.offsetTimeDigitized = strncpy(valptr, bcount); } break; case 37121: undefined; break; case 37122: undefined; break; case 37377: { let sv = getformat(en, bytes, valptr, fmt); { let obj1051 = exif; obj1051.shutterSpeedValue = sv; } } break; case 37379: { let bv = getformat(en, bytes, valptr, fmt); { let obj1052 = exif; obj1052.brightnessValue = bv; } } break; case 37378: { let ap = getformat(en, bytes, valptr, fmt); { let obj1053 = exif; obj1053.aperture = ap; } } break; case 37380: { let bv = getformat(en, bytes, valptr, fmt); { let obj1054 = exif; obj1054.exposureBiasValue = bv; } } break; case 37381: { let ap = getformat(en, bytes, valptr, fmt); { let obj1055 = exif; obj1055.maxAperture = ap; } } break; case 37382: { let sd = getformat(en, bytes, valptr, fmt); { let obj1056 = exif; obj1056.subjectDistance = sd; } } break; case 37383: { let mm = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 2: return "center weight"; break; case 3: return "spot"; break; case 5: return "matrix"; break; default: return "???"; } })(); { let obj1057 = exif; obj1057.meteringMode = mm; } } break; case 37384: { let fl = getformat_fx(en, bytes, valptr, fmt), f = !((fl & 7) === 0); { let obj1058 = exif; obj1058.lightSource = f; } } break; case 37385: { let fl = getformat_fx(en, bytes, valptr, fmt), f = !((fl & 7) === 0); { let obj1059 = exif; obj1059.flash = f; } } break; case 37386: { let fl = getformat(en, bytes, valptr, fmt); { let obj1060 = exif; obj1060.focalLength = fl; } } break; case 37510: { let obj1061 = exif; obj1061['$commentpos'] = (valptr + o0);obj1061['$commentlen'] = 199;if (bytes.substring(valptr, valptr + 8) === "ASCII\u0000\u0000\u0000") obj1061.comment = removeTrailingSpaces$(strncpy((8 + valptr), 191)); } break; case 37500: { let obj1062 = exif; { let buf = ((typeof(bytes) === 'string') ? (bytes.substring(valptr, (valptr + bcount))) : (bytes.substring(valptr, (valptr + bcount)))); obj1062.makerNote = strncpy(valptr, bcount);readMakerNote(en, buf, exif); } } break; case 37520: undefined;undefined; break; case 37521: undefined;undefined; break; case 37522: undefined;undefined; break; case 40960: undefined;undefined; break; case 40961: { let cs = getformat_fx(en, bytes, valptr, fmt); { let obj1063 = exif; obj1063.colorspace = cs; } } break; case 40962: { let w = getformat_fx(en, bytes, valptr, fmt); { let obj1064 = exif; obj1064.ewidth = w; } } break; case 40963: { let w = getformat_fx(en, bytes, valptr, fmt); { let obj1065 = exif; obj1065.eheight = w; } } break; case 40965: undefined; break; case 41486: { let r = getformat(en, bytes, valptr, fmt); { let obj1066 = exif; obj1066.focalPlaneXres = ((pairp(r)) ? ((car(r) / cdr(r))) : (r)); } } break; case 41487: { let r = getformat(en, bytes, valptr, fmt); { let obj1067 = exif; obj1067.focalPlaneYres = ((pairp(r)) ? ((car(r) / cdr(r))) : (r)); } } break; case 41488: { let fpu = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 1: return 25.4; break; case 2: return 25.4; break; case 3: return 10; break; case 4: return 1; break; case 5: return 0.001; break; } })(); { let obj1068 = exif; obj1068.focalPlaneUnits = fpu; } } break; case 41495: { let sm = getformat(en, bytes, valptr, fmt); { let obj1069 = exif; obj1069.sensingMethod = sm; } } break; case 41728: { let obj1070 = exif; obj1070.fileSource = (() => { switch (getformat(en, bytes, valptr, fmt)) { case 1: return "Film Scanner"; break; case 2: return "Reflection Print Scanner"; break; case 3: return "Digital Camera"; break; default: return "unknown"; } })(); } break; case 41729: undefined; break; case 41985: { let cr = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "normal"; break; case 1: return "custom"; break; case 2: return "HDR (no original saved)"; break; case 3: return "HDR (original saved)"; break; case 4: return "original (for HDR)"; break; case 6: return "panorama"; break; case 7: return "portrait HDR"; break; case 8: return "portraitauto"; break; default: return "???"; } })(); { let obj1071 = exif; obj1071.customRender = cr; } } break; case 41986: { let em = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "auto"; break; case 1: return "manual"; break; case 1: return "auto bracket"; break; default: return "???"; } })(); { let obj1072 = exif; obj1072.exposureMode = em; } } break; case 41987: { let wb = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "auto"; break; case 1: return "manual"; break; default: return "???"; } })(); { let obj1073 = exif; obj1073.whiteBalance = wb; } } break; case 41988: { let dz = getformat(en, bytes, valptr, fmt); { let obj1074 = exif; obj1074.digitalZoomRatio = dz; } } break; case 41989: { let fl = getformat(en, bytes, valptr, fmt); { let obj1075 = exif; obj1075.focalLength35 = fl; } } break; case 41990: { let mm = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "standard"; break; case 1: return "landscape"; break; case 2: return "portrait"; break; case 3: return "night"; break; case 3: return "other"; break; default: return "???"; } })(); { let obj1076 = exif; obj1076.sceneCaptureType = mm; } } break; case 41991: { let gc = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "none"; break; case 1: return "low gain up"; break; case 2: return "high gain up"; break; case 3: return "low gain down"; break; case 4: return "high gain down"; break; default: return "???"; } })(); { let obj1077 = exif; obj1077.gainControl = gc; } } break; case 41992: { let mm = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "normal"; break; case 1: return "low"; break; case 2: return "hight"; break; default: return "???"; } })(); { let obj1078 = exif; obj1078.contrast = mm; } } break; case 41993: { let mm = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "normal"; break; case 1: return "low"; break; case 2: return "hight"; break; default: return "???"; } })(); { let obj1079 = exif; obj1079.saturation = mm; } } break; case 41994: { let mm = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "normal"; break; case 1: return "soft"; break; case 2: return "hard"; break; default: return "???"; } })(); { let obj1080 = exif; obj1080.sharpness = mm; } } break; case 41996: { let d = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "unkown"; break; case 1: return "macro"; break; case 2: return "close"; break; case 3: return "distant"; break; default: return "???"; } })(); { let obj1081 = exif; obj1081.distanceSubjectRange = d; } } break; case 42035: { let obj1082 = exif; obj1082.lensMake = strncpy(valptr, bcount); } break; case 42036: { let obj1083 = exif; obj1083.lensModel = strncpy(valptr, bcount); } break; case 42080: { let obj1084 = exif; obj1084.compositeImage = strncpy(valptr, bcount); } break; case 50706:case 50707:'ignored';break; case 50708: { let obj1085 = exif; obj1085.uniqueCameraModel = strncpy(valptr, bcount); } break; case 50709: 'ignored'; break; case 50721:case 50722:case 50723:'ignored';break; case 50724: 'ignored'; break; case 50725: 'ignored'; break; case 50726: 'ignored'; break; case 50727: 'ignored'; break; case 50728: 'ignored'; break; case 50729: 'ignored'; break; case 50730: 'ignored'; break; case 50731: 'ignored'; break; case 50732: 'ignored'; break; case 50733: 'ignored'; break; case 50734: 'ignored'; break; case 50735: { let obj1086 = exif; obj1086.cameraSerialNumber = strncpy(valptr, bcount); } break; case 50739: 'ignored'; break; case 50740: 'ignored'; break; case 50741: 'ignored'; break; case 50778:case 50779:case 50780:'ignored';break; case 50781: 'ignored'; break; case 50931: 'ignored'; break; case 50932: 'ignored'; break; case 50934: 'ignored'; break; case 50935: 'ignored'; break; case 50936: 'ignored'; break; case 51041: 'ignored'; break; case 50937:case 50938:case 50939:case 50940:case 50941:'ignored';break; case 50942: 'ignored'; break; case 41730: 'ignored'; break; case 50964:case 50965:case 50966:case 50967:case 50968:case 50969:case 50970:'ignored';break; case 50971: 'ignored'; break; case 50981:case 50982:'ignored';break; case 51111: 'ignored'; break; default: extension(exif, tag, en, bytes, fmt, bcount, valptr); }return loop((de + 1)); } } })(0)); loop$ }if ((readNext) && (((start + (2 + (4 + (12 * dnum)))) < ((typeof(bytes) === 'string') ? (bytes.length) : (bytes.length))))) { let of = get32u(en, bytes, (start + (2 + (12 * dnum)))); if ((of > 0)) return processExifDir$(en, bytes, (of + base), base, exif, o0, 0, readNext, extension); } } }
)
const readJpegExif$ = ((exif, bytes, pos) => { let exifEndianess = (() => { if (bytes.substring(6, 6 + 2) === "II") return false; else if (bytes.substring(6, 6 + 2) === "MM") return true; else { warning("'read-jpeg-exif", "Unknown exif endianess, assuming big endian");return false; }
 }
);if ((bytes[4] === '\u0000') && (bytes[5] === '\u0000')) { let en = exifEndianess(), hd = get16u(en, bytes, 8); if (!(hd === 42)) return exifError("read-jpeg-exif", "Illegal exif header", hd); else { let fo = get32u(en, bytes, 10); if (((fo < 8)) || ((fo > 16))) return exifError("read-jpeg-exit", "Suspicious offset of first IFD value", fo); else { let obj1087 = exif; obj1087.endianess = en;processExifDir$(en, bytes, (6 + fo), 6, exif, pos, 0, true, ((exif, tag, en, bytes, fmt, bcount, valptr) => { undefined;return 'unknown'; }
));if ((typeof (obj1087.ewidth) === 'number') && (typeof (obj1087.eheight) === 'number') && (typeof (obj1087.focalPlaneXres) === 'number') && (typeof (obj1087.focalPlaneUnits) === 'number')) { { let w = ((obj1087.ewidth * obj1087.focalPlaneUnits) / obj1087.focalPlaneXres); obj1087.cddWidth = w; }{ let h = ((obj1087.eheight * obj1087.focalPlaneUnits) / obj1087.focalPlaneXres); obj1087.cddHeight = h; } }
if (!obj1087.thumbnail) if ((Number.isInteger(obj1087['$thumbnailOffset'])) && (Number.isInteger(obj1087['$thumbnailLength']))) { let th = Buffer.from(bytes.substring(obj1087['$thumbnailOffset'], (obj1087['$thumbnailOffset'] + obj1087['$thumbnailLength'])), "binary"); obj1087.thumbnail = th; }return exif; } } } }
)
const readCom$ = ((exif, bytes, pos) => { { let obj1088 = exif; { let len = bytes.length; { const loop$ = ((function loop(i) { if (i === len) return obj1088.comment = bytes; else if (bytes[i] === '\u0000') { let s = bytes.substring(0, i); obj1088.comment = s;obj1088['$commentpos'] = pos;return obj1088['$commentlen'] = i; } else return loop((i + 1)); })(0)); return loop$; } } } }
)
const readSofn$ = ((exif, bytes, encoding) => { { let obj1089 = exif; if (!obj1089.width) obj1089.width = get16u(true, bytes, 3);if (!obj1089.height) obj1089.height = get16u(true, bytes, 1);obj1089.jpegEncoding = encoding; }return exif; }
)
const readJpegSection = ((mm) => { const loop$ = ((function loop(a, m) { if (m === '\u00ff') if ((a >= 6)) return exifError("read-jpeg-section", "Too many padding bytes", a); else return loop((a + 1), mm.get()); else { let lh = mm.get().charCodeAt(0), ll = mm.get().charCodeAt(0), l = ((lh << 8) | ll); if ((l < 2)) return exifError("read-jpeg-section", "Section too small", a); else if (((l + mm.rindex) >= mm.length)) return exifError("read-jpeg-section", "Premature end of section read: "+(mm.length - mm.rindex), ", expected: "+l - 2); else { let offset = mm.rindex; return [m.charCodeAt(0), mm.toString((l - 2)), offset]; } } })(0, mm.get())); return loop$; })
const readJpegSections = ((exif, mm) => { { let m = readJpegMarker(mm); if (m !== 216) exifError("read-jpeg-sections", "Illegal section marker", (mm.rindex - 1)); else { const loop$ = ((function loop() { { let [m, bytes, offset] = readJpegSection(mm); switch (m) { case 218: return 'sos'; break; case 217: return 'eoi'; break; case 254: readCom$(exif, bytes, mm.rindex - bytes.length);return loop(); break; case 224: return loop(); break; case 225: if (bytes.substring(0, 6) === "Exif\u0000\u0000") { let obj1090 = exif; readJpegExif$(exif, bytes, mm.rindex - bytes.length);if (obj1090['$gpsTag']) { processExifDir$(obj1090.endianess, bytes, (obj1090['$gpsTag'] + 6), 6, exif, 0, 65536, true, ((exif, tag, en, bytes, fmt, bcount, valptr) => { return 'unknown'; }
));{ let obj1091 = exif; if ((Number.isInteger(obj1091['$gpsAltitudeRef'])) && (obj1091['$gpsAltitudeRef'] === 1)) setCar$(obj1091.gpsAltitude, - car(obj1091.gpsAltitude));if (obj1091['$gpsLatitudeRef'] == "S") obj1091.gpsLatitude = -obj1091.gpsLatitude;if (obj1091['$gpsLongitudeRef'] == "W") obj1091.gpsLongitude = -obj1091.gpsLongitude; } }
 }return loop(); break; case 192: readSofn$(exif, bytes, "baseline");return loop(); break; case 193: readSofn$(exif, bytes, "extended sequential");return loop(); break; case 194: readSofn$(exif, bytes, "progressive");return loop(); break; case 195: readSofn$(exif, bytes, "lossless");return loop(); break; case 197: readSofn$(exif, bytes, "differential sequential");return loop(); break; case 198: readSofn$(exif, bytes, "differential progressive");return loop(); break; case 199: readSofn$(exif, bytes, "differential lossless");return loop(); break; case 201: readSofn$(exif, bytes, "extended sequential, arithmetic coding");return loop(); break; case 202: readSofn$(exif, bytes, "progressive, arithmetic coding");return loop(); break; case 203: readSofn$(exif, bytes, "lossless, arithmetic coding");return loop(); break; case 204: readSofn$(exif, bytes, "differential sequential, arithmetic coding");return loop(); break; case 205: readSofn$(exif, bytes, "differential progressive, arithmetic coding");return loop(); break; case 206: readSofn$(exif, bytes, "differential lossless, arithmetic coding");return loop(); break; case 207: readSofn$(exif, bytes, "?");return loop(); break; default: return loop(); } } })()); loop$ } }return exif; }
)
const readMakerNote = ((en, bytes, exif) => { if (bytes.startsWith("Panasonic")) return processExifDir$(en, bytes, 12, 0, exif, 0, 20000, false, ((exif, tag, en, bytes, fmt, bcount, valptr) => { switch (tag) { case 75: { let obj1092 = exif; return obj1092.width = getformat(en, bytes, valptr, fmt); } break; case 76: { let obj1093 = exif; return obj1093.height = getformat(en, bytes, valptr, fmt); } break; case 209: return undefined; break; default: return undefined; } }
)); }
)
const readTiffSections = ((exif, mm) => { let tiffEndianess = (() => { return mm.ref(0) === 'M'; }
);let strncpy = ((o, max) => { const loop$ = ((function loop(i) { if (i === max) return mm.substring(o, (o + i)); else { let c = mm.ref((i + o)); if (c === '\u0000') return mm.substring(o, (i + o)); else return loop((i + 1)); } })(0)); return loop$; });let readIfd = ((en, offset) => { return processExifDir$(en, mm, offset, 0, exif, 0, 0, true, ((exif, tag, en, bytes, fmt, bcount, valptr) => { console.error("read-ifd extension", tag, " ", valptr);return 'unknown'; }
)); }
);{ let en = tiffEndianess(), offset = get32u(en, mm, 4); return readIfd(en, offset); } }
)
const readRw2Sections = ((exif, mm) => { let tiffEndianess = (() => { return mm.ref(0) === 'M'; }
);let strncpy = ((o, max) => { const loop$ = ((function loop(i) { if (i === max) return mm.substring(o, (o + i)); else { let c = mm.ref((i + o)); if (c === '\u0000') return mm.substring(o, (i + o)); else return loop((i + 1)); } })(0)); return loop$; });let cameraIfd = 0;let extension = ((exif, tag, en, bytes, fmt, bcount, valptr) => { switch (tag) { case 1: undefined;return undefined; break; case 2: { let w = getformat(en, bytes, valptr, fmt); { let obj1094 = exif; return obj1094.cddWidth = w; } } break; case 3: { let h = getformat(en, bytes, valptr, fmt); { let obj1095 = exif; return obj1095.cddHeight = h; } } break; case 4:case 5:case 6:case 7:return undefined;break; case 8: { let spp = getformat_fx(en, bytes, valptr, fmt); { let obj1096 = exif; return obj1096.samplesPerPixel = spp; } } break; case 9: return undefined; break; case 10: { let bps = getformat(en, bytes, valptr, fmt); { let obj1097 = exif; return obj1097.bitsPerSample = bps; } } break; case 11: { let c = getformat(en, bytes, valptr, fmt); { let obj1098 = exif; return obj1098.jpegCompress = c; } } break; case 14:case 15:case 16:case 17:case 18:return undefined;break; case 19: return undefined; break; case 23: { let is = getformat_fx(en, bytes, valptr, fmt); { let obj1099 = exif; return obj1099.iso = is; } } break; case 24:case 25:case 26:return undefined;break; case 27: return undefined; break; case 28:case 29:case 30:case 36:case 37:case 38:return undefined;break; case 39: return undefined; break; case 45: return undefined; break; case 46: { let obj1100 = exif; obj1100['$thumbnailOffset'] = valptr;obj1100['$thumbnailLength'] = bcount;obj1100.thumbnail = Buffer.from(bytes.substring(valptr, (valptr + bcount)), "binary");return readJpegSections(exif, Mmap.stringToMmap(obj1100.thumbnail)); } break; case 47:case 48:case 49:case 50:return undefined;break; case 75: return console.error("Panasonic image width ", getformat(en, bytes, valptr, fmt)); break; case 76: return console.error("Panasonic image height ", getformat(en, bytes, valptr, fmt)); break; case 278: return undefined; break; case 279: return console.error("StripByteCounts ", getformat(en, bytes, valptr, fmt)); break; case 280: return undefined; break; case 281: return undefined; break; case 288: return cameraIfd = valptr; break; case 289: return undefined; break; case 295: return undefined; break; case 315: { let obj1101 = exif; return obj1101.artist = strncpy(valptr, bcount); } break; case 700: return undefined; break; case 33723: return undefined; break; default: { let val = getformat(en, bytes, valptr, fmt); undefined;return 'unknown'; } } }
);let cameraIfdExtension = ((exif, tag, en, bytes, fmt, bcount, valptr) => { switch (tag) { case 4352: return undefined; break; case 4353: return undefined; break; case 4354: return undefined; break; case 4357: return undefined; break; case 4608: return undefined; break; case 4609: { let obj1102 = exif; return obj1102.lensMake = strncpy(valptr, bcount); } break; case 4610: { let obj1103 = exif; return obj1103.lensModel = strncpy(valptr, bcount); } break; case 4611: { let obj1104 = exif; return obj1104.focalLength35 = getformat(en, bytes, valptr, fmt); } break; case 4865: { let v = getformat(en, bytes, valptr, fmt); { let obj1105 = exif; return obj1105.aperture = 2 ** (v / 512); } } break; case 4866: { let v = getformat(en, bytes, valptr, fmt); { let obj1106 = exif; return obj1106.shutterSpeedValue = ((((v / 256) < 100)) ? (2 ** (- v / 256)) : (0)); } } break; case 4867: return undefined; break; case 4869: return undefined; break; case 5138: return undefined; break; case 12800:case 3201:case 3202:return undefined;break; case 13056: return undefined; break; case 13344:case 13345:return undefined;break; case 13569: { let o = getformat(en, bytes, valptr, fmt); { let obj1107 = exif; return obj1107.orientation = (() => { switch (o) { case 1:case 2:return 'landscape';break; case 3: return 'upsidedown'; break; case 5:case 6:case 7:case 8:return 'portrait';break; default: return 'seascape'; } })(); } } break; case 13824: return undefined; break; default: return undefined; } }
);let readIfd = ((en, offset) => { return processExifDir$(en, mm, offset, 0, exif, 0, 0, true, extension); }
);{ let en = tiffEndianess(), offset = get32u(en, mm, 4); readIfd(en, offset);if ((cameraIfd > 0)) { let offset = get32u(en, mm, (cameraIfd + 4)), start = (cameraIfd + offset); processExifDir$(en, mm, start, 0, exif, 0, 0, false, cameraIfdExtension); }return exif; } }
)
const readRafSections = ((exif, mm) => { { let pos = mm.rindex, fmtv = mm.substring(pos, (pos + 4)), id = mm.substring((pos + 4), (pos + 12)); pos = mm.rindex;{ let buf = mm.substring(pos, (pos + 32)), i = buf.indexOf('\u0000'), model = buf.substring(0, i); { let obj1108 = exif; obj1108.make = "FUJIFILM";obj1108.uniqueCameraModel = model;obj1108.cameraSerialNumber = id;{ let version = mm.toString(4), unknown = mm.toString(20), jpegoff = mm.toString(4), metaoff = mm.toString(4), metalen = mm.toString(4), cfaoff = mm.toString(4), cfalen = mm.toString(4), unknownlen = mm.toString(12), someoff = mm.toString(4); mm.rindex = (mm.rindex + 28);return readJpegSections(exif, mm); } } } } }
)
const tiffp = ((mm) => { let res = (() => { switch (mm.ref(0)) { case "I":return (mm.get() === 'I') && (mm.get() === '*') && (mm.get() === '\u0000');break; case "M":return (mm.get() === 'M') && (mm.get() === '\u0000') && (mm.get() === '*');break; default: return false; } })(); if (!res) mm.rindex = 0;return res; })
const rw2p = ((mm) => { let res = (mm.ref(0) === 'I') && (mm.get() === 'I') && (mm.get() === 'U') && (mm.get() === '\u0000') && (['', ''].includes(mm.get())) && (mm.get() === '\u0000') && (mm.get() === '\u0000') && (mm.get() === '\u0000'); if (!res) mm.rindex = 0;return res; })
const rafp = ((mm) => { { let sig = "FUJIFILMCCD-RAW ", mark = mm.substring(0, sig.length), res = mark === sig; if (!res) mm.rindex = 0;return res; } }
)
const jpegExif = ((path) => { if (!(fs.existsSync(path))) return error_errno($errnoIoFileNotFoundError, "jpeg-exif", "Can't find file", path); else { let mm = new Mmap(path, 'write', false), exf = new exif({}); try { if ((mm.length > 64)) if (tiffp(mm)) readTiffSections(exf, mm); else if (rw2p(mm)) readRw2Sections(exf, mm); else if (rafp(mm)) readRafSections(exf, mm); else { mm.rindex = 0;readJpegSections(exf, mm); }
 } finally { mm.close() }return exf; } }
)
const jpegExifCommentSet$ = ((path, comment) => { if (!(fs.existsSync(path))) return error_errno($errnoIoFileNotFoundError, "jpeg-exif-comment-set!", "Can't find file", path); else { let mm = new Mmap(path), exf = new exif({}), mtime = false; try { if ((mm.length > 0)) { readJpegSections(exf, mm);{ let obj1109 = exf; return (obj1109['$commentpos']) && ((((len, s) => { mm.windex = obj1109['$commentpos'];mmapPutString$(mm, "ASCII\u0000\u0000\u0000");mmapPutString$(mm, s);mmapPutString$(mm, "\u0000");mtime = true;return s; })(comment.length, (((len < obj1109['$commentlen'])) ? (comment) : (comment.substring(0, obj1109['$commentlen'])))))); } }
 } finally { mm.close();if (mtime) { let pr = openInputFile(path), pw = appendOutputFile(path); { let c = readChar(pr); setOutputPortPosition$(pw, 0);writeChar(c, pw); }closeInputPort(pr);closeOutputPort(pw); } }
 } }
)
const jpegExifOrientationSet$ = ((path, orientation) => { if (!(fs.existsSync(path))) return error_errno($errnoIoFileNotFoundError, "jpeg-exif-comment-set!", "Can't find file", path); else { let mm = new Mmap(path), exf = new exif({}), mtime = false; try { if ((mm.length > 0)) { readJpegSections(exf, mm);{ let obj1110 = exf; if (obj1110['$orientationpos']) { mm.windex = obj1110['$orientationpos'];switch (orientation) { case 'landscape': mmapPutString$(mm, ""); break; case 'portrait': mmapPutString$(mm, ""); break; case 'upsidedonw': mmapPutString$(mm, ""); break; case 'seascape': mmapPutString$(mm, ""); break; }mtime = true;return orientation; }
 } }
 } finally { mm.close();if (mtime) { let pr = openInputFile(path), pw = appendOutputFile(path); { let c = readChar(pr); setOutputPortPosition$(pw, 0);writeChar(c, pw); }closeInputPort(pr);closeOutputPort(pw); } }
 } }
)
const parseExifDate = ((d) => { let parseError = ((d, i) => { throw new $ioParseError({'proc': 'parse-exif-date','msg': "Illegal syntax",'obj': "a{"+d.substring(0, i)+"}"+d[i]}); }
);let substringtoint = ((d, i, l) => { let len = (i + l), zero = '0'.charCodeAt(0); { const loop$ = ((function loop(i, acc) { if (i === len) return acc; else { let v = (d[i].charCodeAt(0) - zero); if (((v < 0)) || ((v > 9))) return parseError(d, i); else return loop((i + 1), (v + (acc * 10))); } })(i, 0)); return loop$; } });if ((d.length === 19) && (d[4] === ':') && (d[7] === ':') && (d[10] === ' ') && (d[13] === ':') && (d[16] === ':')) return makeDate({"sec": substringtoint(d, 17, 2), "min": substringtoint(d, 14, 2), "hour": substringtoint(d, 11, 2), "day": substringtoint(d, 8, 2), "month": substringtoint(d, 5, 2), "year": substringtoint(d, 0, 4)}); else return parseError(d, 0); }
)
