/*=====================================================================*/
/*    .../project/hop/hop/node_modules/exif/node/exif-module.js        */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Tue Mar 26 07:54:31 2024                          */
/*    Last change :  Tue Mar 26 18:11:23 2024 (serrano)                */
/*    Copyright   :  2024 Manuel Serrano                               */
/*    -------------------------------------------------------------    */
/*    Exif parser (generated from bigloo:api/multimedia/Llib/exif.scm) */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    The module                                                       */
/*---------------------------------------------------------------------*/
import * as fs from "node:fs";
import { Mmap } from "./mmap.mjs";

/*---------------------------------------------------------------------*/
/*    errors                                                           */
/*---------------------------------------------------------------------*/
const $errnoIoFileNotFoundError = Error.ENOENT;
const $errnoIoParseError = -1;

/*---------------------------------------------------------------------*/
/*    error_errno ...                                                  */
/*---------------------------------------------------------------------*/
function error_errno(errno, proc, msg, obj) {
   const err = new Error(`${proc}: ${msg} -- ${obj}`);
   err.errno = errno;
   throw err;
}

/*---------------------------------------------------------------------*/
/*    $ioParseError ...                                                */
/*---------------------------------------------------------------------*/
function $ioParseError({proc, msg, obj}) {
   throw new Error(`${proc}: ${msg} -- ${obj}`);
}

/*---------------------------------------------------------------------*/
/*    warning ...                                                      */
/*---------------------------------------------------------------------*/
function warning(...vals) {
   console.log.apply(console, vals);
}

/*---------------------------------------------------------------------*/
/*    makeDate ...                                                     */
/*---------------------------------------------------------------------*/
function makeDate({sec, min, hour, day, month, year}) {
   return new Date(year, month - 1, day, hour, min, sec);
}

/*---------------------------------------------------------------------*/
/*    Cons ...                                                         */
/*---------------------------------------------------------------------*/
function Cons(a, d) {
   this.car = a;
   this.cdr = d;
}

/*---------------------------------------------------------------------*/
/*    cons ...                                                         */
/*---------------------------------------------------------------------*/
function cons(a, d) {
   return new Cons(a, d);
}

/*---------------------------------------------------------------------*/
/*    pairp ...                                                        */
/*---------------------------------------------------------------------*/
function pairp(o) {
   o instanceof Cons;
}

/*---------------------------------------------------------------------*/
/*    car ...                                                          */
/*---------------------------------------------------------------------*/
function car(o) {
   return o.car;
}

/*---------------------------------------------------------------------*/
/*    cdr ...                                                          */
/*---------------------------------------------------------------------*/
function cdr(o) {
   return o.cdr;
}
// generated by /home/serrano/prgm/project/hop/hop/node_modules/exif/node/mkjast.scm
"use strict"

export function exif(props) {
   this.$class = 'exif';
   this['jpeg-encoding'] = false;
   this['jpeg-compress'] = false;
   this['software'] = false;
   this['comment'] = false;
   this['%commentpos'] = false;
   this['%commentlen'] = false;
   this['description'] = false;
   this['date'] = false;
   this['offset-time'] = false;
   this['offset-time-original'] = false;
   this['offset-time-digitized'] = false;
   this['make'] = false;
   this['model'] = false;
   this['unique-camera-model'] = false;
   this['camera-serial-number'] = false;
   this['orientation'] = 'landscape';
   this['%orientationpos'] = false;
   this['width'] = false;
   this['height'] = false;
   this['iwidth'] = false;
   this['ilength'] = false;
   this['ewidth'] = false;
   this['eheight'] = false;
   this['xresolution'] = false;
   this['yresolution'] = false;
   this['resolution-unit'] = false;
   this['focal-length'] = false;
   this['focal-length35'] = false;
   this['custom-render'] = false;
   this['exposure-mode'] = false;
   this['white-balance'] = false;
   this['digital-zoom-ratio'] = false;
   this['light-source'] = false;
   this['flash'] = false;
   this['fnumber'] = false;
   this['iso'] = false;
   this['shutter-speed-value'] = false;
   this['exposure-program'] = false;
   this['exposure-time'] = false;
   this['exposure-bias-value'] = false;
   this['aperture'] = false;
   this['max-aperture'] = false;
   this['metering-mode'] = false;
   this['cdd-width'] = false;
   this['focal-plane-xres'] = false;
   this['focal-plane-yres'] = false;
   this['focal-plane-units'] = false;
   this['gps-tag'] = false;
   this['brightness-value'] = false;
   this['subject-distance'] = false;
   this['colorspace'] = false;
   this['sensing-method'] = false;
   this['composite-image'] = false;
   this['lens-make'] = false;
   this['lens-model'] = false;
   this['digitalZoomRatio'] = false;
   this['scene-capture-type'] = "???";
   this['gain-control'] = "???";
   this['contrast'] = "???";
   this['saturation'] = "???";
   this['sharpness'] = "???";
   this['distance-subject-range'] = false;
   this['new-subfile-type'] = false;
   this['YCbCr-coef'] = false;
   this['YCbCr-subsampling'] = false;
   this['YCbCr-positioning'] = false;
   this['refere'] = false;
   this['rating'] = false;
   this['rating-percentage'] = false;
   this['copyright'] = false;
   this['artist'] = false;
   this['maker-node'] = false;
   this['thumbnail'] = false;
   this['thumbnail-path'] = false;
   this['thumbnail-offset'] = false;
   this['thumbnail-length'] = false;
   Object.assign(this, props);
}
exif.prototype.duplicate = function(prop) {
   const o = new exif({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

// generated by hop2js
export {jpegExif, jpegExifCommentSet$, jpegExifOrientationSet$, parseExifDate}
const exifError = ((proc, msg, obj) => { return error_errno($errnoIoParseError, proc, msg, obj); }
)
const get16u = ((en, bytes, o) => { let stringGet16U = ((en, bytes, o) => { return (en) ? (((bytes[o].charCodeAt(0) << 8) | bytes[(1 + o)].charCodeAt(0))) : (((bytes[(1 + o)].charCodeAt(0) << 8) | bytes[o].charCodeAt(0))); }
);let mmapGet16U = ((en, bytes, o) => { return (en) ? (((bytes.ref(o).charCodeAt(0) << 8) | bytes.ref((1 + o)).charCodeAt(0))) : (((bytes.ref((1 + o)).charCodeAt(0) << 8) | bytes.ref(o).charCodeAt(0))); }
);if (typeof(bytes) === 'string') return stringGet16U(en, bytes, o); else return mmapGet16U(en, bytes, o); }
)
const get32u = ((en, bytes, o) => { let stringGet32U = ((en, bytes, o) => { let e0 = bytes[o].charCodeAt(0), e1 = bytes[(1 + o)].charCodeAt(0), e2 = bytes[(2 + o)].charCodeAt(0), e3 = bytes[(3 + o)].charCodeAt(0); if (en) return ((e0 << 24) | ((e1 << 16) | ((e2 << 8) | e3))); else return ((e3 << 24) | ((e2 << 16) | ((e1 << 8) | e0))); });let mmapGet32U = ((en, bytes, o) => { let e0 = bytes.ref(o).charCodeAt(0), e1 = bytes.ref((1 + o)).charCodeAt(0), e2 = bytes.ref((2 + o)).charCodeAt(0), e3 = bytes.ref((3 + o)).charCodeAt(0); if (en) return ((e0 << 24) | ((e1 << 16) | ((e2 << 8) | e3))); else return ((e3 << 24) | ((e2 << 16) | ((e1 << 8) | e0))); });if (typeof(bytes) === 'string') return stringGet32U(en, bytes, o); else return mmapGet32U(en, bytes, o); }
)
const getformat = ((en, bytes, o, fmt) => { switch (fmt) { case 1:case 6:return (typeof(bytes) === 'string') ? (bytes[o]) : (bytes.ref(o)).charCodeAt(0);break; case 3:case 8:return get16u(en, bytes, o);break; case 4:case 9:return get32u(en, bytes, o);break; case 5:case 10:{ let num = get32u(en, bytes, o), den = get32u(en, bytes, (o + 4)); if (den === 0) return 0; else return cons(num, den); }break; case 11: return exifError("exif", "Unsupported number format", fmt); break; case 12: return exifError("exif", "Unsupported number format", fmt); break; default: return 0; } }
)
const getformat_fx = ((en, bytes, o, fmt) => { let res = getformat(en, bytes, o, fmt); if (Number.isInteger(res)) return res; else if (elongp(res)) return res; else return 0; })
let _exifFormatsSize_ = ['_', 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8]
const readJpegMarker = ((p) => { if (!(p.get() === '\u00ff')) return false; else return p.get().charCodeAt(0); }
)
const removeTrailingSpaces$ = ((s) => { let len = s.length; if (len === 0) return s; else { let start = (len - 1); { const loop$ = ((function loop(i) { if (s[i] === ' ') return loop((i - 1)); else if (i === 0) return ""; else if (i === start) return s; else return stringShrink$(s, (i + 1)); })(start)); return loop$; } } })
const processExifDir$ = ((en, bytes, start, base, exif, o0) => { let strncpy = ((o, max) => { let stringStrncpy = ((o, max) => { const loop$ = ((function loop(i) { if (i === max) return bytes.substring(o, (o + i)); else { let c = bytes[(i + o)]; if (c === '\u0000') return bytes.substring(o, (o + i)); else return loop((i + 1)); } })(0)); return loop$; });let mmapStrncpy = ((o, max) => { const loop$ = ((function loop(i) { if (i === max) return mmapSubstring(bytes, o, (o + i)); else { let c = bytes.ref((i + o)); if (c === '\u0000') return mmapSubstring(bytes, o, (i + o)); else return loop((i + 1)); } })(0)); return loop$; });if (typeof(bytes) === 'string') return stringStrncpy(o, max); else return mmapStrncpy(o, max); }
);let processExifGpsTag = ((o, bcount) => { return false; }
);{ let dnum = get16u(en, bytes, start); { const loop$ = ((function loop(de) { if ((de < dnum)) { let da = (start + (2 + (12 * de))), tag = get16u(en, bytes, da), fmt = get16u(en, bytes, (2 + da)), cmp = get32u(en, bytes, (4 + da)); { let bcount = (cmp * _exifFormatsSize_[fmt]), valptr = ((bcount > 4)) ? ((((ov) => { return (base + ov); })(get32u(en, bytes, (8 + da))))) : ((8 + da)); switch (tag) { case 1: undefined; break; case 1: { let lr = strncpy(valptr, bcount); console.error("gps latitude ref");undefined; } break; case 2: { let la = strncpy(valptr, bcount); console.error("gps latitude");undefined; } break; case 3: { let lr = strncpy(valptr, bcount); console.error("gps longitude ref");undefined; } break; case 4: console.error("tag gps longitude...");undefined; break; case 5: console.error("tag gps altitude ref");undefined; break; case 6: console.error("tag gps altitude");undefined; break; case 7: console.error("tag gps timstamp");undefined; break; case 8: console.error("tag gps satelite [", strncpy(valptr, bcount), "]");undefined; break; case 9: console.error("tag gps status [", strncpy(valptr, bcount), "]");undefined; break; case 10: console.error("tag gps measure mode [", strncpy(valptr, bcount), "]");undefined; break; case 11: undefined; break; case 12: undefined; break; case 13: undefined; break; case 14: undefined; break; case 15: undefined; break; case 16: undefined; break; case 17: undefined; break; case 18:case 19:case 20:case 21:case 22:case 23:case 24:case 25:case 26:case 27:case 28:case 29:case 30:case 31:undefined;break; case 254: { let s = getformat_fx(en, bytes, valptr, fmt); exif['new-subfile-type'] = s; } break; case 256: { let w = getformat_fx(en, bytes, valptr, fmt); exif.iwidth = w; } break; case 257: { let l = getformat_fx(en, bytes, valptr, fmt); exif.ilength = l; } break; case 258: 'todo'; break; case 259: { let c = getformat(en, bytes, valptr, fmt); exif['jpeg-compress'] = c; } break; case 262: { let c = getformat(en, bytes, valptr, fmt); exif['jpeg-compress'] = c; } break; case 270: exif.description = strncpy(valptr, bcount); break; case 271: exif.make = strncpy(valptr, 31); break; case 272: exif.model = strncpy(valptr, 39); break; case 273: 'todo'; break; case 274: { let o = getformat(en, bytes, valptr, fmt); exif.orientation = (() => { switch (o) { case 1: return 'landscape'; break; case 6: return 'portrait'; break; case 8: return 'upsidedown'; break; default: return 'seascape'; } })(); } break; case 277: 'todo'; break; case 278: 'todo'; break; case 279: 'todo'; break; case 282: { let xr = getformat(en, bytes, valptr, fmt); exif.xresolution = xr; } break; case 283: { let yr = getformat(en, bytes, valptr, fmt); exif.yresolution = yr; } break; case 284: 'todo'; break; case 296: { let ru = getformat(en, bytes, valptr, fmt); exif['resolution-unit'] = ru; } break; case 305: exif.software = strncpy(valptr, bcount); break; case 306: { let dt = strncpy(valptr, 31); exif.date = parseExifDate(dt); } break; case 315: exif.artist = strncpy(valptr, bcount); break; case 330: 'ignored'; break; case 513: { let ol = getformat_fx(en, bytes, valptr, fmt), of = (ol + base); exif['thumbnail-offset'] = of; } break; case 514: { let le = getformat_fx(en, bytes, valptr, fmt); exif['thumbnail-length'] = le; } break; case 515: 'todo'; break; case 517: 'todo'; break; case 518: 'todo'; break; case 519: 'todo'; break; case 520: 'todo'; break; case 520: 'todo'; break; case 529: { let co = getformat(en, bytes, valptr, fmt); exif['YCbCr-coef'] = co; } break; case 530: { let ss = getformat_fx(en, bytes, valptr, fmt); exif['YCbCr-subsampling'] = ss; } break; case 531: { let pos = getformat_fx(en, bytes, valptr, fmt); exif['YCbCr-positioning'] = pos; } break; case 532: { let ref = getformat(en, bytes, valptr, fmt); exif.refere = ref; } break; case 18246: { let ra = getformat(en, bytes, valptr, fmt); exif.rating = ra; } break; case 18249: { let ra = getformat(en, bytes, valptr, fmt); exif['rating-percentage'] = ra; } break; case 33432: exif.copyright = strncpy(valptr, bcount); break; case 33434: { let et = getformat(en, bytes, valptr, fmt); exif['exposure-time'] = et; } break; case 33437: { let fn = getformat(en, bytes, valptr, fmt); exif.fnumber = fn; } break; case 34665: { let ss = (base + get32u(en, bytes, valptr)); processExifDir$(en, bytes, ss, base, exif, o0); } break; case 34850: { let e = getformat(en, bytes, valptr, fmt); exif['exposure-program'] = e; } break; case 34853: processExifGpsTag(valptr, bcount);{ let t = getformat_fx(en, bytes, valptr, fmt); exif['gps-tag'] = t; } break; case 34855: { let is = getformat(en, bytes, valptr, fmt); exif.iso = is; } break; case 36864: 'todo'; break; case 36867:case 36868:exif.date = parseExifDate(strncpy(valptr, 19));break; case 36880: exif['offset-time'] = strncpy(valptr, bcount); break; case 36881: exif['offset-time-original'] = strncpy(valptr, bcount); break; case 36882: exif['offset-time-digitized'] = strncpy(valptr, bcount); break; case 37121: undefined; break; case 37122: undefined; break; case 37377: { let sv = getformat(en, bytes, valptr, fmt); exif['shutter-speed-value'] = sv; } break; case 37379: { let bv = getformat(en, bytes, valptr, fmt); exif['brightness-value'] = bv; } break; case 37378: { let ap = getformat(en, bytes, valptr, fmt); exif.aperture = ap; } break; case 37380: { let bv = getformat(en, bytes, valptr, fmt); exif['exposure-bias-value'] = bv; } break; case 37381: { let ap = getformat(en, bytes, valptr, fmt); exif['max-aperture'] = ap; } break; case 37382: { let sd = getformat(en, bytes, valptr, fmt); exif['subject-distance'] = sd; } break; case 37383: { let mm = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 2: return "center weight"; break; case 3: return "spot"; break; case 5: return "matrix"; break; default: return "???"; } })(); exif['metering-mode'] = mm; } break; case 37384: { let fl = getformat_fx(en, bytes, valptr, fmt), f = !((fl & 7) === 0); exif['light-source'] = f; } break; case 37385: { let fl = getformat_fx(en, bytes, valptr, fmt), f = !((fl & 7) === 0); exif.flash = f; } break; case 37386: { let fl = getformat(en, bytes, valptr, fmt); exif['focal-length'] = fl; } break; case 37510: exif['%commentpos'] = (valptr + o0);exif['%commentlen'] = 199;if (bytes.substring(valptr, valptr + 8) === "ASCII\u0000\u0000\u0000") exif.comment = removeTrailingSpaces$(strncpy((8 + valptr), 191)); break; case 37500: strncpy(valptr, bcount); break; case 37520: undefined; break; case 37521: undefined; break; case 37522: undefined; break; case 40960: undefined; break; case 40961: { let cs = getformat_fx(en, bytes, valptr, fmt); exif.colorspace = cs; } break; case 40962: { let w = getformat_fx(en, bytes, valptr, fmt); exif.ewidth = w; } break; case 40963: { let w = getformat_fx(en, bytes, valptr, fmt); exif.eheight = w; } break; case 40965: undefined; break; case 41486: { let r = getformat(en, bytes, valptr, fmt); exif['focal-plane-xres'] = (pairp(r)) ? ((car(r) / cdr(r))) : (r); } break; case 41487: { let r = getformat(en, bytes, valptr, fmt); exif['focal-plane-yres'] = (pairp(r)) ? ((car(r) / cdr(r))) : (r); } break; case 41488: { let fpu = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 1: return 25.4; break; case 2: return 25.4; break; case 3: return 10; break; case 4: return 1; break; case 5: return 0.001; break; } })(); exif['focal-plane-units'] = fpu; } break; case 41495: { let sm = getformat(en, bytes, valptr, fmt); exif['sensing-method'] = sm; } break; case 41728: undefined; break; case 41729: undefined; break; case 41985: { let cr = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "normal"; break; case 1: return "custom"; break; case 2: return "HDR (no original saved)"; break; case 3: return "HDR (original saved)"; break; case 4: return "original (for HDR)"; break; case 6: return "panorama"; break; case 7: return "portrait HDR"; break; case 8: return "portraitauto"; break; default: return "???"; } })(); exif['custom-render'] = cr; } break; case 41986: { let em = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "auto"; break; case 1: return "manual"; break; case 1: return "auto bracket"; break; default: return "???"; } })(); exif['exposure-mode'] = em; } break; case 41987: { let wb = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "auto"; break; case 1: return "manual"; break; default: return "???"; } })(); exif['white-balance'] = wb; } break; case 41988: { let dz = getformat(en, bytes, valptr, fmt); exif['digital-zoom-ratio'] = dz; } break; case 41989: { let fl = getformat(en, bytes, valptr, fmt); exif['focal-length35'] = fl; } break; case 41990: { let mm = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "standard"; break; case 1: return "landscape"; break; case 2: return "portrait"; break; case 3: return "night"; break; case 3: return "other"; break; default: return "???"; } })(); exif['scene-capture-type'] = mm; } break; case 41991: { let gc = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "none"; break; case 1: return "low gain up"; break; case 2: return "high gain up"; break; case 3: return "low gain down"; break; case 4: return "high gain down"; break; default: return "???"; } })(); exif['gain-control'] = gc; } break; case 41992: { let mm = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "normal"; break; case 1: return "low"; break; case 2: return "hight"; break; default: return "???"; } })(); exif.contrast = mm; } break; case 41993: { let mm = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "normal"; break; case 1: return "low"; break; case 2: return "hight"; break; default: return "???"; } })(); exif.saturation = mm; } break; case 41994: { let mm = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "normal"; break; case 1: return "soft"; break; case 2: return "hard"; break; default: return "???"; } })(); exif.sharpness = mm; } break; case 41996: { let d = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "unkown"; break; case 1: return "macro"; break; case 2: return "close"; break; case 3: return "distant"; break; default: return "???"; } })(); exif['distance-subject-range'] = d; } break; case 42035: exif['lens-make'] = strncpy(valptr, bcount); break; case 42036: exif['lens-model'] = strncpy(valptr, bcount); break; case 42080: exif['composite-image'] = strncpy(valptr, bcount); break; case 50706:case 50707:'ignored';break; case 50708: exif['unique-camera-model'] = strncpy(valptr, bcount); break; case 50709: 'ignored'; break; case 50721:case 50722:case 50723:'ignored';break; case 50724: 'ignored'; break; case 50725: 'ignored'; break; case 50726: 'ignored'; break; case 50727: 'ignored'; break; case 50728: 'ignored'; break; case 50729: 'ignored'; break; case 50730: 'ignored'; break; case 50731: 'ignored'; break; case 50732: 'ignored'; break; case 50733: 'ignored'; break; case 50734: 'ignored'; break; case 50735: exif['camera-serial-number'] = strncpy(valptr, bcount); break; case 50739: 'ignored'; break; case 50740: 'ignored'; break; case 50741: 'ignored'; break; case 50778:case 50779:case 50780:'ignored';break; case 50781: 'ignored'; break; case 50931: 'ignored'; break; case 50932: 'ignored'; break; case 50934: 'ignored'; break; case 50935: 'ignored'; break; case 50936: 'ignored'; break; case 51041: 'ignored'; break; case 50937:case 50938:case 50939:case 50940:case 50941:'ignored';break; case 50942: 'ignored'; break; case 41730: 'ignored'; break; case 50964:case 50965:case 50966:case 50967:case 50968:case 50969:case 50970:'ignored';break; case 50971: 'ignored'; break; case 50981:case 50982:'ignored';break; case 51111: 'ignored'; break; default: 'unknown'; } }return loop((de + 1)); } })(0)); loop$ }if (((start + (2 + (4 + (12 * dnum)))) < bytes.length)) { let of = get32u(en, bytes, (start + (2 + (12 * dnum)))); if ((of > 0)) return processExifDir$(en, bytes, (of + base), base, exif, o0); } } }
)
const readJpegExif$ = ((exif, bytes, pos) => { let exifEndianess = (() => { if (bytes.substring(6, 6 + 2) === "II") return false; else if (bytes.substring(6, 6 + 2) === "MM") return true; else { warning("'read-jpeg-exif", "Unknown exif endianess, assuming big endian");return false; }
 }
);if ((bytes[4] === '\u0000') && (bytes[5] === '\u0000')) { let en = exifEndianess(), hd = get16u(en, bytes, 8); if (!(hd === 42)) return exifError("read-jpeg-exif", "Illegal exif header", hd); else { let fo = get32u(en, bytes, 10); if (((fo < 8)) || ((fo > 16))) return exifError("read-jpeg-exit", "Suspicious offset of first IFD value", fo); else processExifDir$(en, bytes, (6 + fo), 6, exif, pos);if ((typeof (exif.ewidth) === 'number') && (typeof (exif['focal-plane-xres']) === 'number') && (typeof (exif['focal-plane-units']) === 'number')) { let w = ((exif.ewidth * exif['focal-plane-units']) / exif['focal-plane-xres']); exif['cdd-width'] = w; }if ((Number.isInteger(exif['thumbnail-offset'])) && (Number.isInteger(exif['thumbnail-length']))) { let th = bytes.substring(exif['thumbnail-offset'], (exif['thumbnail-offset'] + exif['thumbnail-length'])); exif.thumbnail = th;return exif; } else return exif.thumbnail = false; } } }
)
const readCom$ = ((exif, bytes, pos) => { { let len = bytes.length; { const loop$ = ((function loop(i) { if (i === len) return exif.comment = bytes; else if (bytes[i] === '\u0000') { let s = bytes.substring(0, i); exif.comment = s;exif['%commentpos'] = pos;return exif['%commentlen'] = i; } else return loop((i + 1)); })(0)); return loop$; } } }
)
const readSofn$ = ((exif, bytes, encoding) => { exif.width = get16u(true, bytes, 3);exif.height = get16u(true, bytes, 1);exif['jpeg-encoding'] = encoding;return exif; }
)
const readJpegSection = ((mm, path) => { const loop$ = ((function loop(a, m) { if (m === '\u00ff') if ((a >= 6)) return exifError("read-jpeg-section", "Too many padding bytes", a); else return loop((a + 1), mm.get()); else { let lh = mm.get().charCodeAt(0), ll = mm.get().charCodeAt(0), l = ((lh << 8) | ll); if ((l < 2)) return exifError("read-jpeg-section", "Section too small", a); else if (((l + mm.rindex) > mm.length)) return exifError("read-jpeg-section", "Premature end of section read: ~s", ", expected: ~s"); else return [m.charCodeAt(0), mm.toString((l - 2))]; } })(0, mm.get())); return loop$; })
const readJpegSections = ((exif, mm, path) => { mm.rindex = 0;{ let m = readJpegMarker(mm); if (m !== 216) exifError("read-jpeg-sections", "Illegal section marker", (mm.rindex - 1)); else { const loop$ = ((function loop() { { let [m, bytes] = readJpegSection(mm, path); switch (m) { case 218: return 'sos'; break; case 217: return 'eoi'; break; case 254: readCom$(exif, bytes, mm.rindex - bytes.length);return loop(); break; case 224: return loop(); break; case 225: if (bytes.substring(0, 4) === "Exif") readJpegExif$(exif, bytes, mm.rindex - bytes.length);return loop(); break; case 192: readSofn$(exif, bytes, "baseline");return loop(); break; case 193: readSofn$(exif, bytes, "extended sequential");return loop(); break; case 194: readSofn$(exif, bytes, "progressive");return loop(); break; case 195: readSofn$(exif, bytes, "lossless");return loop(); break; case 197: readSofn$(exif, bytes, "differential sequential");return loop(); break; case 198: readSofn$(exif, bytes, "differential progressive");return loop(); break; case 199: readSofn$(exif, bytes, "differential lossless");return loop(); break; case 201: readSofn$(exif, bytes, "extended sequential, arithmetic coding");return loop(); break; case 202: readSofn$(exif, bytes, "progressive, arithmetic coding");return loop(); break; case 203: readSofn$(exif, bytes, "lossless, arithmetic coding");return loop(); break; case 204: readSofn$(exif, bytes, "differential sequential, arithmetic coding");return loop(); break; case 205: readSofn$(exif, bytes, "differential progressive, arithmetic coding");return loop(); break; case 206: readSofn$(exif, bytes, "differential lossless, arithmetic coding");return loop(); break; case 207: readSofn$(exif, bytes, "?");return loop(); break; default: return loop(); } } })()); loop$ } }return exif; }
)
const readTiffSections = ((exif, mm, path) => { let tiffEndianess = (() => { return mm.ref(0) === 'M'; }
);let strncpy = ((o, max) => { const loop$ = ((function loop(i) { if (i === max) return mmapSubstring(mm, o, (o + i)); else { let c = mm.ref((i + o)); if (c === '\u0000') return mmapSubstring(mm, o, (i + o)); else return loop((i + 1)); } })(0)); return loop$; });let readEntry = ((en, offset) => { { let tag = get16u(en, mm, (0 + offset)), typ = get16u(en, mm, (2 + offset)), cnt = get32u(en, mm, (4 + offset)), voff = get32u(en, mm, (8 + offset)); return console.error("tag=", tag, " ", fixnumtostring(tag, 16), " typ=", typ, " cnt=", cnt, " voff=", voff, " ", (typ === 2) ? (strncpy(voff, cnt)) : undefined); } }
);let readIfd = ((en, offset) => { return processExifDir$(en, mm, offset, 0, exif, 0); }
);{ let en = tiffEndianess(), offset = get32u(en, mm, 4); return readIfd(en, offset); } }
)
const readRw2Sections = ((exif, mm, path) => { let tiffEndianess = (() => { return mm.ref(0) === 'M'; }
);let strncpy = ((o, max) => { const loop$ = ((function loop(i) { if (i === max) return mmapSubstring(mm, o, (o + i)); else { let c = mm.ref((i + o)); if (c === '\u0000') return mmapSubstring(mm, o, (i + o)); else return loop((i + 1)); } })(0)); return loop$; });let readEntry = ((en, offset) => { { let tag = get16u(en, mm, (0 + offset)), typ = get16u(en, mm, (2 + offset)), cnt = get32u(en, mm, (4 + offset)), voff = get32u(en, mm, (8 + offset)); return console.error("tag=", tag, " 0x", fixnumtostring(tag, 16), " typ=", typ, " cnt=", cnt, " voff=", voff, " ", (typ === 2) ? (strncpy(voff, cnt)) : undefined); } }
);let readIfd = ((en, offset) => { { const loop$ = ((function loop(dnum, offset) { if ((dnum > 0)) { readEntry(en, offset);return loop((dnum - 1), (offset + 12)); }
 else { console.error("NEXT=", get32u(en, mm, offset));return console.error("OFFSET=", offset, " ", integertostring(offset, 16)); }
 })(get16u(en, mm, offset), (offset + 2))); loop$ }return processExifDir$(en, mm, offset, 0, exif, 0); }
);console.error("RW2 ", mm);{ let en = tiffEndianess(), offset = get32u(en, mm, 4); return readIfd(en, offset); } }
)
const tiffp = ((mm) => { let res = (() => { switch (mm.ref(0)) { case 'I':return (mm.get() === 'I') && (mm.get() === '*') && (mm.get() === '\u0000');break; case 'M':return (mm.get() === 'M') && (mm.get() === '\u0000') && (mm.get() === '*');break; default: return false; } })(); if (!res) mm.rindex = 0;return res; })
const rw2p = ((mm) => { return (mm.ref(0) === 'I') && (mm.get() === 'I') && (mm.get() === 'U') && (mm.get() === '\u0000') && (memqArray(mm.get(), ['', ''])) && (mm.get() === '\u0000') && (mm.get() === '\u0000') && (mm.get() === '\u0000'); }
)
const jpegExif = ((path) => { if (!(fs.existsSync(path))) return error_errno($errnoIoFileNotFoundError, "jpeg-exif", "Can't find file", path); else { let mm = new Mmap(path, 'write', false), exf = new exif({}); try { if ((mm.length > 0)) if (tiffp(mm)) readTiffSections(exf, mm, path); else if (rw2p(mm)) readTiffSections(exf, mm, path); else readJpegSections(exf, mm, path); } finally { mm.close() }return exf; } }
)
const jpegExifCommentSet$ = ((path, comment) => { if (!(fs.existsSync(path))) return error_errno($errnoIoFileNotFoundError, "jpeg-exif-comment-set!", "Can't find file", path); else { let mm = new Mmap(path), exf = new exif({}), mtime = false; try { if ((mm.length > 0)) { readJpegSections(exf, mm, path);return (exf['%commentpos']) && ((((len, s) => { mm.windex = exf['%commentpos'];mmapPutString$(mm, "ASCII\u0000\u0000\u0000");mmapPutString$(mm, s);mmapPutString$(mm, "\u0000");mtime = true;return s; })(comment.length, ((len < exf['%commentlen'])) ? (comment) : (comment.substring(0, exf['%commentlen']))))); }
 } finally { mm.close();if (mtime) { let pr = openInputFile(path), pw = appendOutputFile(path); { let c = readChar(pr); setOutputPortPosition$(pw, 0);writeChar(c, pw); }closeInputPort(pr);closeOutputPort(pw); } }
 } }
)
const jpegExifOrientationSet$ = ((path, orientation) => { if (!(fs.existsSync(path))) return error_errno($errnoIoFileNotFoundError, "jpeg-exif-comment-set!", "Can't find file", path); else { let mm = new Mmap(path), exf = new exif({}), mtime = false; try { if ((mm.length > 0)) { readJpegSections(exf, mm, path);if (exf['%orientationpos']) { mm.windex = exf['%orientationpos'];switch (orientation) { case 'landscape': mmapPutString$(mm, ""); break; case 'portrait': mmapPutString$(mm, ""); break; case 'upsidedonw': mmapPutString$(mm, ""); break; case 'seascape': mmapPutString$(mm, ""); break; }mtime = true;return orientation; }
 }
 } finally { mm.close();if (mtime) { let pr = openInputFile(path), pw = appendOutputFile(path); { let c = readChar(pr); setOutputPortPosition$(pw, 0);writeChar(c, pw); }closeInputPort(pr);closeOutputPort(pw); } }
 } }
)
const parseExifDate = ((d) => { let parseError = ((d, i) => { throw new $ioParseError({'proc': 'parse-exif-date','msg': "Illegal syntax",'obj': "~a{~a}~a"}); }
);let substringtoint = ((d, i, l) => { let len = (i + l), zero = '0'.charCodeAt(0); { const loop$ = ((function loop(i, acc) { if (i === len) return acc; else { let v = (d[i].charCodeAt(0) - zero); if (((v < 0)) || ((v > 9))) return parseError(d, i); else return loop((i + 1), (v + (acc * 10))); } })(i, 0)); return loop$; } });if ((d.length === 19) && (d[4] === ':') && (d[7] === ':') && (d[10] === ' ') && (d[13] === ':') && (d[16] === ':')) return makeDate({"sec": substringtoint(d, 17, 2), "min": substringtoint(d, 14, 2), "hour": substringtoint(d, 11, 2), "day": substringtoint(d, 8, 2), "month": substringtoint(d, 5, 2), "year": substringtoint(d, 0, 4)}); else return parseError(d, 0); }
)
