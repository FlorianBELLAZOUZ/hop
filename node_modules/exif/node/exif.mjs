/*=====================================================================*/
/*    .../project/hop/hop/node_modules/exif/node/exif-module.js        */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Tue Mar 26 07:54:31 2024                          */
/*    Last change :  Sun Apr  7 18:19:40 2024 (serrano)                */
/*    Copyright   :  2024 Manuel Serrano                               */
/*    -------------------------------------------------------------    */
/*    Exif parser (generated from bigloo:api/multimedia/Llib/exif.scm) */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    The module                                                       */
/*---------------------------------------------------------------------*/
import * as fs from "node:fs";
import { Mmap } from "./mmap.mjs";

/*---------------------------------------------------------------------*/
/*    errors                                                           */
/*---------------------------------------------------------------------*/
const $errnoIoFileNotFoundError = Error.ENOENT;
const $errnoIoParseError = -1;

/*---------------------------------------------------------------------*/
/*    error_errno ...                                                  */
/*---------------------------------------------------------------------*/
function error_errno(errno, proc, msg, obj) {
   const err = new Error(`${proc}: ${msg} -- ${obj}`);
   err.errno = errno;
   throw err;
}

/*---------------------------------------------------------------------*/
/*    $ioParseError ...                                                */
/*---------------------------------------------------------------------*/
function $ioParseError({proc, msg, obj}) {
   throw new Error(`${proc}: ${msg} -- ${obj}`);
}

/*---------------------------------------------------------------------*/
/*    warning ...                                                      */
/*---------------------------------------------------------------------*/
function warning(...vals) {
   console.log.apply(console, vals);
}

/*---------------------------------------------------------------------*/
/*    makeDate ...                                                     */
/*---------------------------------------------------------------------*/
function makeDate({sec, min, hour, day, month, year}) {
   return new Date(year, month - 1, day, hour, min, sec);
}

/*---------------------------------------------------------------------*/
/*    cons ...                                                         */
/*---------------------------------------------------------------------*/
function cons(a, d) {
   return [a, d];
}

/*---------------------------------------------------------------------*/
/*    pairp ...                                                        */
/*---------------------------------------------------------------------*/
function pairp(o) {
   Array.isArray(o) && o.length === 2;
}

/*---------------------------------------------------------------------*/
/*    car ...                                                          */
/*---------------------------------------------------------------------*/
function car(o) {
   return o[0];
}

/*---------------------------------------------------------------------*/
/*    cdr ...                                                          */
/*---------------------------------------------------------------------*/
function cdr(o) {
   return o[1];
}

/*---------------------------------------------------------------------*/
/*    stringShrink$ ...                                                */
/*---------------------------------------------------------------------*/
function stringShrink$(s, len) {
   return s.substring(0, len);
}

/*---------------------------------------------------------------------*/
/*    Exif ...                                                         */
/*---------------------------------------------------------------------*/
export function Exif(file) {
   return jpegExif(file);
}

Exif.prototype = exif.prototype;
// generated by /home/serrano/prgm/project/hop/hop/node_modules/exif/node/mkjast.scm

export function exif(props) {
   this.version = false;
   this.jpegEncoding = false;
   this.jpegCompress = false;
   this.software = false;
   this.comment = false;
   Object.defineProperty(this, "$commentpos", { value: false, enumerable: false, writable: true, configurable: false });
   Object.defineProperty(this, "$commentlen", { value: false, enumerable: false, writable: true, configurable: false });
   this.description = false;
   this.date = false;
   this.offsetTime = false;
   this.offsetTimeOriginal = false;
   this.offsetTimeDigitized = false;
   this.make = false;
   this.model = false;
   this.uniqueCameraModel = false;
   this.cameraSerialNumber = false;
   this.orientation = 'landscape';
   Object.defineProperty(this, "$orientationpos", { value: false, enumerable: false, writable: true, configurable: false });
   this.width = false;
   this.height = false;
   this.iwidth = false;
   this.ilength = false;
   this.ewidth = false;
   this.eheight = false;
   this.xresolution = false;
   this.yresolution = false;
   this.resolutionUnit = false;
   this.focalLength = false;
   this.focalLength35 = false;
   this.customRender = false;
   this.exposureMode = false;
   this.whiteBalance = false;
   this.digitalZoomRatio = false;
   this.lightSource = false;
   this.flash = false;
   this.fnumber = false;
   this.iso = false;
   this.shutterSpeedValue = false;
   this.exposureProgram = false;
   this.exposureTime = false;
   this.exposureBiasValue = false;
   this.aperture = false;
   this.maxAperture = false;
   this.meteringMode = false;
   this.cddWidth = false;
   this.focalPlaneXres = false;
   this.focalPlaneYres = false;
   this.focalPlaneUnits = false;
   this.brightnessValue = false;
   this.subjectDistance = false;
   this.colorspace = false;
   this.sensingMethod = false;
   this.compositeImage = false;
   this.lensMake = false;
   this.lensModel = false;
   this.digitalZoomRatio = false;
   this.sceneCaptureType = "???";
   this.gainControl = "???";
   this.contrast = "???";
   this.saturation = "???";
   this.sharpness = "???";
   this.distanceSubjectRange = false;
   this.newSubfileType = false;
   this.YCbCrCoef = false;
   this.YCbCrSubsampling = false;
   this.YCbCrPositioning = false;
   this.refere = false;
   this.rating = false;
   this.ratingPercentage = false;
   this.copyright = false;
   this.artist = false;
   this.makerNote = false;
   this.thumbnail = false;
   Object.defineProperty(this, "$thunmnailPath", { value: false, enumerable: false, writable: true, configurable: false });
   Object.defineProperty(this, "$thunmnailOffset", { value: false, enumerable: false, writable: true, configurable: false });
   Object.defineProperty(this, "$thunmnailLength", { value: false, enumerable: false, writable: true, configurable: false });
   this.endianess = false;
   Object.defineProperty(this, "$gpsTag", { value: false, enumerable: false, writable: true, configurable: false });
   Object.defineProperty(this, "$gpsLatitudeRef", { value: false, enumerable: false, writable: true, configurable: false });
   this.gpsLatitude = false;
   this.gpsLongitude = false;
   Object.defineProperty(this, "$gpsLongitudeRef", { value: false, enumerable: false, writable: true, configurable: false });
   this.gpsAltitude = false;
   Object.defineProperty(this, "$gpsAltitudeRef", { value: false, enumerable: false, writable: true, configurable: false });
   this.gpsSatelites = false;
   this.gpsMeasureMode = false;
   this.gpsStatus = false;
   this.gpsTimeStamp = false;
   this.gpsDateStamp = false;
   this.$class = 'exif';
   Object.assign(this, props);
}
exif.prototype.duplicate = function(props) {
   const o = new exif({});
   Object.assign(o, this);
   Object.assign(o, props);
   return o;
}

// generated by hop2js
export {jpegExif, jpegExifCommentSet$, jpegExifOrientationSet$, parseExifDate}
const exifError = ((proc, msg, obj) => { return error_errno($errnoIoParseError, proc, msg, obj); }
)
const get16u = ((en, bytes, o) => { let stringGet16U = ((en, bytes, o) => { return (en) ? (((bytes[o].charCodeAt(0) << 8) | bytes[(1 + o)].charCodeAt(0))) : (((bytes[(1 + o)].charCodeAt(0) << 8) | bytes[o].charCodeAt(0))); }
);let mmapGet16U = ((en, bytes, o) => { return (en) ? (((bytes.ref(o).charCodeAt(0) << 8) | bytes.ref((1 + o)).charCodeAt(0))) : (((bytes.ref((1 + o)).charCodeAt(0) << 8) | bytes.ref(o).charCodeAt(0))); }
);if (typeof(bytes) === 'string') return stringGet16U(en, bytes, o); else return mmapGet16U(en, bytes, o); }
)
const get32u = ((en, bytes, o) => { let stringGet32U = ((en, bytes, o) => { let e0 = bytes[o].charCodeAt(0), e1 = bytes[(1 + o)].charCodeAt(0), e2 = bytes[(2 + o)].charCodeAt(0), e3 = bytes[(3 + o)].charCodeAt(0); if (en) return ((e0 << 24) | ((e1 << 16) | ((e2 << 8) | e3))); else return ((e3 << 24) | ((e2 << 16) | ((e1 << 8) | e0))); });let mmapGet32U = ((en, bytes, o) => { let e0 = bytes.ref(o).charCodeAt(0), e1 = bytes.ref((1 + o)).charCodeAt(0), e2 = bytes.ref((2 + o)).charCodeAt(0), e3 = bytes.ref((3 + o)).charCodeAt(0); if (en) return ((e0 << 24) | ((e1 << 16) | ((e2 << 8) | e3))); else return ((e3 << 24) | ((e2 << 16) | ((e1 << 8) | e0))); });if (typeof(bytes) === 'string') return stringGet32U(en, bytes, o); else return mmapGet32U(en, bytes, o); }
)
const getformat = ((en, bytes, o, fmt) => { switch (fmt) { case 1:case 6:return (typeof(bytes) === 'string') ? (bytes[o]) : (bytes.ref(o)).charCodeAt(0);break; case 3:case 8:return get16u(en, bytes, o);break; case 4:case 9:return get32u(en, bytes, o);break; case 5:case 10:{ let num = get32u(en, bytes, o), den = get32u(en, bytes, (o + 4)); return cons(num, den); }break; case 11: return exifError("exif", "Unsupported number format", fmt); break; case 12: return exifError("exif", "Unsupported number format", fmt); break; default: console.error("unknown format ", fmt);return 0; } }
)
const getformat_fx = ((en, bytes, o, fmt) => { let res = getformat(en, bytes, o, fmt); if (Number.isInteger(res)) return res; else if (Number.isInteger(res)) return res; else return 0; })
const getformatRat3 = ((en, bytes, valptr, fmt) => { { let sz = _exifFormatsSize_[fmt], r0 = getformat(en, bytes, valptr, fmt), r1 = getformat(en, bytes, (valptr + sz), fmt), r2 = getformat(en, bytes, (valptr + (sz + sz)), fmt); return ((car(r0) / cdr(r0)) + ((car(r1) / (60.0 * cdr(r1))) + (car(r2) / (3600.0 * cdr(r2))))); } }
)
let _exifFormatsSize_ = ['_', 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8]
const readJpegMarker = ((p) => { if (!(p.get() === '\u00ff')) return false; else return p.get().charCodeAt(0); }
)
const removeTrailingSpaces$ = ((s) => { let len = s.length; if (len === 0) return s; else { let start = (len - 1); { const loop$ = ((function loop(i) { if (s[i] === ' ') return loop((i - 1)); else if (i === 0) return ""; else if (i === start) return s; else return stringShrink$(s, (i + 1)); })(start)); return loop$; } } })
const processExifDir$ = ((en, bytes, start, base, exif, o0, tagBase) => { let strncpy = ((o, max) => { let stringStrncpy = ((o, max) => { const loop$ = ((function loop(i) { if (i === max) return bytes.substring(o, (o + i)); else { let c = bytes[(i + o)]; if (c === '\u0000') return bytes.substring(o, (o + i)); else return loop((i + 1)); } })(0)); return loop$; });let mmapStrncpy = ((o, max) => { const loop$ = ((function loop(i) { if (i === max) return mmapSubstring(bytes, o, (o + i)); else { let c = bytes.ref((i + o)); if (c === '\u0000') return mmapSubstring(bytes, o, (i + o)); else return loop((i + 1)); } })(0)); return loop$; });if (typeof(bytes) === 'string') return stringStrncpy(o, max); else return mmapStrncpy(o, max); }
);{ let dnum = get16u(en, bytes, start); { const loop$ = ((function loop(de) { if ((de < dnum)) { let da = (start + (2 + (12 * de))), tag = get16u(en, bytes, da), fmt = get16u(en, bytes, (2 + da)), cmp = get32u(en, bytes, (4 + da)); { let bcount = (cmp * _exifFormatsSize_[fmt]), valptr = ((bcount > 4)) ? ((((ov) => { return (base + ov); })(get32u(en, bytes, (8 + da))))) : ((8 + da)); switch ((tag + tagBase)) { case 1: undefined; break; case 65537: { let obj1004 = exif; obj1004['$gpsLatitudeRef'] = strncpy(valptr, bcount); } break; case 65538: { let obj1005 = exif; obj1005.gpsLatitude = getformatRat3(en, bytes, valptr, fmt); } break; case 65539: { let obj1006 = exif; obj1006['$gpsLongitudeRef'] = strncpy(valptr, bcount); } break; case 65540: { let obj1007 = exif; obj1007.gpsLongitude = getformatRat3(en, bytes, valptr, fmt); } break; case 65541: { let obj1008 = exif; obj1008['$gpsAltitudeRef'] = getformat_fx(en, bytes, valptr, fmt); } break; case 65542: { let obj1009 = exif; obj1009.gpsAltitude = getformat(en, bytes, valptr, fmt); } break; case 65543: { let obj1010 = exif; obj1010.gpsTimeStamp = getformatRat3(en, bytes, valptr, fmt); } break; case 65544: { let obj1011 = exif; obj1011.gpsSatelites = strncpy(valptr, bcount); } break; case 65545: { let obj1012 = exif; obj1012.gpsStatus = strncpy(valptr, bcount); } break; case 65546: { let obj1013 = exif; obj1013.gpsMeasureMode = strncpy(valptr, bcount); } break; case 65563:case 65564:undefined;break; case 65565: { let obj1014 = exif; obj1014.gpsDateStamp = strncpy(valptr, bcount); } break; case 65547: undefined; break; case 65548: undefined; break; case 65549: undefined; break; case 65550: undefined; break; case 65551: undefined; break; case 65552: undefined; break; case 65553: undefined; break; case 254: { let s = getformat_fx(en, bytes, valptr, fmt); { let obj1015 = exif; obj1015.newSubfileType = s; } } break; case 256: { let w = getformat_fx(en, bytes, valptr, fmt); { let obj1016 = exif; obj1016.iwidth = w; } } break; case 257: { let l = getformat_fx(en, bytes, valptr, fmt); { let obj1017 = exif; obj1017.ilength = l; } } break; case 258: 'todo'; break; case 259: { let c = getformat(en, bytes, valptr, fmt); { let obj1018 = exif; obj1018.jpegCompress = c; } } break; case 262: { let c = getformat(en, bytes, valptr, fmt); { let obj1019 = exif; obj1019.jpegCompress = c; } } break; case 270: { let obj1020 = exif; obj1020.description = strncpy(valptr, bcount); } break; case 271: { let obj1021 = exif; obj1021.make = strncpy(valptr, 31); } break; case 272: { let obj1022 = exif; obj1022.model = strncpy(valptr, 39); } break; case 273: 'todo'; break; case 274: { let o = getformat(en, bytes, valptr, fmt); { let obj1023 = exif; obj1023.orientation = (() => { switch (o) { case 1: return 'landscape'; break; case 6: return 'portrait'; break; case 8: return 'upsidedown'; break; default: return 'seascape'; } })(); } } break; case 277: 'todo'; break; case 278: 'todo'; break; case 279: 'todo'; break; case 282: { let xr = getformat(en, bytes, valptr, fmt); { let obj1024 = exif; obj1024.xresolution = xr; } } break; case 283: { let yr = getformat(en, bytes, valptr, fmt); { let obj1025 = exif; obj1025.yresolution = yr; } } break; case 284: 'todo'; break; case 296: { let ru = getformat(en, bytes, valptr, fmt); { let obj1026 = exif; obj1026.resolutionUnit = ru; } } break; case 305: { let obj1027 = exif; obj1027.software = strncpy(valptr, bcount); } break; case 306: { let dt = strncpy(valptr, 31); { let obj1028 = exif; obj1028.date = parseExifDate(dt); } } break; case 315: { let obj1029 = exif; obj1029.artist = strncpy(valptr, bcount); } break; case 330: 'ignored'; break; case 513: { let ol = getformat_fx(en, bytes, valptr, fmt), of = (ol + base); { let obj1030 = exif; obj1030['$thunmnailOffset'] = of; } } break; case 514: { let le = getformat_fx(en, bytes, valptr, fmt); { let obj1031 = exif; obj1031['$thunmnailLength'] = le; } } break; case 515: 'todo'; break; case 517: 'todo'; break; case 518: 'todo'; break; case 519: 'todo'; break; case 520: 'todo'; break; case 520: 'todo'; break; case 529: { let co = getformat(en, bytes, valptr, fmt); { let obj1032 = exif; obj1032.YCbCrCoef = co; } } break; case 530: { let ss = getformat_fx(en, bytes, valptr, fmt); { let obj1033 = exif; obj1033.YCbCrSubsampling = ss; } } break; case 531: { let pos = getformat_fx(en, bytes, valptr, fmt); { let obj1034 = exif; obj1034.YCbCrPositioning = pos; } } break; case 532: { let ref = getformat(en, bytes, valptr, fmt); { let obj1035 = exif; obj1035.refere = ref; } } break; case 18246: { let ra = getformat(en, bytes, valptr, fmt); { let obj1036 = exif; obj1036.rating = ra; } } break; case 18249: { let ra = getformat(en, bytes, valptr, fmt); { let obj1037 = exif; obj1037.ratingPercentage = ra; } } break; case 33432: { let obj1038 = exif; obj1038.copyright = strncpy(valptr, bcount); } break; case 33434: { let et = getformat(en, bytes, valptr, fmt); { let obj1039 = exif; obj1039.exposureTime = et; } } break; case 33437: { let fn = getformat(en, bytes, valptr, fmt); { let obj1040 = exif; obj1040.fnumber = fn; } } break; case 34665: { let ss = (base + get32u(en, bytes, valptr)); processExifDir$(en, bytes, ss, base, exif, o0, 0); } break; case 34850: { let e = getformat(en, bytes, valptr, fmt); { let obj1041 = exif; obj1041.exposureProgram = e; } } break; case 34853: { let t = getformat_fx(en, bytes, valptr, fmt); { let obj1042 = exif; obj1042['$gpsTag'] = t; } } break; case 34855: { let is = getformat(en, bytes, valptr, fmt); { let obj1043 = exif; obj1043.iso = is; } } break; case 36864: 'todo'; break; case 36867:case 36868:{ let obj1044 = exif; obj1044.date = parseExifDate(strncpy(valptr, 19)); }break; case 36880: { let obj1045 = exif; obj1045.offsetTime = strncpy(valptr, bcount); } break; case 36881: { let obj1046 = exif; obj1046.offsetTimeOriginal = strncpy(valptr, bcount); } break; case 36882: { let obj1047 = exif; obj1047.offsetTimeDigitized = strncpy(valptr, bcount); } break; case 37121: undefined; break; case 37122: undefined; break; case 37377: { let sv = getformat(en, bytes, valptr, fmt); { let obj1048 = exif; obj1048.shutterSpeedValue = sv; } } break; case 37379: { let bv = getformat(en, bytes, valptr, fmt); { let obj1049 = exif; obj1049.brightnessValue = bv; } } break; case 37378: { let ap = getformat(en, bytes, valptr, fmt); { let obj1050 = exif; obj1050.aperture = ap; } } break; case 37380: { let bv = getformat(en, bytes, valptr, fmt); { let obj1051 = exif; obj1051.exposureBiasValue = bv; } } break; case 37381: { let ap = getformat(en, bytes, valptr, fmt); { let obj1052 = exif; obj1052.maxAperture = ap; } } break; case 37382: { let sd = getformat(en, bytes, valptr, fmt); { let obj1053 = exif; obj1053.subjectDistance = sd; } } break; case 37383: { let mm = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 2: return "center weight"; break; case 3: return "spot"; break; case 5: return "matrix"; break; default: return "???"; } })(); { let obj1054 = exif; obj1054.meteringMode = mm; } } break; case 37384: { let fl = getformat_fx(en, bytes, valptr, fmt), f = !((fl & 7) === 0); { let obj1055 = exif; obj1055.lightSource = f; } } break; case 37385: { let fl = getformat_fx(en, bytes, valptr, fmt), f = !((fl & 7) === 0); { let obj1056 = exif; obj1056.flash = f; } } break; case 37386: { let fl = getformat(en, bytes, valptr, fmt); { let obj1057 = exif; obj1057.focalLength = fl; } } break; case 37510: { let obj1058 = exif; obj1058['$commentpos'] = (valptr + o0);obj1058['$commentlen'] = 199;if (bytes.substring(valptr, valptr + 8) === "ASCII\u0000\u0000\u0000") obj1058.comment = removeTrailingSpaces$(strncpy((8 + valptr), 191)); } break; case 37500: { let obj1059 = exif; strncpy(valptr, bcount); } break; case 37520: undefined; break; case 37521: undefined; break; case 37522: undefined; break; case 40960: undefined; break; case 40961: { let cs = getformat_fx(en, bytes, valptr, fmt); { let obj1060 = exif; obj1060.colorspace = cs; } } break; case 40962: { let w = getformat_fx(en, bytes, valptr, fmt); { let obj1061 = exif; obj1061.ewidth = w; } } break; case 40963: { let w = getformat_fx(en, bytes, valptr, fmt); { let obj1062 = exif; obj1062.eheight = w; } } break; case 40965: undefined; break; case 41486: { let r = getformat(en, bytes, valptr, fmt); { let obj1063 = exif; obj1063.focalPlaneXres = (pairp(r)) ? ((car(r) / cdr(r))) : (r); } } break; case 41487: { let r = getformat(en, bytes, valptr, fmt); { let obj1064 = exif; obj1064.focalPlaneYres = (pairp(r)) ? ((car(r) / cdr(r))) : (r); } } break; case 41488: { let fpu = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 1: return 25.4; break; case 2: return 25.4; break; case 3: return 10; break; case 4: return 1; break; case 5: return 0.001; break; } })(); { let obj1065 = exif; obj1065.focalPlaneUnits = fpu; } } break; case 41495: { let sm = getformat(en, bytes, valptr, fmt); { let obj1066 = exif; obj1066.sensingMethod = sm; } } break; case 41728: undefined; break; case 41729: undefined; break; case 41985: { let cr = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "normal"; break; case 1: return "custom"; break; case 2: return "HDR (no original saved)"; break; case 3: return "HDR (original saved)"; break; case 4: return "original (for HDR)"; break; case 6: return "panorama"; break; case 7: return "portrait HDR"; break; case 8: return "portraitauto"; break; default: return "???"; } })(); { let obj1067 = exif; obj1067.customRender = cr; } } break; case 41986: { let em = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "auto"; break; case 1: return "manual"; break; case 1: return "auto bracket"; break; default: return "???"; } })(); { let obj1068 = exif; obj1068.exposureMode = em; } } break; case 41987: { let wb = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "auto"; break; case 1: return "manual"; break; default: return "???"; } })(); { let obj1069 = exif; obj1069.whiteBalance = wb; } } break; case 41988: { let dz = getformat(en, bytes, valptr, fmt); { let obj1070 = exif; obj1070.digitalZoomRatio = dz; } } break; case 41989: { let fl = getformat(en, bytes, valptr, fmt); { let obj1071 = exif; obj1071.focalLength35 = fl; } } break; case 41990: { let mm = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "standard"; break; case 1: return "landscape"; break; case 2: return "portrait"; break; case 3: return "night"; break; case 3: return "other"; break; default: return "???"; } })(); { let obj1072 = exif; obj1072.sceneCaptureType = mm; } } break; case 41991: { let gc = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "none"; break; case 1: return "low gain up"; break; case 2: return "high gain up"; break; case 3: return "low gain down"; break; case 4: return "high gain down"; break; default: return "???"; } })(); { let obj1073 = exif; obj1073.gainControl = gc; } } break; case 41992: { let mm = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "normal"; break; case 1: return "low"; break; case 2: return "hight"; break; default: return "???"; } })(); { let obj1074 = exif; obj1074.contrast = mm; } } break; case 41993: { let mm = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "normal"; break; case 1: return "low"; break; case 2: return "hight"; break; default: return "???"; } })(); { let obj1075 = exif; obj1075.saturation = mm; } } break; case 41994: { let mm = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "normal"; break; case 1: return "soft"; break; case 2: return "hard"; break; default: return "???"; } })(); { let obj1076 = exif; obj1076.sharpness = mm; } } break; case 41996: { let d = (() => { switch (getformat_fx(en, bytes, valptr, fmt)) { case 0: return "unkown"; break; case 1: return "macro"; break; case 2: return "close"; break; case 3: return "distant"; break; default: return "???"; } })(); { let obj1077 = exif; obj1077.distanceSubjectRange = d; } } break; case 42035: { let obj1078 = exif; obj1078.lensMake = strncpy(valptr, bcount); } break; case 42036: { let obj1079 = exif; obj1079.lensModel = strncpy(valptr, bcount); } break; case 42080: { let obj1080 = exif; obj1080.compositeImage = strncpy(valptr, bcount); } break; case 50706:case 50707:'ignored';break; case 50708: { let obj1081 = exif; obj1081.uniqueCameraModel = strncpy(valptr, bcount); } break; case 50709: 'ignored'; break; case 50721:case 50722:case 50723:'ignored';break; case 50724: 'ignored'; break; case 50725: 'ignored'; break; case 50726: 'ignored'; break; case 50727: 'ignored'; break; case 50728: 'ignored'; break; case 50729: 'ignored'; break; case 50730: 'ignored'; break; case 50731: 'ignored'; break; case 50732: 'ignored'; break; case 50733: 'ignored'; break; case 50734: 'ignored'; break; case 50735: { let obj1082 = exif; obj1082.cameraSerialNumber = strncpy(valptr, bcount); } break; case 50739: 'ignored'; break; case 50740: 'ignored'; break; case 50741: 'ignored'; break; case 50778:case 50779:case 50780:'ignored';break; case 50781: 'ignored'; break; case 50931: 'ignored'; break; case 50932: 'ignored'; break; case 50934: 'ignored'; break; case 50935: 'ignored'; break; case 50936: 'ignored'; break; case 51041: 'ignored'; break; case 50937:case 50938:case 50939:case 50940:case 50941:'ignored';break; case 50942: 'ignored'; break; case 41730: 'ignored'; break; case 50964:case 50965:case 50966:case 50967:case 50968:case 50969:case 50970:'ignored';break; case 50971: 'ignored'; break; case 50981:case 50982:'ignored';break; case 51111: 'ignored'; break; default: 'unknown'; } }return loop((de + 1)); } })(0)); loop$ }if (((start + (2 + (4 + (12 * dnum)))) < bytes.length)) { let of = get32u(en, bytes, (start + (2 + (12 * dnum)))); if ((of > 0)) return processExifDir$(en, bytes, (of + base), base, exif, o0, 0); } } }
)
const readJpegExif$ = ((exif, bytes, pos) => { let exifEndianess = (() => { if (bytes.substring(6, 6 + 2) === "II") return false; else if (bytes.substring(6, 6 + 2) === "MM") return true; else { warning("'read-jpeg-exif", "Unknown exif endianess, assuming big endian");return false; }
 }
);if ((bytes[4] === '\u0000') && (bytes[5] === '\u0000')) { let en = exifEndianess(), hd = get16u(en, bytes, 8); if (!(hd === 42)) return exifError("read-jpeg-exif", "Illegal exif header", hd); else { let fo = get32u(en, bytes, 10); if (((fo < 8)) || ((fo > 16))) return exifError("read-jpeg-exit", "Suspicious offset of first IFD value", fo); else { let obj1083 = exif; obj1083.endianess = en;processExifDir$(en, bytes, (6 + fo), 6, exif, pos, 0);if ((typeof (obj1083.ewidth) === 'number') && (typeof (obj1083.focalPlaneXres) === 'number') && (typeof (obj1083.focalPlaneUnits) === 'number')) { let w = ((obj1083.ewidth * obj1083.focalPlaneUnits) / obj1083.focalPlaneXres); obj1083.cddWidth = w; }if ((Number.isInteger(obj1083['$thunmnailOffset'])) && (Number.isInteger(obj1083['$thunmnailLength']))) { let th = Buffer.from(bytes.substring(obj1083['$thunmnailOffset'], (obj1083['$thunmnailOffset'] + obj1083['$thunmnailLength'])), "binary"); obj1083.thumbnail = th;return exif; } else return obj1083.thumbnail = false; } } } }
)
const readCom$ = ((exif, bytes, pos) => { { let obj1084 = exif; { let len = bytes.length; { const loop$ = ((function loop(i) { if (i === len) return obj1084.comment = bytes; else if (bytes[i] === '\u0000') { let s = bytes.substring(0, i); obj1084.comment = s;obj1084['$commentpos'] = pos;return obj1084['$commentlen'] = i; } else return loop((i + 1)); })(0)); return loop$; } } } }
)
const readSofn$ = ((exif, bytes, encoding) => { { let obj1085 = exif; obj1085.width = get16u(true, bytes, 3);obj1085.height = get16u(true, bytes, 1);obj1085.jpegEncoding = encoding; }return exif; }
)
const readJpegSection = ((mm, path) => { const loop$ = ((function loop(a, m) { if (m === '\u00ff') if ((a >= 6)) return exifError("read-jpeg-section", "Too many padding bytes", a); else return loop((a + 1), mm.get()); else { let lh = mm.get().charCodeAt(0), ll = mm.get().charCodeAt(0), l = ((lh << 8) | ll); if ((l < 2)) return exifError("read-jpeg-section", "Section too small", a); else if (((l + mm.rindex) > mm.length)) return exifError("read-jpeg-section", "Premature end of section read: "+(mm.length - mm.rindex), ", expected: "+l - 2); else { let offset = mm.rindex; return [m.charCodeAt(0), mm.toString((l - 2)), offset]; } } })(0, mm.get())); return loop$; })
const readJpegSections = ((exif, mm, path) => { mm.rindex = 0;{ let m = readJpegMarker(mm); if (m !== 216) exifError("read-jpeg-sections", "Illegal section marker", (mm.rindex - 1)); else { const loop$ = ((function loop() { { let [m, bytes, offset] = readJpegSection(mm, path); switch (m) { case 218: return 'sos'; break; case 217: return 'eoi'; break; case 254: readCom$(exif, bytes, mm.rindex - bytes.length);return loop(); break; case 224: return loop(); break; case 225: if (bytes.substring(0, 6) === "Exif\u0000\u0000") { let obj1086 = exif; readJpegExif$(exif, bytes, mm.rindex - bytes.length);if (obj1086['$gpsTag']) { processExifDir$(obj1086.endianess, bytes, (obj1086['$gpsTag'] + 6), 6, exif, 0, 65536);{ let obj1087 = exif; if (obj1087['$gpsAltitudeRef'] === 1) setCar$(obj1087.gpsAltitude, - car(obj1087.gpsAltitude));if (obj1087['$gpsLatitudeRef'] == "S") obj1087.gpsLatitude = -obj1087.gpsLatitude;if (obj1087['$gpsLongitudeRef'] == "W") obj1087.gpsLongitude = -obj1087.gpsLongitude; } }
 }return loop(); break; case 192: readSofn$(exif, bytes, "baseline");return loop(); break; case 193: readSofn$(exif, bytes, "extended sequential");return loop(); break; case 194: readSofn$(exif, bytes, "progressive");return loop(); break; case 195: readSofn$(exif, bytes, "lossless");return loop(); break; case 197: readSofn$(exif, bytes, "differential sequential");return loop(); break; case 198: readSofn$(exif, bytes, "differential progressive");return loop(); break; case 199: readSofn$(exif, bytes, "differential lossless");return loop(); break; case 201: readSofn$(exif, bytes, "extended sequential, arithmetic coding");return loop(); break; case 202: readSofn$(exif, bytes, "progressive, arithmetic coding");return loop(); break; case 203: readSofn$(exif, bytes, "lossless, arithmetic coding");return loop(); break; case 204: readSofn$(exif, bytes, "differential sequential, arithmetic coding");return loop(); break; case 205: readSofn$(exif, bytes, "differential progressive, arithmetic coding");return loop(); break; case 206: readSofn$(exif, bytes, "differential lossless, arithmetic coding");return loop(); break; case 207: readSofn$(exif, bytes, "?");return loop(); break; default: return loop(); } } })()); loop$ } }return exif; }
)
const readTiffSections = ((exif, mm, path) => { let tiffEndianess = (() => { return mm.ref(0) === 'M'; }
);let strncpy = ((o, max) => { const loop$ = ((function loop(i) { if (i === max) return mmapSubstring(mm, o, (o + i)); else { let c = mm.ref((i + o)); if (c === '\u0000') return mmapSubstring(mm, o, (i + o)); else return loop((i + 1)); } })(0)); return loop$; });let readIfd = ((en, offset) => { return processExifDir$(en, mm, offset, 0, exif, 0, 0); }
);{ let en = tiffEndianess(), offset = get32u(en, mm, 4); return readIfd(en, offset); } }
)
const readRw2Sections = ((exif, mm, path) => { let tiffEndianess = (() => { return mm.ref(0) === 'M'; }
);let strncpy = ((o, max) => { const loop$ = ((function loop(i) { if (i === max) return mmapSubstring(mm, o, (o + i)); else { let c = mm.ref((i + o)); if (c === '\u0000') return mmapSubstring(mm, o, (i + o)); else return loop((i + 1)); } })(0)); return loop$; });let readEntry = ((en, offset) => { { let tag = get16u(en, mm, (0 + offset)), typ = get16u(en, mm, (2 + offset)), cnt = get32u(en, mm, (4 + offset)), voff = get32u(en, mm, (8 + offset)); return console.error("tag=", tag, " 0x", fixnumtostring(tag, 16), " typ=", typ, " cnt=", cnt, " voff=", voff, " ", (typ === 2) ? (strncpy(voff, cnt)) : undefined); } }
);let readIfd = ((en, offset) => { { const loop$ = ((function loop(dnum, offset) { if ((dnum > 0)) { readEntry(en, offset);return loop((dnum - 1), (offset + 12)); }
 else { console.error("NEXT=", get32u(en, mm, offset));return console.error("OFFSET=", offset, " ", integertostring(offset, 16)); }
 })(get16u(en, mm, offset), (offset + 2))); loop$ }return processExifDir$(en, mm, offset, 0, exif, 0, 0); }
);console.error("RW2 ", mm);{ let en = tiffEndianess(), offset = get32u(en, mm, 4); return readIfd(en, offset); } }
)
const tiffp = ((mm) => { let res = (() => { switch (mm.ref(0)) { case "I":console.error("tiff 73");return (mm.get() === 'I') && (mm.get() === '*') && (mm.get() === '\u0000');break; case "M":console.error("tiff 77");return (mm.get() === 'M') && (mm.get() === '\u0000') && (mm.get() === '*');break; default: return false; } })(); if (!res) mm.rindex = 0;return res; })
const rw2p = ((mm) => { let res = (mm.ref(0) === 'I') && (mm.get() === 'I') && (mm.get() === 'U') && (mm.get() === '\u0000') && (memqArray(mm.get(), ['', ''])) && (mm.get() === '\u0000') && (mm.get() === '\u0000') && (mm.get() === '\u0000'); if (!res) mm.rindex = 0;return res; })
const jpegExif = ((path) => { if (!(fs.existsSync(path))) return error_errno($errnoIoFileNotFoundError, "jpeg-exif", "Can't find file", path); else { let mm = new Mmap(path, 'write', false), exf = new exif({}); try { if ((mm.length > 0)) if (tiffp(mm)) readTiffSections(exf, mm, path); else if (rw2p(mm)) readTiffSections(exf, mm, path); else readJpegSections(exf, mm, path); } finally { mm.close() }return exf; } }
)
const jpegExifCommentSet$ = ((path, comment) => { if (!(fs.existsSync(path))) return error_errno($errnoIoFileNotFoundError, "jpeg-exif-comment-set!", "Can't find file", path); else { let mm = new Mmap(path), exf = new exif({}), mtime = false; try { if ((mm.length > 0)) { readJpegSections(exf, mm, path);{ let obj1088 = exf; return (obj1088['$commentpos']) && ((((len, s) => { mm.windex = obj1088['$commentpos'];mmapPutString$(mm, "ASCII\u0000\u0000\u0000");mmapPutString$(mm, s);mmapPutString$(mm, "\u0000");mtime = true;return s; })(comment.length, ((len < obj1088['$commentlen'])) ? (comment) : (comment.substring(0, obj1088['$commentlen']))))); } }
 } finally { mm.close();if (mtime) { let pr = openInputFile(path), pw = appendOutputFile(path); { let c = readChar(pr); setOutputPortPosition$(pw, 0);writeChar(c, pw); }closeInputPort(pr);closeOutputPort(pw); } }
 } }
)
const jpegExifOrientationSet$ = ((path, orientation) => { if (!(fs.existsSync(path))) return error_errno($errnoIoFileNotFoundError, "jpeg-exif-comment-set!", "Can't find file", path); else { let mm = new Mmap(path), exf = new exif({}), mtime = false; try { if ((mm.length > 0)) { readJpegSections(exf, mm, path);{ let obj1089 = exf; if (obj1089['$orientationpos']) { mm.windex = obj1089['$orientationpos'];switch (orientation) { case 'landscape': mmapPutString$(mm, ""); break; case 'portrait': mmapPutString$(mm, ""); break; case 'upsidedonw': mmapPutString$(mm, ""); break; case 'seascape': mmapPutString$(mm, ""); break; }mtime = true;return orientation; }
 } }
 } finally { mm.close();if (mtime) { let pr = openInputFile(path), pw = appendOutputFile(path); { let c = readChar(pr); setOutputPortPosition$(pw, 0);writeChar(c, pw); }closeInputPort(pr);closeOutputPort(pw); } }
 } }
)
const parseExifDate = ((d) => { let parseError = ((d, i) => { throw new $ioParseError({'proc': 'parse-exif-date','msg': "Illegal syntax",'obj': "a{"+d.substring(0, i)+"}"+d[i]}); }
);let substringtoint = ((d, i, l) => { let len = (i + l), zero = '0'.charCodeAt(0); { const loop$ = ((function loop(i, acc) { if (i === len) return acc; else { let v = (d[i].charCodeAt(0) - zero); if (((v < 0)) || ((v > 9))) return parseError(d, i); else return loop((i + 1), (v + (acc * 10))); } })(i, 0)); return loop$; } });if ((d.length === 19) && (d[4] === ':') && (d[7] === ':') && (d[10] === ' ') && (d[13] === ':') && (d[16] === ':')) return makeDate({"sec": substringtoint(d, 17, 2), "min": substringtoint(d, 14, 2), "hour": substringtoint(d, 11, 2), "day": substringtoint(d, 8, 2), "month": substringtoint(d, 5, 2), "year": substringtoint(d, 0, 4)}); else return parseError(d, 0); }
)
