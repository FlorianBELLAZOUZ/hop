/*=====================================================================*/
/*    .../project/hop/hop/node_modules/exif/node/exif-module.js        */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Tue Mar 26 07:54:31 2024                          */
/*    Last change :  Wed Mar 27 10:24:46 2024 (serrano)                */
/*    Copyright   :  2024 Manuel Serrano                               */
/*    -------------------------------------------------------------    */
/*    Exif parser (generated from bigloo:api/multimedia/Llib/exif.scm) */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    The module                                                       */
/*---------------------------------------------------------------------*/
import * as fs from "node:fs";
import { Mmap } from "./mmap.mjs";

/*---------------------------------------------------------------------*/
/*    errors                                                           */
/*---------------------------------------------------------------------*/
const $errnoIoFileNotFoundError = Error.ENOENT;
const $errnoIoParseError = -1;

/*---------------------------------------------------------------------*/
/*    error_errno ...                                                  */
/*---------------------------------------------------------------------*/
function error_errno(errno, proc, msg, obj) {
   const err = new Error(`${proc}: ${msg} -- ${obj}`);
   err.errno = errno;
   throw err;
}

/*---------------------------------------------------------------------*/
/*    $ioParseError ...                                                */
/*---------------------------------------------------------------------*/
function $ioParseError({proc, msg, obj}) {
   throw new Error(`${proc}: ${msg} -- ${obj}`);
}

/*---------------------------------------------------------------------*/
/*    warning ...                                                      */
/*---------------------------------------------------------------------*/
function warning(...vals) {
   console.log.apply(console, vals);
}

/*---------------------------------------------------------------------*/
/*    makeDate ...                                                     */
/*---------------------------------------------------------------------*/
function makeDate({sec, min, hour, day, month, year}) {
   return new Date(year, month - 1, day, hour, min, sec);
}

/*---------------------------------------------------------------------*/
/*    cons ...                                                         */
/*---------------------------------------------------------------------*/
function cons(a, d) {
   return [a, d];
}

/*---------------------------------------------------------------------*/
/*    pairp ...                                                        */
/*---------------------------------------------------------------------*/
function pairp(o) {
   Array.isArray(o) && o.length === 2;
}

/*---------------------------------------------------------------------*/
/*    car ...                                                          */
/*---------------------------------------------------------------------*/
function car(o) {
   return o[0];
}

/*---------------------------------------------------------------------*/
/*    cdr ...                                                          */
/*---------------------------------------------------------------------*/
function cdr(o) {
   return o[1];
}

/*---------------------------------------------------------------------*/
/*    Exif ...                                                         */
/*---------------------------------------------------------------------*/
export function Exif(file) {
   return jpegExif(file);
}

Exif.prototype = exif.prototype;
// generated by /home/serrano/prgm/project/hop/hop/node_modules/exif/node/mkjast.scm

export function exif(props) {
    this.version = false;
    this.jpegEncoding = false;
    this.jpegCompress = false;
    this.software = false;
    this.comment = false;
    this.$commentpos = false;
    this.$commentlen = false;
    this.description = false;
    this.date = false;
    this.offsetTime = false;
    this.offsetTimeOriginal = false;
    this.offsetTimeDigitized = false;
    this.make = false;
    this.model = false;
    this.uniqueCameraModel = false;
    this.cameraSerialNumber = false;
    this.orientation = 'landscape';
    this.$orientationpos = false;
    this.width = false;
    this.height = false;
    this.iwidth = false;
    this.ilength = false;
    this.ewidth = false;
    this.eheight = false;
    this.xresolution = false;
    this.yresolution = false;
    this.resolutionUnit = false;
    this.focalLength = false;
    this.focalLength35 = false;
    this.customRender = false;
    this.exposureMode = false;
    this.whiteBalance = false;
    this.digitalZoomRatio = false;
    this.lightSource = false;
    this.flash = false;
    this.fnumber = false;
    this.iso = false;
    this.shutterSpeedValue = false;
    this.exposureProgram = false;
    this.exposureTime = false;
    this.exposureBiasValue = false;
    this.aperture = false;
    this.maxAperture = false;
    this.meteringMode = false;
    this.cddWidth = false;
    this.focalPlaneXres = false;
    this.focalPlaneYres = false;
    this.focalPlaneUnits = false;
    this.gpsTag = false;
    this.brightnessValue = false;
    this.subjectDistance = false;
    this.colorspace = false;
    this.sensingMethod = false;
    this.compositeImage = false;
    this.lensMake = false;
    this.lensModel = false;
    this.digitalZoomRatio = false;
    this.sceneCaptureType = "???";
    this.gainControl = "???";
    this.contrast = "???";
    this.saturation = "???";
    this.sharpness = "???";
    this.distanceSubjectRange = false;
    this.newSubfileType = false;
    this.YCbCrCoef = false;
    this.YCbCrSubsampling = false;
    this.YCbCrPositioning = false;
    this.refere = false;
    this.rating = false;
    this.ratingPercentage = false;
    this.copyright = false;
    this.artist = false;
    this.makerNode = false;
    this.thumbnail = false;
    this.thumbnailPath = false;
    this.thumbnailOffset = false;
    this.thumbnailLength = false;
    this.$class = 'exif';
    Object.assign(this, props);
}
exif.prototype.duplicate = function(props) {
    const o = new exif({});
    Object.assign(o, this);
    Object.assign(o, props);
    return o;
}// generated by hop2js
export {
    jpegExif,
    jpegExifCommentSet$,
    jpegExifOrientationSet$,
    parseExifDate
}
const exifError = ((proc, msg, obj) => {
    return error_errno($errnoIoParseError, proc, msg, obj);
})
const get16u = ((en, bytes, o) => {
    let stringGet16U = ((en, bytes, o) => {
        return (en) ? (((bytes[o].charCodeAt(0) << 8) | bytes[(1 + o)].charCodeAt(0))) : (((bytes[(1 + o)].charCodeAt(0) << 8) | bytes[o].charCodeAt(0)));
    });
    let mmapGet16U = ((en, bytes, o) => {
        return (en) ? (((bytes.ref(o).charCodeAt(0) << 8) | bytes.ref((1 + o)).charCodeAt(0))) : (((bytes.ref((1 + o)).charCodeAt(0) << 8) | bytes.ref(o).charCodeAt(0)));
    });
    if (typeof(bytes) === 'string') return stringGet16U(en, bytes, o);
    else return mmapGet16U(en, bytes, o);
})
const get32u = ((en, bytes, o) => {
    let stringGet32U = ((en, bytes, o) => {
        let e0 = bytes[o].charCodeAt(0),
            e1 = bytes[(1 + o)].charCodeAt(0),
            e2 = bytes[(2 + o)].charCodeAt(0),
            e3 = bytes[(3 + o)].charCodeAt(0);
        if (en) return ((e0 << 24) | ((e1 << 16) | ((e2 << 8) | e3)));
        else return ((e3 << 24) | ((e2 << 16) | ((e1 << 8) | e0)));
    });
    let mmapGet32U = ((en, bytes, o) => {
        let e0 = bytes.ref(o).charCodeAt(0),
            e1 = bytes.ref((1 + o)).charCodeAt(0),
            e2 = bytes.ref((2 + o)).charCodeAt(0),
            e3 = bytes.ref((3 + o)).charCodeAt(0);
        if (en) return ((e0 << 24) | ((e1 << 16) | ((e2 << 8) | e3)));
        else return ((e3 << 24) | ((e2 << 16) | ((e1 << 8) | e0)));
    });
    if (typeof(bytes) === 'string') return stringGet32U(en, bytes, o);
    else return mmapGet32U(en, bytes, o);
})
const getformat = ((en, bytes, o, fmt) => {
    switch (fmt) {
        case 1:
        case 6:
            return (typeof(bytes) === 'string') ? (bytes[o]) : (bytes.ref(o)).charCodeAt(0);
            break;
        case 3:
        case 8:
            return get16u(en, bytes, o);
            break;
        case 4:
        case 9:
            return get32u(en, bytes, o);
            break;
        case 5:
        case 10: {
            let num = get32u(en, bytes, o),
                den = get32u(en, bytes, (o + 4));
            if (den === 0) return 0;
            else return cons(num, den);
        }
        break;
        case 11:
            return exifError("exif", "Unsupported number format", fmt);
            break;
        case 12:
            return exifError("exif", "Unsupported number format", fmt);
            break;
        default:
            return 0;
    }
})
const getformat_fx = ((en, bytes, o, fmt) => {
    let res = getformat(en, bytes, o, fmt);
    if (Number.isInteger(res)) return res;
    else if (Number.isInteger(res)) return res;
    else return 0;
})
let _exifFormatsSize_ = ['_', 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8]
const readJpegMarker = ((p) => {
    if (!(p.get() === '\u00ff')) return false;
    else return p.get().charCodeAt(0);
})
const removeTrailingSpaces$ = ((s) => {
    let len = s.length;
    if (len === 0) return s;
    else {
        let start = (len - 1);
        {
            const loop$ = ((function loop(i) {
                if (s[i] === ' ') return loop((i - 1));
                else if (i === 0) return "";
                else if (i === start) return s;
                else return stringShrink$(s, (i + 1));
            })(start));
            return loop$;
        }
    }
})
const processExifDir$ = ((en, bytes, start, base, exif, o0) => {
    let strncpy = ((o, max) => {
        let stringStrncpy = ((o, max) => {
            const loop$ = ((function loop(i) {
                if (i === max) return bytes.substring(o, (o + i));
                else {
                    let c = bytes[(i + o)];
                    if (c === '\u0000') return bytes.substring(o, (o + i));
                    else return loop((i + 1));
                }
            })(0));
            return loop$;
        });
        let mmapStrncpy = ((o, max) => {
            const loop$ = ((function loop(i) {
                if (i === max) return mmapSubstring(bytes, o, (o + i));
                else {
                    let c = bytes.ref((i + o));
                    if (c === '\u0000') return mmapSubstring(bytes, o, (i + o));
                    else return loop((i + 1));
                }
            })(0));
            return loop$;
        });
        if (typeof(bytes) === 'string') return stringStrncpy(o, max);
        else return mmapStrncpy(o, max);
    });
    let processExifGpsTag = ((o, bcount) => {
        return false;
    });
    {
        let dnum = get16u(en, bytes, start);
        {
            const loop$ = ((function loop(de) {
                if ((de < dnum)) {
                    let da = (start + (2 + (12 * de))),
                        tag = get16u(en, bytes, da),
                        fmt = get16u(en, bytes, (2 + da)),
                        cmp = get32u(en, bytes, (4 + da));
                    {
                        let bcount = (cmp * _exifFormatsSize_[fmt]),
                            valptr = ((bcount > 4)) ? ((((ov) => {
                                return (base + ov);
                            })(get32u(en, bytes, (8 + da))))) : ((8 + da));
                        switch (tag) {
                            case 1:
                                undefined;
                                break;
                            case 1: {
                                let lr = strncpy(valptr, bcount);
                                console.error("gps latitude ref");
                                undefined;
                            }
                            break;
                            case 2: {
                                let la = strncpy(valptr, bcount);
                                console.error("gps latitude");
                                undefined;
                            }
                            break;
                            case 3: {
                                let lr = strncpy(valptr, bcount);
                                console.error("gps longitude ref");
                                undefined;
                            }
                            break;
                            case 4:
                                console.error("tag gps longitude...");
                                undefined;
                                break;
                            case 5:
                                console.error("tag gps altitude ref");
                                undefined;
                                break;
                            case 6:
                                console.error("tag gps altitude");
                                undefined;
                                break;
                            case 7:
                                console.error("tag gps timstamp");
                                undefined;
                                break;
                            case 8:
                                console.error("tag gps satelite [", strncpy(valptr, bcount), "]");
                                undefined;
                                break;
                            case 9:
                                console.error("tag gps status [", strncpy(valptr, bcount), "]");
                                undefined;
                                break;
                            case 10:
                                console.error("tag gps measure mode [", strncpy(valptr, bcount), "]");
                                undefined;
                                break;
                            case 11:
                                undefined;
                                break;
                            case 12:
                                undefined;
                                break;
                            case 13:
                                undefined;
                                break;
                            case 14:
                                undefined;
                                break;
                            case 15:
                                undefined;
                                break;
                            case 16:
                                undefined;
                                break;
                            case 17:
                                undefined;
                                break;
                            case 18:
                            case 19:
                            case 20:
                            case 21:
                            case 22:
                            case 23:
                            case 24:
                            case 25:
                            case 26:
                            case 27:
                            case 28:
                            case 29:
                            case 30:
                            case 31:
                                undefined;
                                break;
                            case 254: {
                                let s = getformat_fx(en, bytes, valptr, fmt);
                                {
                                    let obj1004 = exif;
                                    obj1004.newSubfileType = s;
                                }
                            }
                            break;
                            case 256: {
                                let w = getformat_fx(en, bytes, valptr, fmt);
                                {
                                    let obj1005 = exif;
                                    obj1005.iwidth = w;
                                }
                            }
                            break;
                            case 257: {
                                let l = getformat_fx(en, bytes, valptr, fmt);
                                {
                                    let obj1006 = exif;
                                    obj1006.ilength = l;
                                }
                            }
                            break;
                            case 258:
                                'todo';
                                break;
                            case 259: {
                                let c = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1007 = exif;
                                    obj1007.jpegCompress = c;
                                }
                            }
                            break;
                            case 262: {
                                let c = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1008 = exif;
                                    obj1008.jpegCompress = c;
                                }
                            }
                            break;
                            case 270: {
                                let obj1009 = exif;
                                obj1009.description = strncpy(valptr, bcount);
                            }
                            break;
                            case 271: {
                                let obj1010 = exif;
                                obj1010.make = strncpy(valptr, 31);
                            }
                            break;
                            case 272: {
                                let obj1011 = exif;
                                obj1011.model = strncpy(valptr, 39);
                            }
                            break;
                            case 273:
                                'todo';
                                break;
                            case 274: {
                                let o = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1012 = exif;
                                    obj1012.orientation = (() => {
                                        switch (o) {
                                            case 1:
                                                return 'landscape';
                                                break;
                                            case 6:
                                                return 'portrait';
                                                break;
                                            case 8:
                                                return 'upsidedown';
                                                break;
                                            default:
                                                return 'seascape';
                                        }
                                    })();
                                }
                            }
                            break;
                            case 277:
                                'todo';
                                break;
                            case 278:
                                'todo';
                                break;
                            case 279:
                                'todo';
                                break;
                            case 282: {
                                let xr = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1013 = exif;
                                    obj1013.xresolution = xr;
                                }
                            }
                            break;
                            case 283: {
                                let yr = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1014 = exif;
                                    obj1014.yresolution = yr;
                                }
                            }
                            break;
                            case 284:
                                'todo';
                                break;
                            case 296: {
                                let ru = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1015 = exif;
                                    obj1015.resolutionUnit = ru;
                                }
                            }
                            break;
                            case 305: {
                                let obj1016 = exif;
                                obj1016.software = strncpy(valptr, bcount);
                            }
                            break;
                            case 306: {
                                let dt = strncpy(valptr, 31);
                                {
                                    let obj1017 = exif;
                                    obj1017.date = parseExifDate(dt);
                                }
                            }
                            break;
                            case 315: {
                                let obj1018 = exif;
                                obj1018.artist = strncpy(valptr, bcount);
                            }
                            break;
                            case 330:
                                'ignored';
                                break;
                            case 513: {
                                let ol = getformat_fx(en, bytes, valptr, fmt),
                                    of = (ol + base);
                                {
                                    let obj1019 = exif;
                                    obj1019.thumbnailOffset = of;
                                }
                            }
                            break;
                            case 514: {
                                let le = getformat_fx(en, bytes, valptr, fmt);
                                {
                                    let obj1020 = exif;
                                    obj1020.thumbnailLength = le;
                                }
                            }
                            break;
                            case 515:
                                'todo';
                                break;
                            case 517:
                                'todo';
                                break;
                            case 518:
                                'todo';
                                break;
                            case 519:
                                'todo';
                                break;
                            case 520:
                                'todo';
                                break;
                            case 520:
                                'todo';
                                break;
                            case 529: {
                                let co = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1021 = exif;
                                    obj1021.YCbCrCoef = co;
                                }
                            }
                            break;
                            case 530: {
                                let ss = getformat_fx(en, bytes, valptr, fmt);
                                {
                                    let obj1022 = exif;
                                    obj1022.YCbCrSubsampling = ss;
                                }
                            }
                            break;
                            case 531: {
                                let pos = getformat_fx(en, bytes, valptr, fmt);
                                {
                                    let obj1023 = exif;
                                    obj1023.YCbCrPositioning = pos;
                                }
                            }
                            break;
                            case 532: {
                                let ref = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1024 = exif;
                                    obj1024.refere = ref;
                                }
                            }
                            break;
                            case 18246: {
                                let ra = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1025 = exif;
                                    obj1025.rating = ra;
                                }
                            }
                            break;
                            case 18249: {
                                let ra = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1026 = exif;
                                    obj1026.ratingPercentage = ra;
                                }
                            }
                            break;
                            case 33432: {
                                let obj1027 = exif;
                                obj1027.copyright = strncpy(valptr, bcount);
                            }
                            break;
                            case 33434: {
                                let et = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1028 = exif;
                                    obj1028.exposureTime = et;
                                }
                            }
                            break;
                            case 33437: {
                                let fn = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1029 = exif;
                                    obj1029.fnumber = fn;
                                }
                            }
                            break;
                            case 34665: {
                                let ss = (base + get32u(en, bytes, valptr));
                                processExifDir$(en, bytes, ss, base, exif, o0);
                            }
                            break;
                            case 34850: {
                                let e = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1030 = exif;
                                    obj1030.exposureProgram = e;
                                }
                            }
                            break;
                            case 34853:
                                processExifGpsTag(valptr, bcount);
                                {
                                    let t = getformat_fx(en, bytes, valptr, fmt);
                                    {
                                        let obj1031 = exif;
                                        obj1031.gpsTag = t;
                                    }
                                }
                                break;
                            case 34855: {
                                let is = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1032 = exif;
                                    obj1032.iso = is;
                                }
                            }
                            break;
                            case 36864:
                                'todo';
                                break;
                            case 36867:
                            case 36868: {
                                let obj1033 = exif;
                                obj1033.date = parseExifDate(strncpy(valptr, 19));
                            }
                            break;
                            case 36880: {
                                let obj1034 = exif;
                                obj1034.offsetTime = strncpy(valptr, bcount);
                            }
                            break;
                            case 36881: {
                                let obj1035 = exif;
                                obj1035.offsetTimeOriginal = strncpy(valptr, bcount);
                            }
                            break;
                            case 36882: {
                                let obj1036 = exif;
                                obj1036.offsetTimeDigitized = strncpy(valptr, bcount);
                            }
                            break;
                            case 37121:
                                undefined;
                                break;
                            case 37122:
                                undefined;
                                break;
                            case 37377: {
                                let sv = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1037 = exif;
                                    obj1037.shutterSpeedValue = sv;
                                }
                            }
                            break;
                            case 37379: {
                                let bv = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1038 = exif;
                                    obj1038.brightnessValue = bv;
                                }
                            }
                            break;
                            case 37378: {
                                let ap = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1039 = exif;
                                    obj1039.aperture = ap;
                                }
                            }
                            break;
                            case 37380: {
                                let bv = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1040 = exif;
                                    obj1040.exposureBiasValue = bv;
                                }
                            }
                            break;
                            case 37381: {
                                let ap = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1041 = exif;
                                    obj1041.maxAperture = ap;
                                }
                            }
                            break;
                            case 37382: {
                                let sd = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1042 = exif;
                                    obj1042.subjectDistance = sd;
                                }
                            }
                            break;
                            case 37383: {
                                let mm = (() => {
                                    switch (getformat_fx(en, bytes, valptr, fmt)) {
                                        case 2:
                                            return "center weight";
                                            break;
                                        case 3:
                                            return "spot";
                                            break;
                                        case 5:
                                            return "matrix";
                                            break;
                                        default:
                                            return "???";
                                    }
                                })();
                                {
                                    let obj1043 = exif;
                                    obj1043.meteringMode = mm;
                                }
                            }
                            break;
                            case 37384: {
                                let fl = getformat_fx(en, bytes, valptr, fmt),
                                    f = !((fl & 7) === 0);
                                {
                                    let obj1044 = exif;
                                    obj1044.lightSource = f;
                                }
                            }
                            break;
                            case 37385: {
                                let fl = getformat_fx(en, bytes, valptr, fmt),
                                    f = !((fl & 7) === 0);
                                {
                                    let obj1045 = exif;
                                    obj1045.flash = f;
                                }
                            }
                            break;
                            case 37386: {
                                let fl = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1046 = exif;
                                    obj1046.focalLength = fl;
                                }
                            }
                            break;
                            case 37510: {
                                let obj1047 = exif;
                                obj1047['$commentpos'] = (valptr + o0);
                                obj1047['$commentlen'] = 199;
                                if (bytes.substring(valptr, valptr + 8) === "ASCII\u0000\u0000\u0000") obj1047.comment = removeTrailingSpaces$(strncpy((8 + valptr), 191));
                            }
                            break;
                            case 37500: {
                                let obj1048 = exif;
                                strncpy(valptr, bcount);
                            }
                            break;
                            case 37520:
                                undefined;
                                break;
                            case 37521:
                                undefined;
                                break;
                            case 37522:
                                undefined;
                                break;
                            case 40960:
                                undefined;
                                break;
                            case 40961: {
                                let cs = getformat_fx(en, bytes, valptr, fmt);
                                {
                                    let obj1049 = exif;
                                    obj1049.colorspace = cs;
                                }
                            }
                            break;
                            case 40962: {
                                let w = getformat_fx(en, bytes, valptr, fmt);
                                {
                                    let obj1050 = exif;
                                    obj1050.ewidth = w;
                                }
                            }
                            break;
                            case 40963: {
                                let w = getformat_fx(en, bytes, valptr, fmt);
                                {
                                    let obj1051 = exif;
                                    obj1051.eheight = w;
                                }
                            }
                            break;
                            case 40965:
                                undefined;
                                break;
                            case 41486: {
                                let r = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1052 = exif;
                                    obj1052.focalPlaneXres = (pairp(r)) ? ((car(r) / cdr(r))) : (r);
                                }
                            }
                            break;
                            case 41487: {
                                let r = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1053 = exif;
                                    obj1053.focalPlaneYres = (pairp(r)) ? ((car(r) / cdr(r))) : (r);
                                }
                            }
                            break;
                            case 41488: {
                                let fpu = (() => {
                                    switch (getformat_fx(en, bytes, valptr, fmt)) {
                                        case 1:
                                            return 25.4;
                                            break;
                                        case 2:
                                            return 25.4;
                                            break;
                                        case 3:
                                            return 10;
                                            break;
                                        case 4:
                                            return 1;
                                            break;
                                        case 5:
                                            return 0.001;
                                            break;
                                    }
                                })();
                                {
                                    let obj1054 = exif;
                                    obj1054.focalPlaneUnits = fpu;
                                }
                            }
                            break;
                            case 41495: {
                                let sm = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1055 = exif;
                                    obj1055.sensingMethod = sm;
                                }
                            }
                            break;
                            case 41728:
                                undefined;
                                break;
                            case 41729:
                                undefined;
                                break;
                            case 41985: {
                                let cr = (() => {
                                    switch (getformat_fx(en, bytes, valptr, fmt)) {
                                        case 0:
                                            return "normal";
                                            break;
                                        case 1:
                                            return "custom";
                                            break;
                                        case 2:
                                            return "HDR (no original saved)";
                                            break;
                                        case 3:
                                            return "HDR (original saved)";
                                            break;
                                        case 4:
                                            return "original (for HDR)";
                                            break;
                                        case 6:
                                            return "panorama";
                                            break;
                                        case 7:
                                            return "portrait HDR";
                                            break;
                                        case 8:
                                            return "portraitauto";
                                            break;
                                        default:
                                            return "???";
                                    }
                                })();
                                {
                                    let obj1056 = exif;
                                    obj1056.customRender = cr;
                                }
                            }
                            break;
                            case 41986: {
                                let em = (() => {
                                    switch (getformat_fx(en, bytes, valptr, fmt)) {
                                        case 0:
                                            return "auto";
                                            break;
                                        case 1:
                                            return "manual";
                                            break;
                                        case 1:
                                            return "auto bracket";
                                            break;
                                        default:
                                            return "???";
                                    }
                                })();
                                {
                                    let obj1057 = exif;
                                    obj1057.exposureMode = em;
                                }
                            }
                            break;
                            case 41987: {
                                let wb = (() => {
                                    switch (getformat_fx(en, bytes, valptr, fmt)) {
                                        case 0:
                                            return "auto";
                                            break;
                                        case 1:
                                            return "manual";
                                            break;
                                        default:
                                            return "???";
                                    }
                                })();
                                {
                                    let obj1058 = exif;
                                    obj1058.whiteBalance = wb;
                                }
                            }
                            break;
                            case 41988: {
                                let dz = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1059 = exif;
                                    obj1059.digitalZoomRatio = dz;
                                }
                            }
                            break;
                            case 41989: {
                                let fl = getformat(en, bytes, valptr, fmt);
                                {
                                    let obj1060 = exif;
                                    obj1060.focalLength35 = fl;
                                }
                            }
                            break;
                            case 41990: {
                                let mm = (() => {
                                    switch (getformat_fx(en, bytes, valptr, fmt)) {
                                        case 0:
                                            return "standard";
                                            break;
                                        case 1:
                                            return "landscape";
                                            break;
                                        case 2:
                                            return "portrait";
                                            break;
                                        case 3:
                                            return "night";
                                            break;
                                        case 3:
                                            return "other";
                                            break;
                                        default:
                                            return "???";
                                    }
                                })();
                                {
                                    let obj1061 = exif;
                                    obj1061.sceneCaptureType = mm;
                                }
                            }
                            break;
                            case 41991: {
                                let gc = (() => {
                                    switch (getformat_fx(en, bytes, valptr, fmt)) {
                                        case 0:
                                            return "none";
                                            break;
                                        case 1:
                                            return "low gain up";
                                            break;
                                        case 2:
                                            return "high gain up";
                                            break;
                                        case 3:
                                            return "low gain down";
                                            break;
                                        case 4:
                                            return "high gain down";
                                            break;
                                        default:
                                            return "???";
                                    }
                                })();
                                {
                                    let obj1062 = exif;
                                    obj1062.gainControl = gc;
                                }
                            }
                            break;
                            case 41992: {
                                let mm = (() => {
                                    switch (getformat_fx(en, bytes, valptr, fmt)) {
                                        case 0:
                                            return "normal";
                                            break;
                                        case 1:
                                            return "low";
                                            break;
                                        case 2:
                                            return "hight";
                                            break;
                                        default:
                                            return "???";
                                    }
                                })();
                                {
                                    let obj1063 = exif;
                                    obj1063.contrast = mm;
                                }
                            }
                            break;
                            case 41993: {
                                let mm = (() => {
                                    switch (getformat_fx(en, bytes, valptr, fmt)) {
                                        case 0:
                                            return "normal";
                                            break;
                                        case 1:
                                            return "low";
                                            break;
                                        case 2:
                                            return "hight";
                                            break;
                                        default:
                                            return "???";
                                    }
                                })();
                                {
                                    let obj1064 = exif;
                                    obj1064.saturation = mm;
                                }
                            }
                            break;
                            case 41994: {
                                let mm = (() => {
                                    switch (getformat_fx(en, bytes, valptr, fmt)) {
                                        case 0:
                                            return "normal";
                                            break;
                                        case 1:
                                            return "soft";
                                            break;
                                        case 2:
                                            return "hard";
                                            break;
                                        default:
                                            return "???";
                                    }
                                })();
                                {
                                    let obj1065 = exif;
                                    obj1065.sharpness = mm;
                                }
                            }
                            break;
                            case 41996: {
                                let d = (() => {
                                    switch (getformat_fx(en, bytes, valptr, fmt)) {
                                        case 0:
                                            return "unkown";
                                            break;
                                        case 1:
                                            return "macro";
                                            break;
                                        case 2:
                                            return "close";
                                            break;
                                        case 3:
                                            return "distant";
                                            break;
                                        default:
                                            return "???";
                                    }
                                })();
                                {
                                    let obj1066 = exif;
                                    obj1066.distanceSubjectRange = d;
                                }
                            }
                            break;
                            case 42035: {
                                let obj1067 = exif;
                                obj1067.lensMake = strncpy(valptr, bcount);
                            }
                            break;
                            case 42036: {
                                let obj1068 = exif;
                                obj1068.lensModel = strncpy(valptr, bcount);
                            }
                            break;
                            case 42080: {
                                let obj1069 = exif;
                                obj1069.compositeImage = strncpy(valptr, bcount);
                            }
                            break;
                            case 50706:
                            case 50707:
                                'ignored';
                                break;
                            case 50708: {
                                let obj1070 = exif;
                                obj1070.uniqueCameraModel = strncpy(valptr, bcount);
                            }
                            break;
                            case 50709:
                                'ignored';
                                break;
                            case 50721:
                            case 50722:
                            case 50723:
                                'ignored';
                                break;
                            case 50724:
                                'ignored';
                                break;
                            case 50725:
                                'ignored';
                                break;
                            case 50726:
                                'ignored';
                                break;
                            case 50727:
                                'ignored';
                                break;
                            case 50728:
                                'ignored';
                                break;
                            case 50729:
                                'ignored';
                                break;
                            case 50730:
                                'ignored';
                                break;
                            case 50731:
                                'ignored';
                                break;
                            case 50732:
                                'ignored';
                                break;
                            case 50733:
                                'ignored';
                                break;
                            case 50734:
                                'ignored';
                                break;
                            case 50735: {
                                let obj1071 = exif;
                                obj1071.cameraSerialNumber = strncpy(valptr, bcount);
                            }
                            break;
                            case 50739:
                                'ignored';
                                break;
                            case 50740:
                                'ignored';
                                break;
                            case 50741:
                                'ignored';
                                break;
                            case 50778:
                            case 50779:
                            case 50780:
                                'ignored';
                                break;
                            case 50781:
                                'ignored';
                                break;
                            case 50931:
                                'ignored';
                                break;
                            case 50932:
                                'ignored';
                                break;
                            case 50934:
                                'ignored';
                                break;
                            case 50935:
                                'ignored';
                                break;
                            case 50936:
                                'ignored';
                                break;
                            case 51041:
                                'ignored';
                                break;
                            case 50937:
                            case 50938:
                            case 50939:
                            case 50940:
                            case 50941:
                                'ignored';
                                break;
                            case 50942:
                                'ignored';
                                break;
                            case 41730:
                                'ignored';
                                break;
                            case 50964:
                            case 50965:
                            case 50966:
                            case 50967:
                            case 50968:
                            case 50969:
                            case 50970:
                                'ignored';
                                break;
                            case 50971:
                                'ignored';
                                break;
                            case 50981:
                            case 50982:
                                'ignored';
                                break;
                            case 51111:
                                'ignored';
                                break;
                            default:
                                'unknown';
                        }
                    }
                    return loop((de + 1));
                }
            })(0));
            loop$
        }
        if (((start + (2 + (4 + (12 * dnum)))) < bytes.length)) {
            let of = get32u(en, bytes, (start + (2 + (12 * dnum))));
            if ((of > 0)) return processExifDir$(en, bytes, (of + base), base, exif, o0);
        }
    }
})
const readJpegExif$ = ((exif, bytes, pos) => {
    let exifEndianess = (() => {
        if (bytes.substring(6, 6 + 2) === "II") return false;
        else if (bytes.substring(6, 6 + 2) === "MM") return true;
        else {
            warning("'read-jpeg-exif", "Unknown exif endianess, assuming big endian");
            return false;
        }
    });
    if ((bytes[4] === '\u0000') && (bytes[5] === '\u0000')) {
        let en = exifEndianess(),
            hd = get16u(en, bytes, 8);
        if (!(hd === 42)) return exifError("read-jpeg-exif", "Illegal exif header", hd);
        else {
            let fo = get32u(en, bytes, 10);
            if (((fo < 8)) || ((fo > 16))) return exifError("read-jpeg-exit", "Suspicious offset of first IFD value", fo);
            else {
                let obj1072 = exif;
                processExifDir$(en, bytes, (6 + fo), 6, exif, pos);
                if ((typeof(obj1072.ewidth) === 'number') && (typeof(obj1072.focalPlaneXres) === 'number') && (typeof(obj1072.focalPlaneUnits) === 'number')) {
                    let w = ((obj1072.ewidth * obj1072.focalPlaneUnits) / obj1072.focalPlaneXres);
                    obj1072.cddWidth = w;
                }
                if ((Number.isInteger(obj1072.thumbnailOffset)) && (Number.isInteger(obj1072.thumbnailLength))) {
                    let th = bytes.substring(obj1072.thumbnailOffset, (obj1072.thumbnailOffset + obj1072.thumbnailLength));
                    obj1072.thumbnail = th;
                    return exif;
                } else return obj1072.thumbnail = false;
            }
        }
    }
})
const readCom$ = ((exif, bytes, pos) => {
    {
        let obj1073 = exif;
        {
            let len = bytes.length;
            {
                const loop$ = ((function loop(i) {
                    if (i === len) return obj1073.comment = bytes;
                    else if (bytes[i] === '\u0000') {
                        let s = bytes.substring(0, i);
                        obj1073.comment = s;
                        obj1073['$commentpos'] = pos;
                        return obj1073['$commentlen'] = i;
                    } else return loop((i + 1));
                })(0));
                return loop$;
            }
        }
    }
})
const readSofn$ = ((exif, bytes, encoding) => {
    {
        let obj1074 = exif;
        obj1074.width = get16u(true, bytes, 3);
        obj1074.height = get16u(true, bytes, 1);
        obj1074.jpegEncoding = encoding;
    }
    return exif;
})
const readJpegSection = ((mm, path) => {
    const loop$ = ((function loop(a, m) {
        if (m === '\u00ff')
            if ((a >= 6)) return exifError("read-jpeg-section", "Too many padding bytes", a);
            else return loop((a + 1), mm.get());
        else {
            let lh = mm.get().charCodeAt(0),
                ll = mm.get().charCodeAt(0),
                l = ((lh << 8) | ll);
            if ((l < 2)) return exifError("read-jpeg-section", "Section too small", a);
            else if (((l + mm.rindex) > mm.length)) return exifError("read-jpeg-section", xxx(Premature end of section read: + +(mm.length - mm.rindex)), xxx(, expected: + +l - 2));
            else return [m.charCodeAt(0), mm.toString((l - 2))];
        }
    })(0, mm.get()));
    return loop$;
})
const readJpegSections = ((exif, mm, path) => {
    mm.rindex = 0;
    {
        let m = readJpegMarker(mm);
        if (m !== 216) exifError("read-jpeg-sections", "Illegal section marker", (mm.rindex - 1));
        else {
            const loop$ = ((function loop() {
                {
                    let [m, bytes] = readJpegSection(mm, path);
                    switch (m) {
                        case 218:
                            return 'sos';
                            break;
                        case 217:
                            return 'eoi';
                            break;
                        case 254:
                            readCom$(exif, bytes, mm.rindex - bytes.length);
                            return loop();
                            break;
                        case 224:
                            return loop();
                            break;
                        case 225:
                            if (bytes.substring(0, 4) === "Exif") readJpegExif$(exif, bytes, mm.rindex - bytes.length);
                            return loop();
                            break;
                        case 192:
                            readSofn$(exif, bytes, "baseline");
                            return loop();
                            break;
                        case 193:
                            readSofn$(exif, bytes, "extended sequential");
                            return loop();
                            break;
                        case 194:
                            readSofn$(exif, bytes, "progressive");
                            return loop();
                            break;
                        case 195:
                            readSofn$(exif, bytes, "lossless");
                            return loop();
                            break;
                        case 197:
                            readSofn$(exif, bytes, "differential sequential");
                            return loop();
                            break;
                        case 198:
                            readSofn$(exif, bytes, "differential progressive");
                            return loop();
                            break;
                        case 199:
                            readSofn$(exif, bytes, "differential lossless");
                            return loop();
                            break;
                        case 201:
                            readSofn$(exif, bytes, "extended sequential, arithmetic coding");
                            return loop();
                            break;
                        case 202:
                            readSofn$(exif, bytes, "progressive, arithmetic coding");
                            return loop();
                            break;
                        case 203:
                            readSofn$(exif, bytes, "lossless, arithmetic coding");
                            return loop();
                            break;
                        case 204:
                            readSofn$(exif, bytes, "differential sequential, arithmetic coding");
                            return loop();
                            break;
                        case 205:
                            readSofn$(exif, bytes, "differential progressive, arithmetic coding");
                            return loop();
                            break;
                        case 206:
                            readSofn$(exif, bytes, "differential lossless, arithmetic coding");
                            return loop();
                            break;
                        case 207:
                            readSofn$(exif, bytes, "?");
                            return loop();
                            break;
                        default:
                            return loop();
                    }
                }
            })());
            loop$
        }
    }
    return exif;
})
const readTiffSections = ((exif, mm, path) => {
    let tiffEndianess = (() => {
        return mm.ref(0) === 'M';
    });
    let strncpy = ((o, max) => {
        const loop$ = ((function loop(i) {
            if (i === max) return mmapSubstring(mm, o, (o + i));
            else {
                let c = mm.ref((i + o));
                if (c === '\u0000') return mmapSubstring(mm, o, (i + o));
                else return loop((i + 1));
            }
        })(0));
        return loop$;
    });
    let readEntry = ((en, offset) => {
        {
            let tag = get16u(en, mm, (0 + offset)),
                typ = get16u(en, mm, (2 + offset)),
                cnt = get32u(en, mm, (4 + offset)),
                voff = get32u(en, mm, (8 + offset));
            return console.error("tag=", tag, " ", fixnumtostring(tag, 16), " typ=", typ, " cnt=", cnt, " voff=", voff, " ", (typ === 2) ? (strncpy(voff, cnt)) : undefined);
        }
    });
    let readIfd = ((en, offset) => {
        return processExifDir$(en, mm, offset, 0, exif, 0);
    });
    {
        let en = tiffEndianess(),
            offset = get32u(en, mm, 4);
        return readIfd(en, offset);
    }
})
const readRw2Sections = ((exif, mm, path) => {
    let tiffEndianess = (() => {
        return mm.ref(0) === 'M';
    });
    let strncpy = ((o, max) => {
        const loop$ = ((function loop(i) {
            if (i === max) return mmapSubstring(mm, o, (o + i));
            else {
                let c = mm.ref((i + o));
                if (c === '\u0000') return mmapSubstring(mm, o, (i + o));
                else return loop((i + 1));
            }
        })(0));
        return loop$;
    });
    let readEntry = ((en, offset) => {
        {
            let tag = get16u(en, mm, (0 + offset)),
                typ = get16u(en, mm, (2 + offset)),
                cnt = get32u(en, mm, (4 + offset)),
                voff = get32u(en, mm, (8 + offset));
            return console.error("tag=", tag, " 0x", fixnumtostring(tag, 16), " typ=", typ, " cnt=", cnt, " voff=", voff, " ", (typ === 2) ? (strncpy(voff, cnt)) : undefined);
        }
    });
    let readIfd = ((en, offset) => {
        {
            const loop$ = ((function loop(dnum, offset) {
                if ((dnum > 0)) {
                    readEntry(en, offset);
                    return loop((dnum - 1), (offset + 12));
                } else {
                    console.error("NEXT=", get32u(en, mm, offset));
                    return console.error("OFFSET=", offset, " ", integertostring(offset, 16));
                }
            })(get16u(en, mm, offset), (offset + 2)));
            loop$
        }
        return processExifDir$(en, mm, offset, 0, exif, 0);
    });
    console.error("RW2 ", mm);
    {
        let en = tiffEndianess(),
            offset = get32u(en, mm, 4);
        return readIfd(en, offset);
    }
})
const tiffp = ((mm) => {
    let res = (() => {
        switch (mm.ref(0)) {
            case "I":
                return (mm.get() === 'I') && (mm.get() === '*') && (mm.get() === '\u0000');
                break;
            case "M":
                return (mm.get() === 'M') && (mm.get() === '\u0000') && (mm.get() === '*');
                break;
            default:
                return false;
        }
    })();
    if (!res) mm.rindex = 0;
    return res;
})
const rw2p = ((mm) => {
    return (mm.ref(0) === 'I') && (mm.get() === 'I') && (mm.get() === 'U') && (mm.get() === '\u0000') && (memqArray(mm.get(), ['', ''])) && (mm.get() === '\u0000') && (mm.get() === '\u0000') && (mm.get() === '\u0000');
})
const jpegExif = ((path) => {
    if (!(fs.existsSync(path))) return error_errno($errnoIoFileNotFoundError, "jpeg-exif", "Can't find file", path);
    else {
        let mm = new Mmap(path, 'write', false),
            exf = new exif({});
        try {
            if ((mm.length > 0))
                if (tiffp(mm)) readTiffSections(exf, mm, path);
                else if (rw2p(mm)) readTiffSections(exf, mm, path);
            else readJpegSections(exf, mm, path);
        } finally {
            mm.close()
        }
        return exf;
    }
})
const jpegExifCommentSet$ = ((path, comment) => {
    if (!(fs.existsSync(path))) return error_errno($errnoIoFileNotFoundError, "jpeg-exif-comment-set!", "Can't find file", path);
    else {
        let mm = new Mmap(path),
            exf = new exif({}),
            mtime = false;
        try {
            if ((mm.length > 0)) {
                readJpegSections(exf, mm, path);
                {
                    let obj1075 = exf;
                    return (obj1075['$commentpos']) && ((((len, s) => {
                        mm.windex = obj1075['$commentpos'];
                        mmapPutString$(mm, "ASCII\u0000\u0000\u0000");
                        mmapPutString$(mm, s);
                        mmapPutString$(mm, "\u0000");
                        mtime = true;
                        return s;
                    })(comment.length, ((len < obj1075['$commentlen'])) ? (comment) : (comment.substring(0, obj1075['$commentlen'])))));
                }
            }
        } finally {
            mm.close();
            if (mtime) {
                let pr = openInputFile(path),
                    pw = appendOutputFile(path);
                {
                    let c = readChar(pr);
                    setOutputPortPosition$(pw, 0);
                    writeChar(c, pw);
                }
                closeInputPort(pr);
                closeOutputPort(pw);
            }
        }
    }
})
const jpegExifOrientationSet$ = ((path, orientation) => {
    if (!(fs.existsSync(path))) return error_errno($errnoIoFileNotFoundError, "jpeg-exif-comment-set!", "Can't find file", path);
    else {
        let mm = new Mmap(path),
            exf = new exif({}),
            mtime = false;
        try {
            if ((mm.length > 0)) {
                readJpegSections(exf, mm, path);
                {
                    let obj1076 = exf;
                    if (obj1076['$orientationpos']) {
                        mm.windex = obj1076['$orientationpos'];
                        switch (orientation) {
                            case 'landscape':
                                mmapPutString$(mm, "");
                                break;
                            case 'portrait':
                                mmapPutString$(mm, "");
                                break;
                            case 'upsidedonw':
                                mmapPutString$(mm, "");
                                break;
                            case 'seascape':
                                mmapPutString$(mm, "");
                                break;
                        }
                        mtime = true;
                        return orientation;
                    }
                }
            }
        } finally {
            mm.close();
            if (mtime) {
                let pr = openInputFile(path),
                    pw = appendOutputFile(path);
                {
                    let c = readChar(pr);
                    setOutputPortPosition$(pw, 0);
                    writeChar(c, pw);
                }
                closeInputPort(pr);
                closeOutputPort(pw);
            }
        }
    }
})
const parseExifDate = ((d) => {
    let parseError = ((d, i) => {
        throw new $ioParseError({
            'proc': 'parse-exif-date',
            'msg': "Illegal syntax",
            'obj': xxx(a {
                +
            } + d.substring(0, i) + +d[i])
        });
    });
    let substringtoint = ((d, i, l) => {
        let len = (i + l),
            zero = '0'.charCodeAt(0);
        {
            const loop$ = ((function loop(i, acc) {
                if (i === len) return acc;
                else {
                    let v = (d[i].charCodeAt(0) - zero);
                    if (((v < 0)) || ((v > 9))) return parseError(d, i);
                    else return loop((i + 1), (v + (acc * 10)));
                }
            })(i, 0));
            return loop$;
        }
    });
    if ((d.length === 19) && (d[4] === ':') && (d[7] === ':') && (d[10] === ' ') && (d[13] === ':') && (d[16] === ':')) return makeDate({
        "sec": substringtoint(d, 17, 2),
        "min": substringtoint(d, 14, 2),
        "hour": substringtoint(d, 11, 2),
        "day": substringtoint(d, 8, 2),
        "month": substringtoint(d, 5, 2),
        "year": substringtoint(d, 0, 4)
    });
    else return parseError(d, 0);
})