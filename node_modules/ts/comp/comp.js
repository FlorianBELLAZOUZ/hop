/*=====================================================================*/
/*    serrano/prgm/project/hop/hop/node_modules/ts/comp/comp.js        */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Mon Mar 22 15:56:44 2021                          */
/*    Last change :  Thu Apr 15 10:50:56 2021 (serrano)                */
/*    Copyright   :  2021 Manuel Serrano                               */
/*    -------------------------------------------------------------    */
/*    TS to Hop                                                        */
/*=====================================================================*/
"use strict";

/*---------------------------------------------------------------------*/
/*    module                                                           */
/*---------------------------------------------------------------------*/
import { readFileSync, writeFileSync } from "fs";
import * as path from "path";
//import * as _ts from "/usr/share/nodejs/typescript/lib/typescript.js";
import * as _ts from "/usr/lib/nodejs/typescript/lib/typescript.js";
import * as hopc from "/usr/local/lib/hop/3.5.0/node_modules/hopc/lib/ast.js";

const ts = _ts.default;

/*---------------------------------------------------------------------*/
/*    global options                                                   */
/*---------------------------------------------------------------------*/
const options = { 
   allowJS: true,
   module: "commonJS",
   autorequire: true,
   contractjs: "contract.js"
};

/*---------------------------------------------------------------------*/
/*    builtinTypes                                                     */
/*---------------------------------------------------------------------*/
const builtinTypes = {
   Error: "CT.errorCT"
};

/*---------------------------------------------------------------------*/
/*    NameSpaces                                                       */
/*---------------------------------------------------------------------*/
class NS {
   constructor( id, parent ) {
      this.id = id;
      this.parent = parent;
      this.namespaces = [];
      this.declarations = [];
      this.depth = 0;
      
      if( parent ) {
      	 parent.namespaces.push( this );
	 this.depth = parent.depth + 1;
      }
   }
 
   out( m ) {
      console.log( `${m}const __${this.id} = (function() {` );
      
      this.outDeclarations( m + "  " );
      
      console.log( `${m}})();` );
   }
   
   outDeclarations( m ) {
      // namespaces
      if( this.namespaces.length > 0 ) {
	 this.namespaces.forEach( ns => ns.out( m + "  " ) );
      }
	 
      // declarations
      const l = this.declarations.length;
      if( l > 0 ) {
	 this.declarations.forEach( (d, i) => {
	       console.log( `${m}const ${d.id}${d.tag} = ${d.toString()};` );
	    } );
	 
	 console.log( `${m}return {` );
	 this.declarations.forEach( (d, i) => {
	       console.log( `  ${m}${d.id}${d.tag}: ${d.id}${d.tag}${i === l - 1 ? "" : ","}` );
	    } );
	 console.log( `${m}};` );
      }
   }
   
   qname( name ) {
      if( this.parent ) {
      	 return `${this.id}.${name}`;
      } else {
      	 return name;
      }
   }
}

/*---------------------------------------------------------------------*/
/*    Module                                                           */
/*---------------------------------------------------------------------*/
class Module extends NS {
   constructor( id, filename ) {
      super( id, false );
      this.filename = filename;
      this.defexport = false;
   }
   
   out( m ) {
      console.log( "// file:", this.filename );
      
      // namespaces
      if( this.namespaces.length > 0 ) {
	 this.namespaces.forEach( ns => ns.out( "" ) );
      }
	 
      // declarations
      if( this.declarations.length > 0 ) {
	 this.declarations.forEach( d => {
      	       const decl = `const ${d.id}${d.tag} = ${d.toString()};`;
      	       
	       console.log( m + decl );
      	       console.log( "" );
      	    } );
      }

      // exports
      if( this.declarations.length > 0 ) {
	 if( options.module === "commonJS" ) {
	    this.declarations.forEach( d => {
		  if( d.export ) {
	       	     console.log( `exports.${d.id} = ${d.id}${d.tag};` );
		  }
	       } );
	 } else {
	    this.declarations.forEach( d => {
		  if( d.export ) {
	       	     console.log( `export exports.${d.id}.${d.tag} as ${d.id};` );
		  }
	       } );
      	 }
      }
      
      // default export
      if( this.defexport ) {
	 const defexport = `${this.defexport.id}${this.defexport.tag}`;
	 
      	 console.log( "// module exports" );
      	 if( options.module === "commonJS" ) {
	    console.log( `module.exports = ${defexport};` );
      	 } else {
	    console.log( `export default ${defexport};` );
      	 }
      }
   }
}

/*---------------------------------------------------------------------*/
/*    Decl ...                                                         */
/*---------------------------------------------------------------------*/
class Decl {
   constructor( id, ns, tag, obj ) {
      this.id = id;
      this.ns = ns;
      this.tag = tag;
      this.obj = obj;
      this.export = false;
   }
}

/*---------------------------------------------------------------------*/
/*    TypeDecl ...                                                     */
/*---------------------------------------------------------------------*/
class TypeDecl extends Decl {
   constructor( id, ns, obj ) {
      super( id, ns, "CT", obj );
   }
   
   toString() {
      return this.obj;
   }
}

/*---------------------------------------------------------------------*/
/*    FunDecl ...                                                      */
/*---------------------------------------------------------------------*/
class FunDecl extends Decl {
   constructor( id, ns, obj, exp ) {
      super( id, ns, "_ct", obj );
      this.export = exp;
   }
   
   toString() {
      return `${this.obj}.wrap( ${this.ns.qname( this.id ) } )`;
   }
}

/*---------------------------------------------------------------------*/
/*    CT ...                                                           */
/*---------------------------------------------------------------------*/
function CT( node, env, ns ) {
   switch( node.kind ) {
      case ts.SyntaxKind.FunctionDeclaration: 
	 if( node.name ) {
	    const id = nameToString( node.name );
	    const ct = functionCT( node, env );
	    const exp = node.modifies && node.modifiers.find( n => n.kind === ts.SyntaxKind.ExportKeyword );
	    const odecl = ns.declarations.find( d => d.id === id );

	    if( odecl ) {
	       odecl.ct = `CT.CTAnd( ${odecl.ct}, ${ct} )`;
	    } else {
	       ns.declarations.push( new FunDecl( id, ns, ct, exp ) );
	    }
	 }
	 break;
	 
      case ts.SyntaxKind.TypeAliasDeclaration: 
	 if( node.name ) {
	    const id = nameToString( node.name );
	    const descr = { rec: false };
	    const nenv = { [id]: descr, __proto__: env };
	    const ct = typeCT( node.type, nenv );
	    
	    ns.declarations.push( new TypeDecl( id, ns, descr.rec ? `CT.CTRec( () => ${ct} )` : ct ) );
	 }
	 break;
	 
      case ts.SyntaxKind.InterfaceDeclaration: 
	 if( node.name ) {
	    const id = nameToString( node.name );
	    const descr = { rec: false };
	    const nenv = { [id]: descr, __proto__: env };
	    const ct = intfCT( node, nenv );
	    
	    ns.declarations.push( new TypeDecl( id, ns, descr.rec ? `CT.CTRec( () => ${ct} )` : ct ) );
	 }
	 break;
	 
      case ts.SyntaxKind.ExportAssignment:
	 if( node.expression.kind === ts.SyntaxKind.Identifier ) {
	    const id = node.expression.escapedText;
	    const d = ns.declarations.find( d => d.id === id );
	    
	    if( d ) {
	       ns.defexport = d;
	    } else {
	       console.log( "// error, cannot find exported declaration", id );
	    }
	 }
	 return;
	    
      case ts.SyntaxKind.EndOfFileToken:
	 return;
	 
      case ts.SyntaxKind.ModuleDeclaration:
	 const nns = new NS( nameToString( node.name ), ns );

	 CT( node.body, {}, nns );
	 return;
	 
      case ts.SyntaxKind.ModuleBlock:
	 node.statements.forEach( s => CT( s, env, ns ) );
	 return;
	 
      default:
	 console.log( "// unhandled node type: " + ts.SyntaxKind[ node.kind ] );
   }
}

/*---------------------------------------------------------------------*/
/*    functionCT ...                                                   */
/*---------------------------------------------------------------------*/
function functionCT( node, env ) {
   const ctself = "CT.trueCT";
   const ctparams = node.parameters.map( p => paramCT( p, env ) );
   const ctret = typeCT( node.type, env );
   
   return `CT.CTFunction( ${ctself }, [ ${ctparams} ], ${ctret} )`;
}

/*---------------------------------------------------------------------*/
/*    paramCT ...                                                      */
/*---------------------------------------------------------------------*/
function paramCT( node, env ) {
   if( node.dotDotDotToken ) {
      return `{ contract: ${typeCT( node.type.elementType, env )}, dotdotdot: true }`;
   } else if( node.questionToken ) {
      return `{ contract: ${typeCT( node.type, env )}, optional: true }`;
   } else {
      return typeCT( node.type, env );
   }
}

/*---------------------------------------------------------------------*/
/*    nameToString ...                                                 */
/*---------------------------------------------------------------------*/
function nameToString( tname ) {
   switch( tname.kind ) {
      case ts.SyntaxKind.Identifier:
	 return tname.escapedText;
      case ts.SyntaxKind.QualifiedName:
	 return `__${nameToString( tname.left )}.${nameToString( tname.right ) }`;
      default:
	 return "";
   }
}

/*---------------------------------------------------------------------*/
/*    typeCT ...                                                       */
/*---------------------------------------------------------------------*/
function typeCT( node, env ) {
   if( !node.kind ) {
      return false;
   } else {
      switch( node.kind ) {
      	 case ts.SyntaxKind.AnyKeyword:
	    return "CT.anyCT";
      	 case ts.SyntaxKind.VoidKeyword:
	    return "CT.voidCT";
      	 case ts.SyntaxKind.NumberKeyword:
	    return "CT.numberCT";
      	 case ts.SyntaxKind.StringKeyword:
	    return "CT.stringCT";
      	 case ts.SyntaxKind.BooleanKeyword:
	    return "CT.booleanCT";
      	 case ts.SyntaxKind.ParenthesizedType:
	    return typeCT( node.type, env );
	 case ts.SyntaxKind.ArrayType:
	    return `CT.CTArray( ${typeCT( node.elementType, env )} )`;
      	 case ts.SyntaxKind.TypeLiteral:
	    return `CT.CTObject( { ${node.members.map( s => sigCT( s, env ) ).join( ", " )} } )`;
      	 case ts.SyntaxKind.UnionType:
	    return `CT.CTOr( ${node.types.map( t => typeCT( t, env ) ).filter( x => x )} )`;
      	 case ts.SyntaxKind.FunctionType:
	    return functionCT( node, env );
      	 case ts.SyntaxKind.TypeReference:
	    const id = nameToString( node.typeName );
	    if( env[ id ] ) { env[ id ].rec = true }
	    return builtinTypes[ id ] || `${id}CT`;
      	 default:
	    return `/* unknown type ${ts.SyntaxKind[ node.kind ]} */CT.trueCT`;
      }
   }
}

/*---------------------------------------------------------------------*/
/*    intfCT ...                                                       */
/*---------------------------------------------------------------------*/
function intfCT( node, env ) {
   return `CT.CTInterface( { ${node.members.map( s => sigCT( s, env ) ).join( ", " )} } )`;
}

/*---------------------------------------------------------------------*/
/*    typeName ...                                                     */
/*---------------------------------------------------------------------*/
function typeName( node, env ) {
   if( !node.kind ) {
      return false;
   } else {
      switch( node.kind ) {
      	 case ts.SyntaxKind.AnyKeyword:
	    return "true";
      	 case ts.SyntaxKind.NumberKeyword:
	    return "number";
      	 case ts.SyntaxKind.StringKeyword:
	    return "string";
      	 case ts.SyntaxKind.BooleanKeyword:
	    return "boolean";
      	 case ts.SyntaxKind.ParenthesizedType:
	    return typeCT( node.type, env );
      	 default:
	    return `/* unknown type ${ts.SyntaxKind[ node.kind ]} */"true"`;
      }
   }
}

/*---------------------------------------------------------------------*/
/*    sigCT ...                                                        */
/*---------------------------------------------------------------------*/
function sigCT( node, env ) {
   const ct = typeCT( node.type, env );
   
   switch( node.kind ) {
      case ts.SyntaxKind.PropertySignature:
	 if( node.questionToken ) {
	    return `"${nameToString( node.name )}": { contract: ${ct}, optional: true }`;
	 } else {
	    return `"${nameToString( node.name )}": ${ct}`;
      	 }
	 
      case ts.SyntaxKind.IndexSignature:
	 const param = node.parameters[ 0 ];
	 return `"${nameToString( param.name )}": { contract: ${ct}, index: "${typeName( param.type, env )}"  }`;
	 
      default:
	 return "sigCT" + ts.SyntaxKind[ node.type ];
   }
}

/*---------------------------------------------------------------------*/
/*    autorequire ...                                                  */
/*    -------------------------------------------------------------    */
/*    Try to guess a good "require" for that module.                   */
/*---------------------------------------------------------------------*/
function autorequire( file ) {
   if( file === "index.d.ts" ) {
      const basename = path.basename( process.cwd() );
      console.log( `const ${basename} = require( "./index.js" );` );
   } else {
      const basename = file.replace( /d.ts$/, "" );
      console.log( `const ${basename} = require( "./${basename}.js" );` );
   }
}

/*---------------------------------------------------------------------*/
/*    TCType ...                                                       */
/*---------------------------------------------------------------------*/
function TCType( node, tc ) {
   if( tc.getTypeAtLocation( node ).intrinsicName ) {
      return J2SSymbol( tc.getTypeAtLocation( node ).intrinsicName );
   } else {
      return J2SSymbol( "unknown" );
   }
}

/*---------------------------------------------------------------------*/
/*    KEY ...                                                          */
/*---------------------------------------------------------------------*/
let KEY = 0;

/*---------------------------------------------------------------------*/
/*    J2SKey ...                                                       */
/*---------------------------------------------------------------------*/
function J2SKey() {
   return KEY++;
}

/*---------------------------------------------------------------------*/
/*    J2SSymbol ...                                                    */
/*---------------------------------------------------------------------*/
function J2SSymbol( str ) {
   return { __symbol__: str };
}

/*---------------------------------------------------------------------*/
/*    J2SLoc ...                                                       */
/*---------------------------------------------------------------------*/
function J2SLoc( node, env ) {
   return `${env.source}:${node.pos}`;
}

/*---------------------------------------------------------------------*/
/*    J2SEndloc ...                                                    */
/*---------------------------------------------------------------------*/
function J2SEndloc( node, env ) {
   return `${env.source}:${node.end}`
}

/*---------------------------------------------------------------------*/
/*    J2SType ...                                                      */
/*---------------------------------------------------------------------*/
function J2SType( node ) {
   if( !node || !node.kind ) {
      return J2SSymbol( "unknown" );
   } else {
      switch( node.kind ) {
      	 case ts.SyntaxKind.AnyKeyword:
	    return J2SSymbol( "any" );
      	 case ts.SyntaxKind.VoidKeyword:
	    return J2SSymbol( "undefined" );
      	 case ts.SyntaxKind.NumberKeyword:
	    return J2SSymbol( "number" );
      	 case ts.SyntaxKind.StringKeyword:
	    return J2SSymbol( "string" );
      	 case ts.SyntaxKind.BooleanKeyword:
	    return J2SSymbol( "boolean" );
      	 case ts.SyntaxKind.ParenthesizedType:
	    return J2SType( node.type, env );
	 case ts.SyntaxKind.ArrayType:
	    return J2SSymbol( "array" );
      	 case ts.SyntaxKind.TypeLiteral:
	    return J2SSymbol( "object" );
      	 case ts.SyntaxKind.UnionType:
	    return J2SSymbol( "object" );
      	 case ts.SyntaxKind.FunctionType:
	    return J2SSymbol( "function" );
      	 case ts.SyntaxKind.TypeReference:
	    return J2SSymbol( nameToString )( node.typeName );
      	 default:
	    return J2SSymbol( `/* unknown type ${ts.SyntaxKind[ node.kind ]} */any` );
      }
   }
}

/*---------------------------------------------------------------------*/
/*    J2SHint ...                                                      */
/*---------------------------------------------------------------------*/
function J2SHint( node, env ) {
   const ty = J2SType( node );
   
   if( ty.__symbol__ !== "any" && ty.__symbol__ !== "unknown" ) {
      return [ { __car__: ty, __cdr__: 100000 } ];
   } else {
      return null;
   }
}
   
/*---------------------------------------------------------------------*/
/*    J2SIdent ...                                                     */
/*---------------------------------------------------------------------*/
function J2SIdent( node, env, scope ) {
   switch( node.kind ) {
      case ts.SyntaxKind.Identifier:
	 return J2SSymbol( node.escapedText );
      default:
	 return J2SSymbol( `/* unknown ident ${ts.SyntaxKind[ node.kind ]} */_` );
   }
}

/*---------------------------------------------------------------------*/
/*    J2SUndefined ...                                                 */
/*---------------------------------------------------------------------*/
function J2SUndefined( node, env, scope ) {
   return new hopc.J2SUndefined( J2SLoc( node, env ), // loc
      J2SSymbol( "undefined" ), // type
      null, // hint
      undefined ); // range
}

/*---------------------------------------------------------------------*/
/*    J2SString ...                                                    */
/*---------------------------------------------------------------------*/
function J2SString( node, env, scope ) {
   return new hopc.J2SString( J2SLoc( node, env ), // loc
      J2SSymbol( "string" ), // type
      null, // hint
      undefined, // range
      node.escapedText, // value
      null ); //escape
}

/*---------------------------------------------------------------------*/
/*    J2SName ...                                                      */
/*---------------------------------------------------------------------*/
function J2SName( node, env, scope ) {
   switch( node.kind ) {
      case ts.SyntaxKind.Identifier:
	 return J2SString( node, env, scope );
      default:
	 console.error( "NAME=", ts.SyntaxKind[ node.kind ], node.kind );
	 return J2SSymbol( `/* unknown name ${ts.SyntaxKind[ node.kind ]} */_` );
   }
}

/*---------------------------------------------------------------------*/
/*    J2SOperator ...                                                  */
/*---------------------------------------------------------------------*/
function J2SOperator( node, env, scope ) {
   switch( node.kind ) {
      case ts.SyntaxKind.PlusToken: 
	 return J2SSymbol( "+" );
      default:
	 console.error( "TS=", ts.SyntaxKind[ node.kind ], node.kind );
	 return J2SSymbol( `/* unknown operator ${ts.SyntaxKind[ node.kind ]} */_` );
   }
}

/*---------------------------------------------------------------------*/
/*    J2SBinary ...                                                    */
/*---------------------------------------------------------------------*/
function J2SBinary( node, env, scope ) {
   if( node.operatorToken.kind === ts.SyntaxKind.FirstAssignment ) {
      return new hopc.J2SAssig( J2SLoc( node, env ), // loc
	 TCType( node, env.typechecker ), // type
	 null, // hint
	 undefined, // range
	 J2SExpr( node.left, env, scope ), // left
	 J2SExpr( node.right, env, scope ) ); // right
   } else {
      return new hopc.J2SBinary( J2SLoc( node, env ), // loc
	 TCType( node, env.typechecker ), // type
	 null, // hint
	 undefined, // range
	 J2SOperator( node.operatorToken, env, scope ), // op
	 J2SExpr( node.left, env, scope ), // left
	 J2SExpr( node.right, env, scope ) ); // right
   }
}

/*---------------------------------------------------------------------*/
/*    J2SFunThis ...                                                   */
/*---------------------------------------------------------------------*/
function J2SFunThis( node, env, scope, thisp ) {
   return new hopc.J2SFun( J2SLoc( node, env ), // loc
      J2SSymbol( "function" ), // type
      null, // hint
      undefined, // range
      node.type ? J2SType( node.type ) : J2SSymbol( "unknown" ), // rtype
      undefined, // rrange
      J2SSymbol( "this" ), // idthis
      false, // idgen
      J2SSymbol( "typescript" ), // mode
      false, // decl
      false, // need-bind-exit-return
      false, // new-target
      false, // vararg
      node.name ? J2SIdent( node.name, env, scope ) : J2SSymbol( "fun" ), // name
      false, // generator
      true, // optimize
      thisp, // thisp
      false, // argumentsp
      node.parameters.map( p => J2SDecl( p, env, scope ) ), // params
      3, // constrsize
      true, // src
      false, // method
      false, // ismethodof
      J2SBlock( node.body, env, scope ) ); // body
}

/*---------------------------------------------------------------------*/
/*    J2SFun ...                                                       */
/*---------------------------------------------------------------------*/
function J2SFun( node, env, scope ) {
   return J2SFunThis( node, env, scope, J2SDeclThis( node, env, scope ) );
}   
   
/*---------------------------------------------------------------------*/
/*    J2SArrow ...                                                     */
/*---------------------------------------------------------------------*/
function J2SArrow( node, env, scope ) {
   return J2SFunThis( node, env, scope, false );
}

/*---------------------------------------------------------------------*/
/*    J2SCall ...                                                      */
/*---------------------------------------------------------------------*/
function J2SCall( node, env, scope ) {
   return new hopc.J2SCall( J2SLoc( node, env ), // loc
      TCType( node, env.typechecker ), // type
      null, // hint
      undefined, // range
      -1, // profid
      J2SExpr( node.expression, env, scope ), // fun
      J2SSymbol( "direct" ), // protocol
      [ J2SUndefined( node, env, scope ) ], // thisarg
      node.arguments.map( n => J2SExpr( n, env, scope ) ) ); // args
}

/*---------------------------------------------------------------------*/
/*    J2SInit ...                                                      */
/*---------------------------------------------------------------------*/
function J2SInit( node, env, scope ) {
   switch( node.kind ) {
      case ts.SyntaxKind.PropertyAssignment:
	 return new hopc.J2SDataPropertyInit( J2SLoc( node, env ), // loc
 	    J2SName( node.name, env, scope ), // name
	    J2SExpr( node.initializer, env, scope ) ); // val
	 
      default:
	 console.error( "TS=", ts.SyntaxKind[ node.kind ], node.kind );
	 return J2SSymbol( `/* unknown init ${ts.SyntaxKind[ node.kind ]} */_` );
   }
}

/*---------------------------------------------------------------------*/
/*    J2SExpr ...                                                      */
/*---------------------------------------------------------------------*/
function J2SExpr( node, env, scope ) {
   switch( node.kind ) {
      case ts.SyntaxKind.BinaryExpression:
	 return J2SBinary( node, env, scope );
	 
      case ts.SyntaxKind.CallExpression:
	 return J2SCall( node, env, scope );
	 
      case ts.SyntaxKind.ElementAccessExpression:
	 return new hopc.J2SAccess( J2SLoc( node, env ), // loc
	    TCType( node, env,typechecker ), // type
	    null, // hint
	    undefined, // range
	    J2SExpr( node.expression, env, scope ), // obj
	    J2SExpr( node.name, env, scope ) ); // field
	 
      case ts.SyntaxKind.FunctionExpression:
	 return J2SFun( node, env, scope );
	 
      case ts.SyntaxKind.ArrowFunction:
	 return J2SArrow( node, env, scope );
	 
      case ts.SyntaxKind.Identifier:
	 return new hopc.J2SUnresolvedRef( J2SLoc( node, env ), // loc
	    TCType( node, env.typechecker ), // type
	    null, // hint
	    undefined, // range
	    false, // cache
	    J2SIdent( node, env, scope ) );

      case ts.SyntaxKind.NumericLiteral:
	 return new hopc.J2SNumber( J2SLoc( node, env ), // loc
	    J2SSymbol( "number" ), // type
	    null, // hint
	    undefined, // range
	    Number.parseFloat( node.text ) ); //val
	 
      case ts.SyntaxKind.ObjectLiteralExpression:
	 return new hopc.J2SObjInit( J2SLoc( node, env ), // loc
	    TCType( node, env.typechecker ), // type
	    null, // hint
	    undefined, // range
	    node.properties.map( n => J2SInit( n, env, scope ) ), // inits
	    false, // cmap
	    false ); // ronly
	 
      case ts.SyntaxKind.PropertyAccessExpression:
	 return new hopc.J2SAccess( J2SLoc( node, env ), // loc
	    TCType( node, env.typechecker ), // type
	    null, // hint
	    undefined, // range
	    J2SExpr( node.expression, env, scope ), // obj
	    J2SString( node.name, env, scope ) ); // field
	 
      case ts.SyntaxKind.ParenthesizedExpression:
	 return new hopc.J2SParen( J2SLoc( node, env ), // loc
	    TCType( node, env.typechecker ), // type
	    null, // hint
	    undefined, // range
	    J2SExpr( node.expression, env, scope ) ); // expression
	 
      case ts.SyntaxKind.StringLiteral:
	 return new hopc.J2SString( J2SLoc( node, env ), // loc
	    J2SSymbol( "string" ), // type
	    null, // hint
	    undefined, // range
	    node.text, //val
	    null ); // escape
	 
      case ts.SyntaxKind.Undefined:
	 return J2SUndefined( node, env, scope );
	 
      default:
	 console.error( "J2SExpr unknown epression", ts.SyntaxKind[ node.kind ] );
	 return J2SUndefined( node, env, scope );
   }
}

/*---------------------------------------------------------------------*/
/*    J2SBlock ...                                                     */
/*---------------------------------------------------------------------*/
function J2SBlock( node, env, scope ) {
   return new hopc.J2SBlock( J2SLoc( node, env ), // loc
      node.statements.map( s => J2SStmt( s, env, scope ) ), // nodes
      J2SEndloc( node, env ) ); // endloc
}

/*---------------------------------------------------------------------*/
/*    J2SStmtExpr ...                                                  */
/*---------------------------------------------------------------------*/
function J2SStmtExpr( node, env, scope ) {
   return new hopc.J2SStmtExpr( J2SLoc( node, env ), // loc
      J2SExpr( node.expression, env, scope ) );
}

/*---------------------------------------------------------------------*/
/*    J2SVarDecls ...                                                  */
/*---------------------------------------------------------------------*/
function J2SVarDecls( node, env, scope ) {
   return new hopc.J2SVarDecls( J2SLoc( node, env ), // loc
      node.declarationList.declarations.map( n => J2SStmt( n, env, scope ) ) ); // decls
}

/*---------------------------------------------------------------------*/
/*    J2SReturn ...                                                    */
/*---------------------------------------------------------------------*/
function J2SReturn( node, env, scope ) {
   return new hopc.J2SReturn( J2SLoc( node, env ), // loc
      false, // exit
      true, // tail
      undefined, // from
      J2SExpr( node.expression, env, scope ) ); // expr
}

/*---------------------------------------------------------------------*/
/*    J2SDecl ...                                                      */
/*---------------------------------------------------------------------*/
function J2SDecl( node, env, scope ) { 
   return new hopc.J2SDecl( J2SLoc( node, env ), // loc
      J2SIdent( node.name, env, scope ), // id
      false, // _scmid
      J2SKey(), // key
      true, // writable
      J2SSymbol( "local" ), // scope
      0, // usecnt
      false, // useinloop
      false, // escape
      0, // usage
      J2SSymbol( "param" ), // binder
      J2SType( node ), // utype
      J2SType( undefined ), // itype
      J2SType( undefined ), // vtype
      undefined, // irange
      undefined, // vrange
      null, // hint
      null ); // exports
}

/*---------------------------------------------------------------------*/
/*    J2SDeclThis ...                                                  */
/*---------------------------------------------------------------------*/
function J2SDeclThis( node, env, scope ) { 
   return new hopc.J2SDecl( J2SLoc( node, env ), // loc
      J2SSymbol( "this" ), // id
      J2SSymbol( "this" ), // _scmid
      J2SKey(), // key
      true, // writable
      J2SSymbol( "local" ), // scope
      0, // usecnt
      false, // useinloop
      false, // escape
      0, // usage
      J2SSymbol( "var" ), // binder
      J2SType( undefined ), // utype
      J2SType( undefined ), // itype
      J2SType( undefined ), // vtype
      undefined, // irange
      undefined, // vrange
      null, // hint
      null ); // exports
}

/*---------------------------------------------------------------------*/
/*    J2SDeclFun ...                                                   */
/*---------------------------------------------------------------------*/
function J2SDeclFun( node, env, scope ) {
   return new hopc.J2SDeclFun( J2SLoc( node, env ),  // loc
      J2SIdent( node.name, env, scope ), // name 
      false, // _scmid
      J2SKey(), // key
      false, // writable
      J2SSymbol( "global" ), // scope
      0, // usecnt
      false, // useinloop
      false, // escape
      0, // usage
      J2SSymbol( "var" ), // binder
      J2SSymbol( "function" ), // utype
      J2SSymbol( "function" ), // itype
      J2SSymbol( "function" ), // vtype
      undefined, // irange
      undefined, // vrange
      null, // hint
      null, // exports
      J2SFun( node, env, "local" ), // val
      false ); // expression
}
   
/*---------------------------------------------------------------------*/
/*    J2SDeclVar ...                                                   */
/*---------------------------------------------------------------------*/
function J2SDeclVar( node, env, scope ) {
   return new hopc.J2SDeclInit( J2SLoc( node, env ),  // loc
      J2SIdent( node.name, env, scope ), // id 
      false, // _scmid
      J2SKey(), // key
      false, // writable
      J2SSymbol( scope ), // scope
      0, // usecnt
      false, // useinloop
      false, // escape
      0, // usage
      J2SSymbol( "var" ), // binder
      J2SType( node ), // utype
      J2SType( undefined ), // itype
      J2SType( undefined ), // vtype
      undefined, // irange
      undefined, // vrange
      null, // hint
      null, // exports
      J2SExpr( node.initializer, env, scope ) ); // val
}
   
/*---------------------------------------------------------------------*/
/*    J2SStmt ...                                                      */
/*---------------------------------------------------------------------*/
function J2SStmt( node, env, scope ) {
   switch( node.kind ) {
      case ts.SyntaxKind.FunctionDeclaration: 
	 return J2SDeclFun( node, env, scope );
	 
      case ts.SyntaxKind.VariableDeclaration: 
	 return J2SDeclVar( node, env, scope );
	 
      case ts.SyntaxKind.ReturnStatement:   
	 return J2SReturn( node, env, scope );
	 
      case ts.SyntaxKind.ExpressionStatement:   
	 return J2SStmtExpr( node, env, scope );
	 
      case ts.SyntaxKind.VariableStatement:
	 return J2SVarDecls( node, env, scope );

      case ts.SyntaxKind.EndOfFileToken:
	 return false;
	 
      default:
	 console.error( "J2SStmt unknown statement", ts.SyntaxKind[ node.kind ] );
	 return new hopc.J2SStmtExpr( J2SLoc( node, env ), 
	    J2SUndefined( node, env, scope ) );
   }
}

/*---------------------------------------------------------------------*/
/*    main ...                                                         */
/*---------------------------------------------------------------------*/
function main() {
   const files = process.argv.slice( 2 );
   const prog = ts.createProgram( [ files[ 0 ] ], options );
   let tc = prog.getTypeChecker();
   const file = prog.getSourceFile( files[ 0 ] );
   let emitResult = prog.emit();
   
   let allDiagnostics = 
      ts.getPreEmitDiagnostics( prog ).concat( emitResult.diagnostics );

   if( allDiagnostics.length > 0 ) {
      console.log( "[");
      allDiagnostics.forEach( (diagnostic, i) => {
	    let msg = 
	       ts.flattenDiagnosticMessageText( diagnostic.messageText, "\n" )
	       .replace( /"/g, '\\"' );
	    
    	    if( diagnostic.file ) {
      	       let { line, character } = ts.getLineAndCharacterOfPosition( diagnostic.file, diagnostic.start );
	       console.log( `{"error": "${msg}", "at": {"file": "${diagnostic.file.fileName}", "loc": ${diagnostic.start}}}` );
    	    } else {
      	       console.log( `{"error": "${msg}"}` );
    	    }
	    if( i + 1 < allDiagnostics.length ) {
	       console.log( "," );
	    }
      	 } );
      
      console.log( "]" );
   }

   const nodes = [];
   
   ts.forEachChild( file, n => {
      const m = J2SStmt( n, {source: files[ 0 ], typechecker: tc }, "global" );
      
      if( m ) nodes.push( m );
   } );
      
   const ast = new hopc.J2SProgram( `${files[ 0 ]}:0`, // loc
      nodes, //nodes
      `${files[ 0 ]}:nodes[ nodes.length - 1 ].end`, // endloc
      0, // version
      J2SSymbol( "typescript" ), // mode
      files[ 0 ], // path
      0, // pcache-size
      0, // rxcache-size
      0, // call-size
      files[ 0 ].replace( ".ts", "" ), // name
      true, // main
      false, // module
      null, // cnsts
      null, // decls
      null, // headers
      null, // globals
      true, // direct-eval
      false, // source-map
      null, // imports
      null ); // exports
   
   if( allDiagnostics.length === 0 ) {
      writeFileSync( files[ 1 ], ast.tojson() );
      return 0;
   } else {
      return 1;
   }
}

process.exit( main() );
