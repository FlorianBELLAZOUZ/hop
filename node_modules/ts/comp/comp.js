/*=====================================================================*/
/*    serrano/prgm/project/hop/hop/node_modules/ts/comp/comp.js        */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Mon Mar 22 15:56:44 2021                          */
/*    Last change :  Wed Apr  6 09:12:27 2022 (serrano)                */
/*    Copyright   :  2021-22 Manuel Serrano                            */
/*    -------------------------------------------------------------    */
/*    TS to Hop                                                        */
/*    -------------------------------------------------------------    */
/*    see https://ts-ast-viewer.com/                                   */
/*=====================================================================*/
"use strict";

/*---------------------------------------------------------------------*/
/*    module                                                           */
/*---------------------------------------------------------------------*/
const [ , , , , , HOPMODULESDIR, TSMODULESDIR ] = process.argv;

const { readFileSync, writeFileSync } = require("fs");
const path = require("path");
const ts = require(path.join(TSMODULESDIR, "typescript/lib/typescript.js"));
const hopc = require(path.join(HOPMODULESDIR, "hopc/lib/ast.js"));

/*---------------------------------------------------------------------*/
/*    global options                                                   */
/*---------------------------------------------------------------------*/
const options = { 
   allowJS: true,
   target: ts.ScriptTarget.ES2020,
   module: ts.ModuleKind.ES2020,
   autorequire: true,
   typeRoots: [path.join(HOPMODULESDIR, "@types")],
   moduleResolution: ts.ModuleResolutionKind.NodeJs,
   paths: {
      "hop": [path.join(HOPMODULESDIR,"@types/hop.d.ts")],
      "hop:*": [path.join(HOPMODULESDIR,"*")],
      "@hop/*": [path.join(HOPMODULESDIR + "/@hop","*")]
   }
};

/*---------------------------------------------------------------------*/
/*    builtinTypes                                                     */
/*---------------------------------------------------------------------*/
const builtinTypes = {
   Error: "CT.errorCT"
};

/*---------------------------------------------------------------------*/
/*    NameSpaces                                                       */
/*---------------------------------------------------------------------*/
class NS {
   constructor(id, parent) {
      this.id = id;
      this.parent = parent;
      this.namespaces = [];
      this.declarations = [];
      this.depth = 0;
      
      if(parent) {
      	 parent.namespaces.push(this);
	 this.depth = parent.depth + 1;
      }
   }
 
   out(m) {
      console.log(`${m}const __${this.id} = (function() {`);
      
      this.outDeclarations(m + "  ");
      
      console.log(`${m}})();`);
   }
   
   outDeclarations(m) {
      // namespaces
      if(this.namespaces.length > 0) {
	 this.namespaces.forEach(ns => ns.out(m + "  "));
      }
	 
      // declarations
      const l = this.declarations.length;
      if(l > 0) {
	 this.declarations.forEach((d, i) => {
	       console.log(`${m}const ${d.id}${d.tag} = ${d.toString()};`);
	    });
	 
	 console.log(`${m}return {`);
	 this.declarations.forEach((d, i) => {
	       console.log(`  ${m}${d.id}${d.tag}: ${d.id}${d.tag}${i === l - 1 ? "" : ","}`);
	    });
	 console.log(`${m}};`);
      }
   }
   
   qname(name) {
      if(this.parent) {
      	 return `${this.id}.${name}`;
      } else {
      	 return name;
      }
   }
}

/*---------------------------------------------------------------------*/
/*    Module                                                           */
/*---------------------------------------------------------------------*/
class Module extends NS {
   constructor(id, filename) {
      super(id, false);
      this.filename = filename;
      this.defexport = false;
   }
   
   out(m) {
      console.log("// file:", this.filename);
      
      // namespaces
      if(this.namespaces.length > 0) {
	 this.namespaces.forEach(ns => ns.out(""));
      }
	 
      // declarations
      if(this.declarations.length > 0) {
	 this.declarations.forEach(d => {
      	       const decl = `const ${d.id}${d.tag} = ${d.toString()};`;
      	       
	       console.log(m + decl);
      	       console.log("");
      	    });
      }

      // exports
      if(this.declarations.length > 0) {
	 if(options.module === "commonJS") {
	    this.declarations.forEach(d => {
		  if(d.export) {
	       	     console.log(`exports.${d.id} = ${d.id}${d.tag};`);
		  }
	       });
	 } else {
	    this.declarations.forEach(d => {
		  if(d.export) {
	       	     console.log(`export exports.${d.id}.${d.tag} as ${d.id};`);
		  }
	       });
      	 }
      }
      
      // default export
      if(this.defexport) {
	 const defexport = `${this.defexport.id}${this.defexport.tag}`;
	 
      	 console.log("// module exports");
      	 if(options.module === "commonJS") {
	    console.log(`module.exports = ${defexport};`);
      	 } else {
	    console.log(`export default ${defexport};`);
      	 }
      }
   }
}

/*---------------------------------------------------------------------*/
/*    Decl ...                                                         */
/*---------------------------------------------------------------------*/
class Decl {
   constructor(id, ns, tag, obj) {
      this.id = id;
      this.ns = ns;
      this.tag = tag;
      this.obj = obj;
      this.export = false;
   }
}

/*---------------------------------------------------------------------*/
/*    TypeDecl ...                                                     */
/*---------------------------------------------------------------------*/
class TypeDecl extends Decl {
   constructor(id, ns, obj) {
      super(id, ns, "CT", obj);
   }
   
   toString() {
      return this.obj;
   }
}

/*---------------------------------------------------------------------*/
/*    FunDecl ...                                                      */
/*---------------------------------------------------------------------*/
class FunDecl extends Decl {
   constructor(id, ns, obj, exp) {
      super(id, ns, "_ct", obj);
      this.export = exp;
   }
   
   toString() {
      return `${this.obj}.wrap(${this.ns.qname(this.id) })`;
   }
}

/*---------------------------------------------------------------------*/
/*    CT ...                                                           */
/*---------------------------------------------------------------------*/
function CT(node, env, ns) {
   switch(node.kind) {
      case ts.SyntaxKind.FunctionDeclaration: 
	 if(node.name) {
	    const id = nameToString(node.name);
	    const ct = functionCT(node, env);
	    const exp = node.modifies && node.modifiers.find(n => n.kind === ts.SyntaxKind.ExportKeyword);
	    const odecl = ns.declarations.find(d => d.id === id);

	    if(odecl) {
	       odecl.ct = `CT.CTAnd(${odecl.ct}, ${ct})`;
	    } else {
	       ns.declarations.push(new FunDecl(id, ns, ct, exp));
	    }
	 }
	 break;
	 
      case ts.SyntaxKind.TypeAliasDeclaration: 
	 if(node.name) {
	    const id = nameToString(node.name);
	    const descr = { rec: false };
	    const nenv = { [id]: descr, __proto__: env };
	    const ct = typeCT(node.type, nenv);
	    
	    ns.declarations.push(new TypeDecl(id, ns, descr.rec ? `CT.CTRec(() => ${ct})` : ct));
	 }
	 break;
	 
      case ts.SyntaxKind.InterfaceDeclaration: 
	 if(node.name) {
	    const id = nameToString(node.name);
	    const descr = { rec: false };
	    const nenv = { [id]: descr, __proto__: env };
	    const ct = intfCT(node, nenv);
	    
	    ns.declarations.push(new TypeDecl(id, ns, descr.rec ? `CT.CTRec(() => ${ct})` : ct));
	 }
	 break;
	 
      case ts.SyntaxKind.ExportAssignment:
	 if(node.expression.kind === ts.SyntaxKind.Identifier) {
	    const id = node.expression.escapedText;
	    const d = ns.declarations.find(d => d.id === id);
	    
	    if(d) {
	       ns.defexport = d;
	    } else {
	       console.log("// error, cannot find exported declaration", id);
	    }
	 }
	 return;
	    
      case ts.SyntaxKind.EndOfFileToken:
	 return;
	 
      case ts.SyntaxKind.ModuleDeclaration:
	 const nns = new NS(nameToString(node.name), ns);

	 CT(node.body, {}, nns);
	 return;
	 
      case ts.SyntaxKind.ModuleBlock:
	 node.statements.forEach(s => CT(s, env, ns));
	 return;
	 
      default:
	 console.log("// unhandled node type: " + ts.SyntaxKind[ node.kind ]);
   }
}

/*---------------------------------------------------------------------*/
/*    functionCT ...                                                   */
/*---------------------------------------------------------------------*/
function functionCT(node, env) {
   const ctself = "CT.trueCT";
   const ctparams = node.parameters.map(p => paramCT(p, env));
   const ctret = typeCT(node.type, env);
   
   return `CT.CTFunction(${ctself }, [ ${ctparams} ], ${ctret})`;
}

/*---------------------------------------------------------------------*/
/*    paramCT ...                                                      */
/*---------------------------------------------------------------------*/
function paramCT(node, env) {
   if(node.dotDotDotToken) {
      return `{ contract: ${typeCT(node.type.elementType, env)}, dotdotdot: true }`;
   } else if(node.questionToken) {
      return `{ contract: ${typeCT(node.type, env)}, optional: true }`;
   } else {
      return typeCT(node.type, env);
   }
}

/*---------------------------------------------------------------------*/
/*    nameToString ...                                                 */
/*---------------------------------------------------------------------*/
function nameToString(tname) {
   switch(tname.kind) {
      case ts.SyntaxKind.Identifier:
	 return tname.escapedText;
      case ts.SyntaxKind.QualifiedName:
	 return `__${nameToString(tname.left)}.${nameToString(tname.right) }`;
      default:
	 return "";
   }
}

/*---------------------------------------------------------------------*/
/*    typeCT ...                                                       */
/*---------------------------------------------------------------------*/
function typeCT(node, env) {
   if(!node.kind) {
      return false;
   } else {
      switch(node.kind) {
      	 case ts.SyntaxKind.AnyKeyword:
	    return "CT.anyCT";
      	 case ts.SyntaxKind.VoidKeyword:
	    return "CT.voidCT";
      	 case ts.SyntaxKind.NumberKeyword:
	    return "CT.numberCT";
      	 case ts.SyntaxKind.StringKeyword:
	    return "CT.stringCT";
      	 case ts.SyntaxKind.BooleanKeyword:
	    return "CT.booleanCT";
      	 case ts.SyntaxKind.ParenthesizedType:
	    return typeCT(node.type, env);
	 case ts.SyntaxKind.ArrayType:
	    return `CT.CTArray(${typeCT(node.elementType, env)})`;
      	 case ts.SyntaxKind.TypeLiteral:
	    return `CT.CTObject({ ${node.members.map(s => sigCT(s, env)).join(", ")} })`;
      	 case ts.SyntaxKind.UnionType:
	    return `CT.CTOr(${node.types.map(t => typeCT(t, env)).filter(x => x)})`;
      	 case ts.SyntaxKind.FunctionType:
	    return functionCT(node, env);
      	 case ts.SyntaxKind.TypeReference:
	    const id = nameToString(node.typeName);
	    if(env[ id ]) { env[ id ].rec = true }
	    return builtinTypes[ id ] || `${id}CT`;
      	 default:
	    return `/* unknown type ${ts.SyntaxKind[ node.kind ]} */CT.trueCT`;
      }
   }
}

/*---------------------------------------------------------------------*/
/*    intfCT ...                                                       */
/*---------------------------------------------------------------------*/
function intfCT(node, env) {
   return `CT.CTInterface({ ${node.members.map(s => sigCT(s, env)).join(", ")} })`;
}

/*---------------------------------------------------------------------*/
/*    typeName ...                                                     */
/*---------------------------------------------------------------------*/
function typeName(node, env) {
   if(!node.kind) {
      return false;
   } else {
      switch(node.kind) {
      	 case ts.SyntaxKind.AnyKeyword:
	    return "true";
      	 case ts.SyntaxKind.NumberKeyword:
	    return "number";
      	 case ts.SyntaxKind.StringKeyword:
	    return "string";
      	 case ts.SyntaxKind.BooleanKeyword:
	    return "boolean";
      	 case ts.SyntaxKind.ParenthesizedType:
	    return typeCT(node.type, env);
      	 default:
	    return `/* unknown type ${ts.SyntaxKind[ node.kind ]} */"true"`;
      }
   }
}

/*---------------------------------------------------------------------*/
/*    sigCT ...                                                        */
/*---------------------------------------------------------------------*/
function sigCT(node, env) {
   const ct = typeCT(node.type, env);
   
   switch(node.kind) {
      case ts.SyntaxKind.PropertySignature:
	 if(node.questionToken) {
	    return `"${nameToString(node.name)}": { contract: ${ct}, optional: true }`;
	 } else {
	    return `"${nameToString(node.name)}": ${ct}`;
      	 }
	 
      case ts.SyntaxKind.IndexSignature:
	 const param = node.parameters[ 0 ];
	 return `"${nameToString(param.name)}": { contract: ${ct}, index: "${typeName(param.type, env)}"  }`;
	 
      default:
	 return "sigCT" + ts.SyntaxKind[ node.type ];
   }
}

/*---------------------------------------------------------------------*/
/*    autorequire ...                                                  */
/*    -------------------------------------------------------------    */
/*    Try to guess a good "require" for that module.                   */
/*---------------------------------------------------------------------*/
function autorequire(file) {
   if(file === "index.d.ts") {
      const basename = path.basename(process.cwd());
      console.log(`const ${basename} = require("./index.js");`);
   } else {
      const basename = file.replace(/d.ts$/, "");
      console.log(`const ${basename} = require("./${basename}.js");`);
   }
}

/*---------------------------------------------------------------------*/
/*    TCType ...                                                       */
/*---------------------------------------------------------------------*/
function TCType(node, tc) {
   if(tc.getTypeAtLocation(node).intrinsicName) {
      return J2SSymbol(tc.getTypeAtLocation(node).intrinsicName);
   } else {
      return J2SSymbol("unknown");
   }
}

/*---------------------------------------------------------------------*/
/*    KEY ...                                                          */
/*---------------------------------------------------------------------*/
let KEY = 0;

/*---------------------------------------------------------------------*/
/*    J2SKey ...                                                       */
/*---------------------------------------------------------------------*/
function J2SKey() {
   return KEY++;
}

/*---------------------------------------------------------------------*/
/*    J2SSymbol ...                                                    */
/*---------------------------------------------------------------------*/
function J2SSymbol(str) {
   return { __symbol__: str };
}

/*---------------------------------------------------------------------*/
/*    J2SLoc ...                                                       */
/*---------------------------------------------------------------------*/
function J2SLoc(node, env) {
   return `${env.source}:${node.pos}`;
}

/*---------------------------------------------------------------------*/
/*    J2SEndloc ...                                                    */
/*---------------------------------------------------------------------*/
function J2SEndloc(node, env) {
   return `${env.source}:${node.end}`
}

/*---------------------------------------------------------------------*/
/*    J2SType ...                                                      */
/*---------------------------------------------------------------------*/
function J2SType(node, env) {
   if(!node || !node.kind) {
      return J2SSymbol("unknown");
   } else {
      switch(node.kind) {
      	 case ts.SyntaxKind.AnyKeyword:
	    return J2SSymbol("any");
      	 case ts.SyntaxKind.VoidKeyword:
	    return J2SSymbol("undefined");
      	 case ts.SyntaxKind.NumberKeyword:
	    return J2SSymbol("number");
      	 case ts.SyntaxKind.StringKeyword:
	    return J2SSymbol("string");
      	 case ts.SyntaxKind.BooleanKeyword:
	    return J2SSymbol("boolean");
      	 case ts.SyntaxKind.ParenthesizedType:
	    return J2SType(node.type, env);
	 case ts.SyntaxKind.ArrayType:
	    return J2SSymbol("array");
      	 case ts.SyntaxKind.TypeLiteral:
	    return J2SSymbol("object");
      	 case ts.SyntaxKind.UnionType:
	    return J2SSymbol("object");
      	 case ts.SyntaxKind.FunctionType:
	    return J2SSymbol("function");
      	 case ts.SyntaxKind.TypeReference:
	    return J2SSymbol(nameToString)(node.typeName);
      	 case ts.SyntaxKind.VariableDeclaration:
	    return J2SType(node.type, env);
      	 default:
	    console.error("J2SType unknown node", 
	       ts.SyntaxKind[node.kind], J2SLoc(node, env));
	    return J2SSymbol(`unknown`);
      }
   }
}

/*---------------------------------------------------------------------*/
/*    J2SHint ...                                                      */
/*---------------------------------------------------------------------*/
function J2SHint(node, env) {
   const ty = J2SType(node, env);
   
   if(ty.__symbol__ !== "any" && ty.__symbol__ !== "unknown") {
      return [ { __car__: ty, __cdr__: 100000 } ];
   } else {
      return null;
   }
}
   
/*---------------------------------------------------------------------*/
/*    J2SIdent ...                                                     */
/*---------------------------------------------------------------------*/
function J2SIdent(node, env, scope) {
   switch(node.kind) {
      case ts.SyntaxKind.Identifier:
	 return J2SSymbol(node.escapedText);
      default:
	 return J2SSymbol(`/* unknown ident ${ts.SyntaxKind[ node.kind ]} */_`);
   }
}

/*---------------------------------------------------------------------*/
/*    J2SUndefined ...                                                 */
/*---------------------------------------------------------------------*/
function J2SUndefined(node, env, scope) {
   return new hopc.J2SUndefined(J2SLoc(node, env), // loc
      J2SSymbol("undefined"), // type
      null, // hint
      undefined); // range
}

/*---------------------------------------------------------------------*/
/*    J2SString ...                                                    */
/*---------------------------------------------------------------------*/
function J2SString(node, val, env, scope) {
   return new hopc.J2SString(J2SLoc(node, env), // loc
      J2SSymbol("string"), // type
      null, // hint
      undefined, // range
      val, // value
      null, //escape
      false); // private
}

/*---------------------------------------------------------------------*/
/*    J2SName ...                                                      */
/*---------------------------------------------------------------------*/
function J2SName(node, env, scope) {
   switch(node.kind) {
      case ts.SyntaxKind.Identifier:
	 return J2SString(node, node.escapedText, env, scope);
      default:
	 return J2SSymbol(`/* unknown name ${ts.SyntaxKind[ node.kind ]} */_`);
   }
}

/*---------------------------------------------------------------------*/
/*    J2SOperator ...                                                  */
/*---------------------------------------------------------------------*/
function J2SOperator(node, env, scope) {
   switch(node.kind) {
      case ts.SyntaxKind.PlusToken: 
	 return J2SSymbol("+");
	 
      case ts.SyntaxKind.GreaterThanToken: 
	 return J2SSymbol(">");
	 
      case ts.SyntaxKind.GreaterThanEqualsToken: 
	 return J2SSymbol(">=");
	 
      case ts.SyntaxKind.FirstBinaryOperator:
	 return J2SSymbol("<");
	 
      case ts.SyntaxKind.LessThanEqualsToken:
	 return J2SSymbol("<=");
	 
      case ts.SyntaxKind.FirstCompoundAssignment:
	 return J2SSymbol("+");
	 
      case ts.SyntaxKind.AmpersandAmpersandToken:
	 return J2SSymbol("&&");
	 
      case ts.SyntaxKind.BarBarToken:
	 return J2SSymbol("OR");
	 
      case ts.SyntaxKind.EqualsEqualsToken:
	 return J2SSymbol("==");
	 
      case ts.SyntaxKind.EqualsEqualsEqualsToken:
	 return J2SSymbol("===");
	 
      case ts.SyntaxKind.ExclamationEqualsEqualsToken:
	 return J2SSymbol("!==");
	 
      default:
	 console.error("TS=", ts.SyntaxKind[ node.kind ], node.kind, node.getText());
	 return J2SSymbol(`/* unknown operator ${ts.SyntaxKind[ node.kind ]} */_`);
   }
}

/*---------------------------------------------------------------------*/
/*    J2SUnary ...                                                     */
/*---------------------------------------------------------------------*/
function J2SUnary(node, env, scope) {
   switch(node.operator) {
      case 53: 
	 return new hopc.J2SUnary(J2SLoc(node, env), // loc
	    TCType(node, env.typechecker), // type
	    null, // hint
	    undefined, // range
	    J2SSymbol("!"), // op
	    J2SExpr(node.operand, env, scope)); // expression
	 
      default:
	 console.error("J2SUnary unkown expression", node);
   }
}
      
/*---------------------------------------------------------------------*/
/*    J2SBinary ...                                                    */
/*---------------------------------------------------------------------*/
function J2SBinary(node, env, scope) {
   switch(node.operatorToken.kind) {
      case ts.SyntaxKind.FirstAssignment:
      	 return new hopc.J2SAssig(J2SLoc(node, env), // loc
	    TCType(node, env.typechecker), // type
	    null, // hint
	    undefined, // range
	    J2SExpr(node.left, env, scope), // left
	    J2SExpr(node.right, env, scope)); // right
	 
      case ts.SyntaxKind.FirstCompoundAssignment:
      	 return new hopc.J2SAssigOp(J2SLoc(node, env), // loc
	    TCType(node, env.typechecker), // type
	    null, // hint
	    undefined, // range
	    J2SExpr(node.left, env, scope), // left
	    J2SExpr(node.right, env, scope), // right
	    J2SOperator(node.operatorToken, env, scope));
	 
      default:
      	 return new hopc.J2SBinary(J2SLoc(node, env), // loc
	    TCType(node, env.typechecker), // type
	    null, // hint
	    undefined, // range
	    J2SOperator(node.operatorToken, env, scope), // op
	    J2SExpr(node.left, env, scope), // left
	    J2SExpr(node.right, env, scope)); // right
   }
}

/*---------------------------------------------------------------------*/
/*    J2SFunThis ...                                                   */
/*---------------------------------------------------------------------*/
function J2SFunThis(node, env, scope, thisp, body) {
   return new hopc.J2SFun(J2SLoc(node, env), // loc
      J2SSymbol("function"), // type
      null, // hint
      undefined, // range
      J2SSymbol("unknown"), // rtype
      node.type ? J2SType(node.type, env) : J2SSymbol("unknown"), // rutype
      undefined, // rrange
      J2SSymbol("this"), // idthis
      false, // idgen
      J2SSymbol("typescript"), // mode
      false, // decl
      false, // need-bind-exit-return
      J2SSymbol("unknown"), // new-target
      false, // vararg
      node.name ? J2SIdent(node.name, env, scope) : J2SSymbol("fun"), // name
      false, // generator
      true, // optimize
      thisp, // thisp
      false, // argumentsp
      node.parameters.map(p => J2SParam(p, env, scope)), // params
      3, // constrsize
      true, // src
      false, // method
      false, // ismethodof
      body); // body
}

/*---------------------------------------------------------------------*/
/*    J2SFun ...                                                       */
/*---------------------------------------------------------------------*/
function J2SFun(node, env, scope) {
   const thisp = J2SDeclThis(node, env, scope);
   const body = J2SBlock(node.body, env, scope);
   return J2SFunThis(node, env, scope, thisp, body);
}   

/*---------------------------------------------------------------------*/
/*    J2SArrow ...                                                     */
/*---------------------------------------------------------------------*/
function J2SArrow(node, env, scope) {
   if (node.body.kind === ts.SyntaxKind.Block) {
      const body = J2SBlock(node.body, env, scope);
      return J2SFunThis(node, env, scope, false, body);
   } else {
      const loc = J2SLoc(node, env);
      const endloc = J2SEndloc(node, env)
      const expr = J2SExpr(node.body, env, scope);
      const ret = new hopc.J2SReturn(loc, // loc
      	 false, // exit
      	 true, // tail
      	 undefined, // from
      	 expr); // expr
      const body = new hopc.J2SBlock(loc, [ ret ], endloc);
      return J2SFunThis(node, env, scope, false, body);
   }
}

/*---------------------------------------------------------------------*/
/*    J2SClassElement ...                                              */
/*---------------------------------------------------------------------*/
function J2SClassElement(node, env, scope) {
   
   function J2SClassDecl(node, env, scope) {
      switch(node.kind) {
      	 case ts.SyntaxKind.MethodDeclaration: 
	    return J2SFunThis(node, env, "local", J2SDeclThis(node, env, scope));
	 default:
	    console.error("J2SClassDecl unknown statement", ts.SyntaxKind[ node.kind ]);
	    return new hopc.J2SStmtExpr(J2SLoc(node, env), 
	       J2SUndefined(node, env, scope));
      }
   }
       
   function J2SDataPropertyInit(node, env, scope) {
      return new hopc.J2SDataPropertyInit(J2SLoc(node, env), // loc
	 J2SName(node.name, env, scope), // name
	 J2SClassDecl(node, env, scope)); // val
   }
   
   return new hopc.J2SClassElement(J2SLoc(node, env), // loc
      false, // _static
      J2SDataPropertyInit(node, env, scope)); // prop
}

/*---------------------------------------------------------------------*/
/*    J2SClass ...                                                     */
/*---------------------------------------------------------------------*/
function J2SClass(node, env, scope) {
   return new hopc.J2SClass(J2SLoc(node, env), // loc
      J2SSymbol("unknown"), // type
      null, // hint
      undefined, // range
      J2SEndloc(node, env), // endloc
      J2SIdent(node.name, env, scope), // name
      false, // decl
      J2SUndefined(node, env, scope), // super
      true, // src
      node.members.map(m => J2SClassElement(m, env, scope))); // elements
}

/*---------------------------------------------------------------------*/
/*    J2SCall ...                                                      */
/*---------------------------------------------------------------------*/
function J2SCall(node, env, scope) {
   return new hopc.J2SCall(J2SLoc(node, env), // loc
      TCType(node, env.typechecker), // type
      null, // hint
      undefined, // range
      -1, // profid
      J2SExpr(node.expression, env, scope), // fun
      J2SSymbol("direct"), // protocol
      [ J2SUndefined(node, env, scope) ], // thisarg
      node.arguments.map(n => J2SExpr(n, env, scope))); // args
}

/*---------------------------------------------------------------------*/
/*    J2SNew ...                                                       */
/*---------------------------------------------------------------------*/
function J2SNew(node, env, scope) {
   return new hopc.J2SNew(J2SLoc(node, env), // loc
      TCType(node, env.typechecker), // type
      null, // hint
      undefined, // range
      [], // caches
      J2SExpr(node.expression, env, scope), // clazz
      J2SSymbol("direct"), // protocol
      node.arguments.map(n => J2SExpr(n, env, scope))); // args
}

/*---------------------------------------------------------------------*/
/*    J2SInit ...                                                      */
/*---------------------------------------------------------------------*/
function J2SInit(node, env, scope) {
   switch(node.kind) {
      case ts.SyntaxKind.PropertyAssignment:
	 return new hopc.J2SDataPropertyInit(J2SLoc(node, env), // loc
 	    J2SName(node.name, env, scope), // name
	    J2SExpr(node.initializer, env, scope)); // val
	 
      default:
	 console.error("TS=", ts.SyntaxKind[ node.kind ], node.kind);
	 return J2SSymbol(`/* unknown init ${ts.SyntaxKind[ node.kind ]} */_`);
   }
}

/*---------------------------------------------------------------------*/
/*    J2STemplate ...                                                  */
/*---------------------------------------------------------------------*/
function J2STemplate(node, env, scope) {
   const exprs = [ J2SString(node.head, node.head.text, env, scope) ];

   node.templateSpans.forEach(s => {
	 exprs.push(J2SExpr(s.expression, env, scope));
	 if(s.literal.text !== "") { 
	    exprs.push(J2SString(s.literal, s.literal.text, env, scope));
	 }
      });
   
   return new hopc.J2STemplate(J2SLoc(node, env), // loc
      J2SSymbol("string"), // type
      null, // hint
      undefined, // range
      exprs); // exprs
}

/*---------------------------------------------------------------------*/
/*    J2SExpr ...                                                      */
/*---------------------------------------------------------------------*/
function J2SExpr(node, env, scope) {
   switch(node.kind) {
      case ts.SyntaxKind.BinaryExpression:
	 return J2SBinary(node, env, scope);
	 
      case ts.SyntaxKind.CallExpression:
	 return J2SCall(node, env, scope);
	 
      case ts.SyntaxKind.NewExpression:
	 return J2SNew(node, env, scope);
	 
      case ts.SyntaxKind.ElementAccessExpression:
	 return new hopc.J2SAccess(J2SLoc(node, env), // loc
	    TCType(node, env.typechecker), // type
	    null, // hint
	    undefined, // range
	    J2SExpr(node.expression, env, scope), // obj
	    J2SExpr(node.argumentExpression, env, scope)); // field
	 
      case ts.SyntaxKind.FunctionExpression:
	 return J2SFun(node, env, scope);
	 
      case ts.SyntaxKind.ArrowFunction:
	 return J2SArrow(node, env, scope);
	 
      case ts.SyntaxKind.Identifier:
	 return new hopc.J2SUnresolvedRef(J2SLoc(node, env), // loc
	    TCType(node, env.typechecker), // type
	    null, // hint
	    undefined, // range
	    false, // cache
	    J2SIdent(node, env, scope));

      case ts.SyntaxKind.ThisKeyword:
	 return new hopc.J2SUnresolvedRef(J2SLoc(node, env), // loc
	    TCType(node, env.typechecker), // type
	    null, // hint
	    undefined, // range
	    false, // cache
	    J2SSymbol("this"));

      case ts.SyntaxKind.NumericLiteral:
	 return new hopc.J2SNumber(J2SLoc(node, env), // loc
	    J2SSymbol("number"), // type
	    null, // hint
	    undefined, // range
	    Number.parseFloat(node.text)); //val
	 
      case ts.SyntaxKind.ObjectLiteralExpression:
	 return new hopc.J2SObjInit(J2SLoc(node, env), // loc
	    TCType(node, env.typechecker), // type
	    null, // hint
	    undefined, // range
	    node.properties.map(n => J2SInit(n, env, scope)), // inits
	    false, // cmap
	    false); // ronly
	 
      case ts.SyntaxKind.ArrayLiteralExpression:
	 return new hopc.J2SArray(J2SLoc(node, env), // loc
	    TCType(node, env.typechecker), // type
	    null, // hint
	    undefined, // range
	    node.elements.length, // len
	    node.elements.map(n => J2SExpr(n, env, scope))); // exprs
	 
      case ts.SyntaxKind.PropertyAccessExpression:
	 return new hopc.J2SAccess(J2SLoc(node, env), // loc
	    TCType(node, env.typechecker), // type
	    null, // hint
	    undefined, // range
	    J2SExpr(node.expression, env, scope), // obj
	    J2SString(node.name, node.name.escapedText, env, scope)); // field
	 
      case ts.SyntaxKind.ParenthesizedExpression:
	 return new hopc.J2SParen(J2SLoc(node, env), // loc
	    TCType(node, env.typechecker), // type
	    null, // hint
	    undefined, // range
	    J2SExpr(node.expression, env, scope)); // expression
	 
      case ts.SyntaxKind.StringLiteral:
	 return J2SString(node, node.text, env, scope);
	 
      case ts.SyntaxKind.FirstTemplateToken:
	 return new hopc.J2STemplate(J2SLoc(node, env), // loc
	    J2SSymbol("string"), // type
	    null, // hint
	    undefined, // range
	    [ J2SString(node, node.text, env, scope) ]); // exprs
	 
      case ts.SyntaxKind.TemplateExpression:
	 return J2STemplate(node, env, scope);
	 
      case ts.SyntaxKind.TrueKeyword:
	 return new hopc.J2SBool(J2SLoc(node, env), // loc
	    J2SSymbol("bool"), // type
	    null, // hint
	    undefined, // range
	    true); // val
	 
      case ts.SyntaxKind.FalseKeyword:
	 return new hopc.J2SBool(J2SLoc(node, env), // loc
	    J2SSymbol("bool"), // type
	    null, // hint
	    undefined, // range
	    false); // val
	 
      case ts.SyntaxKind.TypeOfExpression:
	 return new hopc.J2SUnary(J2SLoc(node, env), // loc
	    J2SSymbol("string"), // type
	    null, // hint
	    undefined, // range
	    J2SSymbol("typeof"), // op
	    J2SExpr(node.expression, env, scope)); // expression
	 
      case ts.SyntaxKind.ConditionalExpression:
	 return new hopc.J2SCond(J2SLoc(node, env), // loc
	    J2SSymbol("unknown"), // type
	    null, // hint
	    undefined, // range
	    J2SExpr(node.condition, env, scope), // test
	    J2SExpr(node.whenTrue, env, scope), // then
	    J2SExpr(node.whenFalse, env, scope)); // else

      case ts.SyntaxKind.PrefixUnaryExpression:
	 return J2SUnary(node, env, scope);
	 
      case ts.SyntaxKind.AwaitExpression:
	 return new hopc.J2SYield(J2SLoc(node, env), // loc
	    J2SSymbol("unknown"), // type
	    null, // hint
	    undefined, // range
	    J2SExpr(node.expression, env, scope), // expression
	    false, // generator
	    true); // _await
	 
      case ts.SyntaxKind.Undefined:
	 return J2SUndefined(node, env, scope);
	 
      default:
	 console.error("J2SExpr unknown expression", ts.SyntaxKind[node.kind], J2SLoc(node, env));
	 return J2SUndefined(node, env, scope);
   }
}

/*---------------------------------------------------------------------*/
/*    J2SBlock ...                                                     */
/*---------------------------------------------------------------------*/
function J2SBlock(node, env, scope) {
   return new hopc.J2SBlock(J2SLoc(node, env), // loc
      node.statements.map(s => J2SStmt(s, env, scope)), // nodes
      J2SEndloc(node, env)); // endloc
}

/*---------------------------------------------------------------------*/
/*    J2SStmtExpr ...                                                  */
/*---------------------------------------------------------------------*/
function J2SStmtExpr(node, env, scope) {
   return new hopc.J2SStmtExpr(J2SLoc(node, env), // loc
      J2SExpr(node.expression, env, scope));
}

/*---------------------------------------------------------------------*/
/*    J2SVarDecls ...                                                  */
/*---------------------------------------------------------------------*/
function J2SVarDecls(node, env, scope) {
   return new hopc.J2SVarDecls(J2SLoc(node, env), // loc
      node.declarationList.declarations.map(n => J2SStmt(n, env, scope))); // decls
}

/*---------------------------------------------------------------------*/
/*    J2SReturn ...                                                    */
/*---------------------------------------------------------------------*/
function J2SReturn(node, env, scope) {
   const expr = node.expression 
      ? J2SExpr(node.expression, env, scope)
      : J2SUndefined(node, env, scope);
   return new hopc.J2SReturn(J2SLoc(node, env), // loc
      false, // exit
      true, // tail
      undefined, // from
      expr); // expr
}

/*---------------------------------------------------------------------*/
/*    J2SDecl ...                                                      */
/*---------------------------------------------------------------------*/
function J2SDecl(node, env, scope) { 
   return new hopc.J2SDecl(J2SLoc(node, env), // loc
      J2SIdent(node.name, env, scope), // id
      false, // _scmid
      J2SKey(), // key
      true, // writable
      J2SSymbol("local"), // scope
      0, // usecnt
      false, // useinloop
      false, // escape
      0, // usage
      J2SSymbol("param"), // binder
      J2SType(node, env), // utype
      J2SType(undefined, env), // itype
      J2SType(undefined, env), // vtype
      J2SType(undefined, env), // mtype
      undefined, // irange
      undefined, // vrange
      null, // hint
      false); // export
}

/*---------------------------------------------------------------------*/
/*    J2SParam ...                                                     */
/*---------------------------------------------------------------------*/
function J2SParam(node, env, scope) { 
   return new hopc.J2SDecl(J2SLoc(node, env), // loc
      J2SIdent(node.name, env, scope), // id
      false, // _scmid
      J2SKey(), // key
      true, // writable
      J2SSymbol("local"), // scope
      0, // usecnt
      false, // useinloop
      false, // escape
      0, // usage
      J2SSymbol("param"), // binder
      J2SType(undefined, env), // ctype
      J2SType(node.type, env), // utype
      J2SType(undefined, env), // itype
      J2SType(undefined, env), // vtype
      J2SType(undefined, env), // mtype
      undefined, // irange
      undefined, // vrange
      null, // hint
      false); // export
}

/*---------------------------------------------------------------------*/
/*    J2SDeclThis ...                                                  */
/*---------------------------------------------------------------------*/
function J2SDeclThis(node, env, scope) { 
   return new hopc.J2SDecl(J2SLoc(node, env), // loc
      J2SSymbol("this"), // id
      J2SSymbol("this"), // _scmid
      J2SKey(), // key
      true, // writable
      J2SSymbol("local"), // scope
      0, // usecnt
      false, // useinloop
      false, // escape
      0, // usage
      J2SSymbol("var"), // binder
      J2SType(undefined, env), // ctype
      J2SType(undefined, env), // utype
      J2SType(undefined, env), // itype
      J2SType(undefined, env), // vtype
      J2SType(undefined, env), // mtype
      undefined, // irange
      undefined, // vrange
      null, // hint
      false); // export
}

/*---------------------------------------------------------------------*/
/*    J2SDeclExport ...                                                */
/*---------------------------------------------------------------------*/
function J2SDeclExport(node, env, scope) {
   
   function J2SExportName(node) {
      const id = J2SIdent(node.name, env, scope);
      const alias = node.propertyName && J2SIdent(node.propertyName, env, scope);
      return new hopc.J2SExport(J2SLoc(node, env), // loc
	 id, // id
	 alias || id); // alias
   }
   
   switch (node.exportClause.kind) {
      case ts.SyntaxKind.NamedExports:
	 return node.exportClause.elements.map(J2SExportName);
      default:
	 console.error("J2SDeclExport unimplemented statement", 
	    ts.SyntaxKind[ node.kind ], J2SLoc(node, env));
   }
}
   
/*---------------------------------------------------------------------*/
/*    J2SDeclFun ...                                                   */
/*---------------------------------------------------------------------*/
function J2SDeclFun(node, env, scope) {
   return new hopc.J2SDeclFun(J2SLoc(node, env),  // loc
      J2SIdent(node.name, env, scope), // id
      false, // _scmid
      J2SKey(), // key
      false, // writable
      J2SSymbol("global"), // scope
      0, // usecnt
      false, // useinloop
      false, // escape
      0, // usage
      J2SSymbol("var"), // binder
      J2SType(undefined, env), // ctype
      J2SSymbol("function"), // utype
      J2SSymbol("function"), // itype
      J2SSymbol("function"), // vtype
      J2SType(undefined, env), // mtype
      undefined, // irange
      undefined, // vrange
      null, // hint
      false, // export
      J2SFun(node, env, "local"), // val
      false); // expression
}
   
/*---------------------------------------------------------------------*/
/*    J2SDeclMet ...                                                   */
/*---------------------------------------------------------------------*/
function J2SDeclMet(node, env, scope) {
   return new hopc.J2SDeclFun(J2SLoc(node, env),  // loc
      J2SIdent(node.name, env, scope), // name 
      false, // _scmid
      J2SKey(), // key
      false, // writable
      J2SSymbol("global"), // scope
      0, // usecnt
      false, // useinloop
      false, // escape
      0, // usage
      J2SSymbol("var"), // binder
      J2SType(undefined, env), // ctype
      J2SSymbol("function"), // utype
      J2SSymbol("function"), // itype
      J2SSymbol("function"), // vtype
      J2SType(undefined, env), // mtype
      undefined, // irange
      undefined, // vrange
      null, // hint
      false, // export
      J2SFunThis(node, env, "local"), // val
      false); // expression
}
   
/*---------------------------------------------------------------------*/
/*    J2SDeclClass ...                                                 */
/*---------------------------------------------------------------------*/
function J2SDeclClass(node, env, scope) {
   const clazz = J2SClass(node, env, "local");
   const clazzdecl = new hopc.J2SDeclClass(J2SLoc(node, env),  // loc
      J2SIdent(node.name, env, scope), // id 
      false, // _scmid
      J2SKey(), // key
      false, // writable
      J2SSymbol("global"), // scope
      0, // usecnt
      false, // useinloop
      false, // escape
      0, // usage
      J2SSymbol("var"), // binder
      J2SType(undefined, env), // ctype
      J2SSymbol("function"), // utype
      J2SSymbol("function"), // itype
      J2SSymbol("function"), // vtype
      J2SSymbol("function"), // mtype
      undefined, // irange
      undefined, // vrange
      null, // hint
      false, // export
      clazz); // val
   const vardecl = new hopc.J2SDeclInit(J2SLoc(node, env),  // loc
      J2SIdent(node.name, env, scope), // id 
      false, // _scmid
      J2SKey(), // key
      true, // writable
      J2SSymbol(scope), // scope
      0, // usecnt
      false, // useinloop
      false, // escape
      0, // usage
      J2SSymbol("class"), // binder
      J2SType(undefined, env), // ctype
      J2SType(node, env), // utype
      J2SType(undefined, env), // itype
      J2SType(undefined, env), // vtype
      J2SType(undefined, env), // mtype
      undefined, // irange
      undefined, // vrange
      null, // hint
      false, // export
      clazz); // val
   
   clazz.decl = clazzdecl;
   return new hopc.J2SVarDecls(J2SLoc(node, env), [ vardecl ]);
}
   
/*---------------------------------------------------------------------*/
/*    J2SDeclVar ...                                                   */
/*---------------------------------------------------------------------*/
function J2SDeclVar(node, env, scope) {
   if(node.initializer) {
      return new hopc.J2SDeclInit(J2SLoc(node, env),  // loc
      	 J2SIdent(node.name, env, scope), // id 
      	 false, // _scmid
      	 J2SKey(), // key
      	 true, // writable
      	 J2SSymbol(scope), // scope
      	 0, // usecnt
      	 false, // useinloop
      	 false, // escape
      	 0, // usage
      	 J2SSymbol("var"), // binder
      	 J2SType(undefined, env), // ctype
      	 J2SType(node, env), // utype
      	 J2SType(undefined, env), // itype
      	 J2SType(undefined, env), // vtype
      	 J2SType(undefined, env), // mtype
      	 undefined, // irange
      	 undefined, // vrange
      	 null, // hint
      	 false, // export
      	 J2SExpr(node.initializer, env, scope)); // val
   } else {
      return new hopc.J2SDecl(J2SLoc(node, env),  // loc
      	 J2SIdent(node.name, env, scope), // id 
      	 false, // _scmid
      	 J2SKey(), // key
      	 true, // writable
      	 J2SSymbol(scope), // scope
      	 0, // usecnt
      	 false, // useinloop
      	 false, // escape
      	 0, // usage
      	 J2SSymbol("var"), // binder
      	 J2SType(undefined, env), // ctype
      	 J2SType(node, env), // utype
      	 J2SType(undefined, env), // itype
      	 J2SType(undefined, env), // vtype
      	 J2SType(undefined, env), // mtype
      	 undefined, // irange
      	 undefined, // vrange
      	 null, // hint
      	 false); // export
   }
}

/*---------------------------------------------------------------------*/
/*    J2SVarDeclList ...                                               */
/*---------------------------------------------------------------------*/
function J2SVarDeclList(node, env, scope) {
   return new hopc.J2SVarDecls(J2SLoc(node, env), // loc
      node.declarations.map(d => J2SDeclVar(d, env, scope))); // decls
}

/*---------------------------------------------------------------------*/
/*    J2SEnumDeclaration ...                                           */
/*---------------------------------------------------------------------*/
function J2SEnumDeclaration(node, env, scope) {
   
   function J2SMember(node, idx, env, scope) {
      if(node.initializer) {
	 return [ new hopc.J2SDataPropertyInit(J2SLoc(node, env), // loc
 	    	     J2SName(node.name, env, scope), // name
	    	     J2SExpr(node.initializer, env, scope)) ]; // val
      } else {
	 return [ new hopc.J2SDataPropertyInit(J2SLoc(node, env), // loc
 	    	     J2SName(node.name, env, scope), // name
	 	     new hopc.J2SNumber(J2SLoc(node, env), // loc
	    		J2SSymbol("number"), // type
	    		null, // hint
	    		undefined, // range
	    		idx)), //val
		  new hopc.J2SDataPropertyInit(J2SLoc(node, env), // loc
	 	     new hopc.J2SNumber(J2SLoc(node, env), // loc
	    		J2SSymbol("number"), // type
	    		null, // hint
	    		undefined, // range
	    		idx),
		     J2SName(node.name, node.name, env, scope)) ];
      }
   }
   
   return new hopc.J2SVarDecls(J2SLoc(node, env),
      [ new hopc.J2SDeclInit(J2SLoc(node, env),  // loc
      	   J2SIdent(node.name, env, scope), // id 
      	   false, // _scmid
      	   J2SKey(), // key
      	   false, // writable
      	   J2SSymbol(scope), // scope
      	   0, // usecnt
      	   false, // useinloop
      	   false, // escape
      	   0, // usage
      	   J2SSymbol("let"), // binder
      	   J2SType(undefined, env), // ctype
      	   J2SType(node, env), // utype
      	   J2SType(undefined, env), // itype
      	   J2SType(undefined, env), // vtype
      	   undefined, // irange
      	   undefined, // vrange
      	   null, // hint
      	   false, // export
      	   new hopc.J2SObjInit(J2SLoc(node, env), // loc
	      TCType(node, env.typechecker), // type
	      null, // hint
	      undefined, // range
	      node.members.flatMap((n, i) => J2SMember(n, i, env, scope)), // inits
	      false, // cmap
	      false)) ]); // ronly
}

/*---------------------------------------------------------------------*/
/*    J2SImport ...                                                    */
/*---------------------------------------------------------------------*/
function J2SImport(node, env, scope) {
   
   function J2SImportName(node) {
      const name = J2SIdent(node.name, env, scope);
      const alias = node.propertyName && J2SIdent(node.propertyName, env, scope);
      return new hopc.J2SImportName(J2SLoc(node, env), // loc
	 alias || name, // name
	 name); // alias
   }
   
   function J2SImportNames(node, env, scope) {
      const loc = J2SLoc(node, env);
      const names = 
      	 node.importClause.namedBindings.elements.map(J2SImportName);
      
      return new hopc.J2SImport(loc, // loc
      	 node.moduleSpecifier.text, // path
	 false, // ipath
	 J2SUndefined(node, env,scope), // dollarpath
	 names, // importNames
	 false, // iprgm
	 false); // lang
   }
   
   function J2SImportNamespace(node, env, scope) {
      const name = 
	 J2SIdent(node.importClause.namedBindings.name, env, scope);
      const names = [new hopc.J2SImportName(J2SLoc(node, env), // loc
	     		J2SSymbol("*"), // id
	     		name)];
      
      return new hopc.J2SImport(J2SLoc(node, env), // loc
      	 node.moduleSpecifier.text, // path
	 false, // ipath
	 J2SUndefined(node, env,scope), // dollarpath
	 names, // importNames
	 false, // iprgm
	 false); // lang
   }
   
   switch (node.importClause.namedBindings.kind) {
      case ts.SyntaxKind.NamespaceImport:
	 return J2SImportNamespace(node, env, scope);
	 
      default:
	 return J2SImportNames(node, env, scope);
   }
}


/*---------------------------------------------------------------------*/
/*    J2SNop ...                                                       */
/*---------------------------------------------------------------------*/
function J2SNop(node, env, scope) {
   return new hopc.J2SNop(J2SLoc(node, env));
}

/*---------------------------------------------------------------------*/
/*    J2SFor ...                                                       */
/*---------------------------------------------------------------------*/
function J2SFor(node, env, scope) {
   return new hopc.J2SFor(J2SLoc(node, env), // loc
      false, // need_bind_exit_break
      undefined, // id
      false, // need_bind_exit_continue,
      J2SStmt(node.statement, env, scope),
      node.initializer ? 
	 J2SStmt(node.initializer, env, scope) : J2SNop(node, env, scope),
      J2SExpr(node.condition, env, scope),
      J2SExpr(node.incrementor, env, scope));
}

/*---------------------------------------------------------------------*/
/*    J2SIf ...                                                        */
/*---------------------------------------------------------------------*/
function J2SIf(node, env, scope) {
   return new hopc.J2SIf(J2SLoc(node, env), // loc
      J2SExpr(node.expression, env, scope), // test
      J2SStmt(node.thenStatement, env, scope), // then
      node.elseStatement // else
	 ? J2SStmt(node.elseStatement, env, scope) 
	    : J2SNop(node, env, scope));
}

/*---------------------------------------------------------------------*/
/*    J2STry ...                                                       */
/*---------------------------------------------------------------------*/
function J2STry(node, env, scope) {
   function J2SCatch(node, env, scope) {
      return new hopc.J2SCatch(J2SLoc(node, env), // loc
 	 J2SParam(node.variableDeclaration, env, scope), // param
	 J2SStmt(node.block, env, scope)); // body
   }
   
   return new hopc.J2STry(J2SLoc(node, env), // loc
      J2SStmt(node.tryBlock, env, scope), // body
      node.catchClause // catch
	 ? J2SCatch(node.catchClause, env, scope)
	 : J2SNop(node),
      node.finallyBlock // finally
	 ? J2SStmt(node.finallyBlock, env, scope) 
         : J2SNop(node, env, scope));
}

/*---------------------------------------------------------------------*/
/*    J2SCaseBlock ...                                                 */
/*---------------------------------------------------------------------*/
function J2SCaseBlock(node, env, scope) {
   function J2SCaseClause(node) {
      switch (node.kind) {
	 case ts.SyntaxKind.CaseClause: 
	    return new hopc.J2SCase(
	       J2SLoc(node, env),
	       J2SExpr(node.expression, env, scope),
	       new hopc.J2SSeq(
		  J2SLoc(node, env),
		  node.statements.map(n => J2SStmt(n, env, scope))));
	    
	 case ts.SyntaxKind.DefaultClause:
	    return new hopc.J2SDefault(
	       J2SLoc(node, env),
	       J2SUndefined(node, env, scope),
	       new hopc.J2SSeq(
		  J2SLoc(node, env),
		  node.statements.map(n => J2SStmt(n, env, scope))));
	    
      	 default:
	    console.error("J2SStmt unknown statement", 
	       ts.SyntaxKind[ node.kind ], J2SLoc(node, env));
	    return new hopc.J2SStmtExpr(J2SLoc(node, env), 
	       J2SUndefined(node, env, scope));
      }
   }
   
   return node.clauses.map(J2SCaseClause);
}

/*---------------------------------------------------------------------*/
/*    J2SSwitch ...                                                    */
/*---------------------------------------------------------------------*/
function J2SSwitch(node, env, scope) {
   return new hopc.J2SSwitch(J2SLoc(node, env), // loc
      true, // need_bind_exit_break
      undefined, // id
      J2SExpr(node.expression, env, scope), // key
      J2SCaseBlock(node.caseBlock, env, scope));
}

/*---------------------------------------------------------------------*/
/*    J2SStmt ...                                                      */
/*---------------------------------------------------------------------*/
function J2SStmt(node, env, scope) {
   switch (node.kind) {
      case ts.SyntaxKind.Block:
	 return J2SBlock(node, env, scope);

      case ts.SyntaxKind.ExportDeclaration:
	 env.exports = env.exports.concat(J2SDeclExport(node, env, scope));
	 return false;
	 
      case ts.SyntaxKind.ClassDeclaration: 
	 return J2SDeclClass(node, env, scope);
	 
      case ts.SyntaxKind.FunctionDeclaration: 
	 return J2SDeclFun(node, env, scope);
	 
      case ts.SyntaxKind.VariableDeclaration: 
	 return J2SDeclVar(node, env, scope);
	 
      case ts.SyntaxKind.VariableDeclarationList: 
	 return J2SVarDeclList(node, env, scope);
	 
      case ts.SyntaxKind.EnumDeclaration:
	 return J2SEnumDeclaration(node, env, scope);
	 
      case ts.SyntaxKind.ReturnStatement:   
	 return J2SReturn(node, env, scope);
	 
      case ts.SyntaxKind.ExpressionStatement:   
	 return J2SStmtExpr(node, env, scope);
	 
      case ts.SyntaxKind.VariableStatement:
	 return J2SVarDecls(node, env, scope);

      case ts.SyntaxKind.ImportDeclaration:
	 return J2SImport(node, env, scope);
	 
      case ts.SyntaxKind.ForStatement:
	 return J2SFor(node, env, scope);
	 
      case ts.SyntaxKind.IfStatement:
	 return J2SIf(node, env, scope);
	 
      case ts.SyntaxKind.EmptyStatement:
	 return J2SNop(node, env, scope);
	 
      case ts.SyntaxKind.InterfaceDeclaration: 
	 return J2SNop(node, env, scope);
	 
      case ts.SyntaxKind.TryStatement:
	 return J2STry(node, env, scope);
	 
      case ts.SyntaxKind.ThrowStatement:
	 return new hopc.J2SThrow(J2SLoc(node, env),
	    J2SExpr(node.expression, env, scope));
	 
      case ts.SyntaxKind.SwitchStatement:
	 return J2SSwitch(node, env, scope);

      case ts.SyntaxKind.BreakStatement:
	 return new hopc.J2SBreak(J2SLoc(node, env), false, false);
	 
      case ts.SyntaxKind.EndOfFileToken:
	 return false;
	 
      default:
	 console.error("J2SStmt unknown statement", 
	    ts.SyntaxKind[node.kind], J2SLoc(node, env));
	 return new hopc.J2SStmtExpr(J2SLoc(node, env), 
	    J2SUndefined(node, env, scope));
   }
}

/*---------------------------------------------------------------------*/
/*    main ...                                                         */
/*---------------------------------------------------------------------*/
function main() {
   const [, , src, tgt, main, , , debug] = process.argv;
   
   const emitjs = debug === "true";
   
   const opts = {noEmit: !emitjs, ... options};
   const prog = ts.createProgram([src], opts);
   let tc = prog.getTypeChecker();
   const file = prog.getSourceFile(src);
   let emitResult = prog.emit();
   
   let allDiagnostics = 
      ts.getPreEmitDiagnostics(prog).concat(emitResult.diagnostics);

   if(allDiagnostics.length > 0) {
      console.log("[");
      allDiagnostics.forEach((diagnostic, i) => {
	    let msg = 
	       ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n")
	       .replace(/"/g, '\\"')
	       .replace(/\n/g, '');
	    
    	    if(diagnostic.file) {
      	       let { line, character } = ts.getLineAndCharacterOfPosition(diagnostic.file, diagnostic.start);
	       console.log(`{"error": "${msg}", "at": {"file": "${diagnostic.file.fileName}", "loc": ${diagnostic.start}}}`);
    	    } else {
      	       console.log(`{"error": "${msg}"}`);
    	    }
	    if(i + 1 < allDiagnostics.length) {
	       console.log(",");
	    }
      	 });
      
      console.log("]");
   }

   const nodes = [];
   const env = { source: src, typechecker: tc, exports: [] }
   
   ts.forEachChild(file, n => {
      const m = J2SStmt(n, env, "global");
      
      if (m) nodes.push(m);
   });
      
   const ast = new hopc.J2SProgram(`${src}:0`, // loc
      nodes, //nodes
      `${src}:nodes[ nodes.length - 1 ].end`, // endloc
      J2SSymbol("typescript"), // mode
      src, // path
      0, // pcache-size
      0, // rxcache-size
      0, // call-size
      src.replace(".ts", ""), // name
      main == "true", // main
      false, // module
      null, // cnsts
      null, // decls
      null, // headers
      null, // globals
      true, // direct-eval
      false, // source-map
      null, // imports
      env.exports); // exports
   
   if(allDiagnostics.length === 0) {
      writeFileSync(tgt, ast.tojson());
      return 0;
   } else {
      return 1;
   }
}

process.exit(main());
