/*=====================================================================*/
/*    serrano/prgm/project/hop/hop/node_modules/ts/comp/comp.js        */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Mon Mar 22 15:56:44 2021                          */
/*    Last change :  Wed Jan 11 02:18:52 2023 (serrano)                */
/*    Copyright   :  2021-23 Manuel Serrano                            */
/*    -------------------------------------------------------------    */
/*    TS to Hop                                                        */
/*    -------------------------------------------------------------    */
/*    see https://ts-ast-viewer.com/                                   */
/*=====================================================================*/
"use strict";

/*---------------------------------------------------------------------*/
/*    module                                                           */
/*---------------------------------------------------------------------*/
const [ , , , , , HOPMODULESDIR, TSMODULESDIR ] = process.argv;

const { readFileSync, writeFileSync } = require("fs");
const path = require("path");
const ts = require(path.join(TSMODULESDIR, "typescript/lib/typescript.js"));
const hopc = require(path.join(HOPMODULESDIR, "hopc/lib/ast.js"));

/*---------------------------------------------------------------------*/
/*    global options                                                   */
/*---------------------------------------------------------------------*/
const options = { 
   pretty: false,
   allowJS: true,
   target: ts.ScriptTarget.ES2020,
   module: ts.ModuleKind.ES2020,
   autorequire: true,
   typeRoots: [path.join(HOPMODULESDIR, "@types")],
   moduleResolution: ts.ModuleResolutionKind.NodeJs,
   pretty: false,
   experimentalDecorators: true,
   allowSyntheticDefaultImports: true,
   paths: {
      "hop": [path.join(HOPMODULESDIR,"@types/hop.d.ts")],
      "hop:*": [path.join(HOPMODULESDIR,"*")],
      "@hop/*": [path.join(HOPMODULESDIR + "/@hop","*")]
   }
};

/*---------------------------------------------------------------------*/
/*    errorBuffer ...                                                  */
/*---------------------------------------------------------------------*/
let errorBuffer = [];

/*---------------------------------------------------------------------*/
/*    parseError ...                                                   */
/*---------------------------------------------------------------------*/
function parseError(msg, node, env) {
   errorBuffer.push({"error": msg, "at": {"file": env.source, "loc": node.pos}});
}

/*---------------------------------------------------------------------*/
/*    NameSpaces                                                       */
/*---------------------------------------------------------------------*/
class NS {
   constructor(id, parent) {
      this.id = id;
      this.parent = parent;
      this.namespaces = [];
      this.declarations = [];
      this.depth = 0;
      
      if (parent) {
      	 parent.namespaces.push(this);
	 this.depth = parent.depth + 1;
      }
   }
 
   out(m) {
      console.log(`${m}const __${this.id} = (function() {`);
      
      this.outDeclarations(m + "  ");
      
      console.log(`${m}})();`);
   }
   
   outDeclarations(m) {
      // namespaces
      if (this.namespaces.length > 0) {
	 this.namespaces.forEach(ns => ns.out(m + "  "));
      }
	 
      // declarations
      const l = this.declarations.length;
      if (l > 0) {
	 this.declarations.forEach((d, i) => {
	       console.log(`${m}const ${d.id}${d.tag} = ${d.toString()};`);
	    });
	 
	 console.log(`${m}return {`);
	 this.declarations.forEach((d, i) => {
	       console.log(`  ${m}${d.id}${d.tag}: ${d.id}${d.tag}${i === l - 1 ? "" : ","}`);
	    });
	 console.log(`${m}};`);
      }
   }
   
   qname(name) {
      if (this.parent) {
      	 return `${this.id}.${name}`;
      } else {
      	 return name;
      }
   }
}

/*---------------------------------------------------------------------*/
/*    Module                                                           */
/*---------------------------------------------------------------------*/
class Module extends NS {
   constructor(id, filename) {
      super(id, false);
      this.filename = filename;
      this.defexport = false;
   }
   
   out(m) {
      console.log("// file:", this.filename);
      
      // namespaces
      if (this.namespaces.length > 0) {
	 this.namespaces.forEach(ns => ns.out(""));
      }
	 
      // declarations
      if (this.declarations.length > 0) {
	 this.declarations.forEach(d => {
      	       const decl = `const ${d.id}${d.tag} = ${d.toString()};`;
      	       
	       console.log(m + decl);
      	       console.log("");
      	    });
      }

      // exports
      if (this.declarations.length > 0) {
	 if (options.module === "commonJS") {
	    this.declarations.forEach(d => {
		  if (d.export) {
	       	     console.log(`exports.${d.id} = ${d.id}${d.tag};`);
		  }
	       });
	 } else {
	    this.declarations.forEach(d => {
		  if (d.export) {
	       	     console.log(`export exports.${d.id}.${d.tag} as ${d.id};`);
		  }
	       });
      	 }
      }
      
      // default export
      if (this.defexport) {
	 const defexport = `${this.defexport.id}${this.defexport.tag}`;
	 
      	 console.log("// module exports");
      	 if (options.module === "commonJS") {
	    console.log(`module.exports = ${defexport};`);
      	 } else {
	    console.log(`export default ${defexport};`);
      	 }
      }
   }
}

/*---------------------------------------------------------------------*/
/*    typeToString ...                                                 */
/*---------------------------------------------------------------------*/
function typeToString(tname) {
   switch (tname.kind) {
      case ts.SyntaxKind.Identifier:
	 switch (tname.escapedText) {
	    case "boolean": return "bool";
	    default: return tname.escapedText;
	 }
      case ts.SyntaxKind.QualifiedName:
	 return `__${typeToString(tname.left)}.${typeToString(tname.right) }`;
      default:
	 return "";
   }
}


/*---------------------------------------------------------------------*/
/*    autorequire ...                                                  */
/*    -------------------------------------------------------------    */
/*    Try to guess a good "require" for that module.                   */
/*---------------------------------------------------------------------*/
function autorequire(file) {
   if (file === "index.d.ts") {
      const basename = path.basename(process.cwd());
      console.log(`const ${basename} = require("./index.js");`);
   } else {
      const basename = file.replace(/d.ts$/, "");
      console.log(`const ${basename} = require("./${basename}.js");`);
   }
}


/*---------------------------------------------------------------------*/
/*    asyncFun ...                                                     */
/*---------------------------------------------------------------------*/
function asyncFun(node) {
   if (node.modifiers) {
      return node.modifiers.find(n => n.kind === ts.SyntaxKind.AsyncKeyword);
   } else {
      return false;
   }
}

/*---------------------------------------------------------------------*/
/*    TCType ...                                                       */
/*---------------------------------------------------------------------*/
function TCType(node, tc) {
   const iname = tc.getTypeAtLocation(node).intrinsicName;

   if (iname) {
      if (iname === "error") {
      	 return J2SSymbol("unknown");
      } else {
      	 return J2SSymbol(iname);
      }
   } else {
      return J2SSymbol("unknown");
   }
}

/*---------------------------------------------------------------------*/
/*    KEY ...                                                          */
/*---------------------------------------------------------------------*/
let KEY = 0;

/*---------------------------------------------------------------------*/
/*    J2SKey ...                                                       */
/*---------------------------------------------------------------------*/
function J2SKey() {
   return KEY++;
}

/*---------------------------------------------------------------------*/
/*    J2SSymbol ...                                                    */
/*---------------------------------------------------------------------*/
function J2SSymbol(str) {
   return { __symbol__: str };
}

/*---------------------------------------------------------------------*/
/*    J2SLoc ...                                                       */
/*---------------------------------------------------------------------*/
function J2SLoc(node, env) {
   return `${env.source}:${node.pos}`;
}

/*---------------------------------------------------------------------*/
/*    J2SEndloc ...                                                    */
/*---------------------------------------------------------------------*/
function J2SEndloc(node, env) {
   return `${env.source}:${node.end}`
}

/*---------------------------------------------------------------------*/
/*    J2SType ...                                                      */
/*---------------------------------------------------------------------*/
function J2SType(node, env) {
   if (!node || !node.kind) {
      return J2SSymbol("unknown");
   } else {
      switch (node.kind) {
      	 case ts.SyntaxKind.AnyKeyword:
      	 case ts.SyntaxKind.UnknownKeyword:
	    return J2SSymbol("any");
      	 case ts.SyntaxKind.VoidKeyword:
      	 case ts.SyntaxKind.UndefinedKeyword:
	    return J2SSymbol("undefined");
      	 case ts.SyntaxKind.NumberKeyword:
	    return J2SSymbol("number");
      	 case ts.SyntaxKind.StringKeyword:
	    return J2SSymbol("string");
      	 case ts.SyntaxKind.BooleanKeyword:
	    return J2SSymbol("bool");
      	 case ts.SyntaxKind.ParenthesizedType:
	    return J2SType(node.type, env);
	 case ts.SyntaxKind.ArrayType:
	    return J2SSymbol("array");
      	 case ts.SyntaxKind.TypeLiteral:
	    return J2SSymbol("object");
      	 case ts.SyntaxKind.UnionType:
	    return J2SSymbol("object");
      	 case ts.SyntaxKind.FunctionType:
	    return J2SSymbol("function");
      	 case ts.SyntaxKind.TypeReference:
	    return J2SSymbol(typeToString(node.typeName));
      	 case ts.SyntaxKind.VariableDeclaration:
	    return J2SType(node.type, env);
      	 default:
	    parseError(`Unsupported type (${ts.SyntaxKind[node.kind]})`, node, env);
	    return J2SSymbol(`unknown`);
      }
   }
}

/*---------------------------------------------------------------------*/
/*    J2SHint ...                                                      */
/*---------------------------------------------------------------------*/
function J2SHint(node, env) {
   const ty = J2SType(node, env);
   
   if (ty.__symbol__ !== "any" && ty.__symbol__ !== "unknown") {
      return [{ __car__: ty, __cdr__: 100000 }];
   } else {
      return null;
   }
}
   
/*---------------------------------------------------------------------*/
/*    J2SIdent ...                                                     */
/*---------------------------------------------------------------------*/
function J2SIdent(node, env, scope) {
   switch (node.kind) {
      case ts.SyntaxKind.Identifier:
	 return J2SSymbol(node.escapedText);
      default:
	 parseError(`Unsupported ident (${ts.SyntaxKind[node.kind]})`, node, env);
	 return J2SSymbol(`/* unknown ident ${ts.SyntaxKind[node.kind]} ${J2SLoc(node, env)}*/_`);
   }
}

/*---------------------------------------------------------------------*/
/*    J2SUndefined ...                                                 */
/*---------------------------------------------------------------------*/
function J2SUndefined(node, env, scope) {
   return new hopc.J2SUndefined(J2SLoc(node, env), // loc
      J2SSymbol("undefined"), // type
      null, // hint
      undefined); // range
}

/*---------------------------------------------------------------------*/
/*    J2SString ...                                                    */
/*---------------------------------------------------------------------*/
function J2SString(node, val, env, scope) {
   return new hopc.J2SString(J2SLoc(node, env), // loc
      J2SSymbol("string"), // type
      null, // hint
      undefined, // range
      val, // value
      null, //escape
      false); // private
}

/*---------------------------------------------------------------------*/
/*    J2SPropName ...                                                  */
/*---------------------------------------------------------------------*/
function J2SPropName(node, env, scope) {
   switch (node.kind) {
      case ts.SyntaxKind.Identifier:
      case ts.SyntaxKind.PrivateIdentifier:
	 return J2SString(node, node.escapedText, env, scope);
	 
      case ts.SyntaxKind.StringLiteral:
	 return J2SString(node, node.text, env, scope);
	 
      default:
	 return J2SSymbol(`/* unknown name "${node.text}" ${ts.SyntaxKind[node.kind]}@${J2SLoc(node, env)} */_`);
   }
}

/*---------------------------------------------------------------------*/
/*    J2SOperator ...                                                  */
/*---------------------------------------------------------------------*/
function J2SOperator(node, env, scope) {
   switch (node.kind) {
      case ts.SyntaxKind.BarToken: 
	 return J2SSymbol("BIT_OR");
	 
      case ts.SyntaxKind.AmpersandToken: 
	 return J2SSymbol("&");
	 
      case ts.SyntaxKind.CaretToken: 
	 return J2SSymbol("^");
	 
      case ts.SyntaxKind.PlusToken: 
	 return J2SSymbol("+");
	 
      case ts.SyntaxKind.MinusToken: 
	 return J2SSymbol("-");
	 
      case ts.SyntaxKind.AsteriskToken: 
	 return J2SSymbol("*");
	 
      case ts.SyntaxKind.SlashToken: 
	 return J2SSymbol("/");
	 
      case ts.SyntaxKind.PercentToken: 
	 return J2SSymbol("%");
	 
      case ts.SyntaxKind.GreaterThanToken: 
	 return J2SSymbol(">");
	 
      case ts.SyntaxKind.GreaterThanEqualsToken: 
	 return J2SSymbol(">=");
	 
      case ts.SyntaxKind.GreaterThanGreaterThanToken: 
	 return J2SSymbol(">>");
	 
      case ts.SyntaxKind.FirstBinaryOperator:
	 return J2SSymbol("<");
	 
      case ts.SyntaxKind.LessThanEqualsToken:
	 return J2SSymbol("<=");
	 
      case ts.SyntaxKind.LessThanLessThanToken:
	 return J2SSymbol("<<");
	 
      case ts.SyntaxKind.FirstCompoundAssignment:
	 return J2SSymbol("+");
	 
      case ts.SyntaxKind.AmpersandAmpersandToken:
	 return J2SSymbol("&&");
	 
      case ts.SyntaxKind.BarBarToken:
	 return J2SSymbol("OR");
	 
      case ts.SyntaxKind.EqualsEqualsToken:
	 return J2SSymbol("==");
	 
      case ts.SyntaxKind.EqualsEqualsEqualsToken:
	 return J2SSymbol("===");
	 
      case ts.SyntaxKind.ExclamationEqualsToken:
	 return J2SSymbol("!=");
	 
      case ts.SyntaxKind.ExclamationEqualsEqualsToken:
	 return J2SSymbol("!==");
	 
      case ts.SyntaxKind.InKeyword:
	 return J2SSymbol("in");
	 
      case ts.SyntaxKind.InstanceOfKeyword:
	 return J2SSymbol("instanceof");
	 
      case ts.SyntaxKind.BarEqualsToken:
	 return J2SSymbol("BIT_OR");
	 
      case ts.SyntaxKind.CaretEqualsToken:
	 return J2SSymbol("^");
	 
      case ts.SyntaxKind.AmpersandEqualsToken:
	 return J2SSymbol("&");
	 
      default:
	 parseError(`Unsupported operator "${node.getText()}" (${ts.SyntaxKind[node.kind]})`, node, env);
	 return J2SSymbol(`/* unknown operator "${node.getText()}" ${ts.SyntaxKind[node.kind]}@${J2SLoc(node, env)} */_`);
   }
}

/*---------------------------------------------------------------------*/
/*    J2SUnary ...                                                     */
/*---------------------------------------------------------------------*/
function J2SUnary(node, env, scope) {
   switch (node.operator) {
      case 40: // - operator
	 if (node.operand.kind === ts.SyntaxKind.NumericLiteral) {
	    const val = Number.parseFloat(node.operand.text);
	    return new hopc.J2SNumber(J2SLoc(node, env), // loc
	       J2SSymbol(Number.isInteger(val) ? "integer" : "number"), // type
	       null, // hint
	       undefined, // range
	       -val); //val
	 } else {
	    return new hopc.J2SUnary(J2SLoc(node, env), // loc
	       TCType(node, env.typechecker), // type
	       null, // hint
	       undefined, // range
	       J2SSymbol("-"), // op
	       J2SExpr(node.operand, env, scope)); // expression
	 }
      case 45: // ++ operator
	 return J2SPostPrefix(node, env, scope, hopc.J2SPrefix);
      case 53: // ! operator
	 return new hopc.J2SUnary(J2SLoc(node, env), // loc
	    TCType(node, env.typechecker), // type
	    null, // hint
	    undefined, // range
	    J2SSymbol("!"), // op
	    J2SExpr(node.operand, env, scope)); // expression
      case 54: // ~ operator
	 return new hopc.J2SUnary(J2SLoc(node, env), // loc
	    TCType(node, env.typechecker), // type
	    null, // hint
	    undefined, // range
	    J2SSymbol("~"), // op
	    J2SExpr(node.operand, env, scope)); // expression
      default:
	 parseError(`Unsupported unary expression "${node.getText()}" (${ts.SyntaxKind[node.kind]})`, node, env);
	 console.error("J2SUnary unkown expression", node);
   }
}
      
/*---------------------------------------------------------------------*/
/*    J2SBinary ...                                                    */
/*---------------------------------------------------------------------*/
function J2SBinary(node, env, scope) {
   switch (node.operatorToken.kind) {
      case ts.SyntaxKind.FirstAssignment:
      	 return new hopc.J2SAssig(J2SLoc(node, env), // loc
	    TCType(node, env.typechecker), // type
	    null, // hint
	    undefined, // range
	    J2SExpr(node.left, env, scope), // left
	    J2SExpr(node.right, env, scope)); // right
	 
      case ts.SyntaxKind.FirstCompoundAssignment:
      	 return new hopc.J2SAssigOp(J2SLoc(node, env), // loc
	    TCType(node, env.typechecker), // type
	    null, // hint
	    undefined, // range
	    J2SExpr(node.left, env, scope), // left
	    J2SExpr(node.right, env, scope), // right
	    J2SOperator(node.operatorToken, env, scope));
	 
      default:
      	 return new hopc.J2SBinary(J2SLoc(node, env), // loc
	    TCType(node, env.typechecker), // type
	    null, // hint
	    undefined, // range
	    J2SOperator(node.operatorToken, env, scope), // op
	    J2SExpr(node.left, env, scope), // left
	    J2SExpr(node.right, env, scope)); // right
   }
}

/*---------------------------------------------------------------------*/
/*    J2SPostPrefix ...                                                */
/*---------------------------------------------------------------------*/
function J2SPostPrefix(node, env, scope, ctor) {
   let op = undefined;
   
   switch (node.operator) {
      case 45: // ++
	 op = J2SSymbol("++");
	 break;

      case 46: // --
	 op = J2SSymbol("--");
	 break;

      default:
	 parseError(`Unsupported prefix expression "${node.getText()}" (${ts.SyntaxKind[node.kind]})`, node, env);
	 console.error(`J2SPostPrefix unkown expression ${node.operator}`, node);
   }
   
   const loc = J2SLoc(node, env);
   const lhs = J2SExpr(node.operand, env, scope);
   const rhs = new hopc.J2SBinary(loc, // loc
      TCType(node, env.typechecker), // type
      null, // hint
      undefined, // range
      op, // operator
      J2SExpr(node.operand, env, scope), // lhs
      new hopc.J2SNumber(loc, 
	 J2SSymbol("integer"), // type
	 null, // hint
	 undefined, // range
	 1)); //val
   
   return new ctor(loc, // loc
      TCType(node, env.typechecker), // type
      null, // hint
      undefined, // range
      lhs, // lhs
      rhs, // rhs
      op); // op
}
      
/*---------------------------------------------------------------------*/
/*    J2SFunBody ...                                                   */
/*---------------------------------------------------------------------*/
function J2SFunBody(body, params, env, scope) {
   const inits = params.filter(n => n.initializer)
      .map(n => {
	 const loc = J2SLoc(n, env);
	 const left = new hopc.J2SUnresolvedRef(
	    loc,
	    J2SSymbol("any"), // type
	    null, // hint
	    undefined, // range
	    false, // cache
	    J2SIdent(n.name, env, scope));
	 const assig = new hopc.J2SUnresolvedRef(
	    loc,
	    J2SSymbol("any"), // type
	    null, // hint
	    undefined, // range
	    false, // cache
	    J2SIdent(n.name, env, scope));
	 const right = new hopc.J2SUndefined(
	    loc, // loc
	    J2SSymbol("undefined"), // type
	    null, // hint
	    undefined); // range
	 const test = new hopc.J2SBinary(
	       loc, //loc
	       J2SSymbol("bool"), // type
	       null, // hint
	       undefined, // range
	       J2SSymbol("==="), // op
	       left, // left
	    right);
	 const then = new hopc.J2SAssig(
	    loc, // loc
	    J2SSymbol("unknown"), // type
	    null, // hint
	    undefined, // range
	    assig, // left
	    J2SExpr(n.initializer, env, scope)); // right
	 return new hopc.J2SCond(
	    loc, // loc
	    J2SSymbol("unknown"), // type
	    null, // hint
	    undefined, // range
	    test, // test
	    then, // then
	    new J2SUndefined(n, env, scope)); // _else
      });

   if (inits.length == 0) {
      return body;
   } else {
      const loc = J2SLoc(body, env);
      const decl = new hopc.J2SDeclInit(
	 loc, // loc
	 J2SSymbol("%inits"), // id
	 false,  // _scmid
      	 J2SKey(), // key
      	 false, // writable
      	 J2SSymbol("local"), // scope
      	 0, // usecnt
      	 false, // useinloop
      	 false, // escape
      	 0, // usage
      	 J2SSymbol("let"), // binder
      	 J2SSymbol("any"), // ctype
      	 J2SSymbol("any"), // utype
      	 J2SType(undefined, env), // itype
      	 J2SType(undefined, env), // vtype
      	 J2SType(undefined, env), // mtype
      	 undefined, // irange
      	 undefined, // vrange
      	 null, // hint
      	 false,
 	 new hopc.J2SSequence(
	    loc, // loc
	    J2SSymbol("any"), // type
      	    null, // hint
	    undefined, // range
	    inits));
      if (body.nodes[0] instanceof hopc.J2SVarDecls) {
	 const vdecls = body.nodes[0];
	 vdecls.decls = [ decl ].concat(vdecls.decls);
      } else {
	 const vdecls = new hopc.J2SVarDecls(loc, [ decl ]);
	 body.nodes = [ vdecls ].concat(body.nodes);
      }
      return body;
   }
}

/*---------------------------------------------------------------------*/
/*    J2SFunThis ...                                                   */
/*---------------------------------------------------------------------*/
function J2SFunThis(node, env, scope, thisp, body) {
   return new hopc.J2SFun(J2SLoc(node, env), // loc
      J2SSymbol("function"), // type
      null, // hint
      undefined, // range
      J2SSymbol("unknown"), // rtype
      node.type ? J2SType(node.type, env) : J2SSymbol("unknown"), // rutype
      undefined, // rrange
      J2SSymbol("this"), // idthis
      false, // idgen
      J2SSymbol("typescript"), // mode
      false, // decl
      false, // need-bind-exit-return
      J2SSymbol("unknown"), // new-target
      false, // vararg
      node.name ? J2SIdent(node.name, env, scope) : J2SSymbol("fun"), // name
      false, // generator
      true, // optimize
      thisp, // thisp
      false, // argumentsp
      node?.parameters.map(p => J2SParam(p, env, scope)) ?? [], // params
      3, // constrsize
      true, // src
      false, // method
      false, // ismethodof
      J2SFunBody(body, node?.parameters ?? [], env, scope)); // body
}

/*---------------------------------------------------------------------*/
/*    J2SFunGen ...                                                    */
/*---------------------------------------------------------------------*/
function J2SFunGen(node, env, scope, thisp, body) {
   return new hopc.J2SFun(J2SLoc(node, env), // loc
      J2SSymbol("function"), // type
      null, // hint
      undefined, // range
      J2SSymbol("unknown"), // rtype
      node.type ? J2SType(node.type, env) : J2SSymbol("unknown"), // rutype
      undefined, // rrange
      J2SSymbol("this"), // idthis
      false, // idgen
      J2SSymbol("strict"), // mode
      false, // decl
      false, // need-bind-exit-return
      J2SSymbol("unknown"), // new-target
      false, // vararg
      node.name ? J2SSymbol(node.name.escapedText + "*") : J2SSymbol("fun*"), // name
      true, // generator
      true, // optimize
      thisp, // thisp
      false, // argumentsp
      [], // params
      3, // constrsize
      true, // src
      false, // method
      false, // ismethodof
      body); // body
}

/*---------------------------------------------------------------------*/
/*    J2SAsync ...                                                     */
/*---------------------------------------------------------------------*/
function J2SAsync(node, env, scope, thisp, body) {
   const gen = J2SFunGen(node, env, scope, thisp, body);
   const loc = J2SLoc(node, env);
   const endloc = J2SEndloc(node, env);
   const jsspawn = new hopc.J2SHopRef(loc, // loc
      J2SSymbol("any"), // type
      null, // hint
      undefined, // range
      J2SSymbol("js-spawn"),
      J2SSymbol("any"), // rtype
      false); // module
   const thisa = new hopc.J2SUnresolvedRef(loc, // loc
      J2SSymbol("any"), // type
      null, // hint
      undefined, // range
      false, // cache
      J2SSymbol("this"));
   const _thisa = new hopc.J2SHopRef(loc, // loc
      J2SSymbol("object"), // type
      null, // hint
      undefined, // range
      J2SSymbol("%this"),
      J2SSymbol("object"), // rtype
      false); // module
   const expr = new hopc.J2SCall(loc, // loc
      J2SSymbol("any"), // type
      null, // hint
      undefined, // range
      -1, // profid
      jsspawn, // fun
      J2SSymbol("direct"), // protocol
      [], //thisarg
      [ gen, thisa, _thisa ]); // args
   const ret = new hopc.J2SReturn(loc, // loc
      false, // exit
      true, // tail
      undefined, // from
      expr);
   const fbody = new hopc.J2SBlock(loc, [ ret ], endloc);
   
   return J2SFunThis(node, env, scope, thisp, fbody);
}

/*---------------------------------------------------------------------*/
/*    J2SFun ...                                                       */
/*---------------------------------------------------------------------*/
function J2SFun(node, env, scope) {
   const thisp = J2SDeclThis(node, env, scope);
   const body = J2SBlock(node.body, env, scope);
   
   if (asyncFun(node)) {
      return J2SAsync(node, env, scope, thisp, body);
   } else { 
      return J2SFunThis(node, env, scope, thisp, body);
   }
}   

/*---------------------------------------------------------------------*/
/*    J2SArrow ...                                                     */
/*---------------------------------------------------------------------*/
function J2SArrow(node, env, scope) {
   if (node.body.kind === ts.SyntaxKind.Block) {
      const body = J2SBlock(node.body, env, scope);
      if (asyncFun(node)) {
      	 return J2SAsync(node, env, scope, false, body);
      } else {
      	 return J2SFunThis(node, env, scope, false, body);
      }
   } else {
      const loc = J2SLoc(node, env);
      const endloc = J2SEndloc(node, env)
      const expr = J2SExpr(node.body, env, scope);
      const ret = new hopc.J2SReturn(loc, // loc
      	 false, // exit
      	 true, // tail
      	 undefined, // from
      	 expr); // expr
      const body = new hopc.J2SBlock(loc, [ ret ], endloc);
      if (asyncFun(node)) {
      	 return J2SAsync(node, env, scope, false, body);
      } else {
      	 return J2SFunThis(node, env, scope, false, body);
      }
   }
}

/*---------------------------------------------------------------------*/
/*    J2SClassElement ...                                              */
/*---------------------------------------------------------------------*/
function J2SClassElement(node, env, scope) {
   
   function classElement(node, env, scope) {
      switch (node.kind) {
      	 case ts.SyntaxKind.MethodDeclaration: 
	    const mbody = J2SBlock(node.body, env, scope);
	    const met = J2SFunThis(node, env, "local", J2SDeclThis(node, env, scope), mbody);
	    return new hopc.J2SMethodPropertyInit(J2SLoc(node, env), // loc
	       J2SPropName(node.name, env, scope), // name
	       met, // val
	       false); // inlinecachevar
	    
	 case ts.SyntaxKind.PropertyDeclaration:
	    if (node.initializer) {
	       return new hopc.J2SDataPropertyInit(J2SLoc(node, env), // loc
	       	  J2SPropName(node.name, env, scope), // name
		  J2SExpr(node.initializer, env, scope)); // val
	    } else {
	       return new hopc.J2SPropertyInit(J2SLoc(node, env), // loc
	       	  J2SPropName(node.name, env, scope)); // name
	    }

	 case ts.SyntaxKind.Constructor:
	    const cbody = J2SBlock(node.body, env, scope);
	    const ctor = J2SFunThis(node, env, "local", J2SDeclThis(node, env, scope), cbody);
	    return new hopc.J2SMethodPropertyInit(J2SLoc(node, env), // loc
	       J2SString(node, "constructor", env, scope), // name
	       ctor, // val
	       false); // inlinecachevar
	    
	 default:
	    parseError(`Unsupported class property "${node.getText()}" (${ts.SyntaxKind[node.kind]})`, node, env);
	    return new hopc.J2SStmtExpr(J2SLoc(node, env), 
	       J2SUndefined(node, env, scope));
      }
   }
   
   const isStatic = node.modifiers?.find(m => m.kind === ts.SyntaxKind.StaticKeyword);
   
   return new hopc.J2SClassElement(J2SLoc(node, env), // loc
      isStatic ? true : false, // _static
      classElement(node, env, scope), // prop
      TCType(node, env.typechecker), // type
      undefined, // clazz
      -1, // index
      false, // rtwin
      0, // usage
      null); // hint
}

/*---------------------------------------------------------------------*/
/*    J2SClass ...                                                     */
/*---------------------------------------------------------------------*/
function J2SClass(node, env, scope, ctor) {
   let sup;
   
   if (node.heritageClauses) {
      const expr = node.heritageClauses[0].types[0].expression;
      sup = J2SExpr(expr, env, scope);
   } else {
      sup = J2SUndefined(node, env, scope);
   }
	
   const members = 
      node.members.filter(m => m.kind !== ts.SyntaxKind.SemicolonClassElement);
   
   return new ctor(J2SLoc(node, env), // loc
      J2SSymbol("unknown"), // type
      null, // hint
      undefined, // range
      J2SEndloc(node, env), // endloc
      J2SIdent(node.name, env, scope), // name
      false, // decl
      sup, // super
      true, // src
      members.map(m => J2SClassElement(m, env, scope)), // elements
      0, // constrsize
      false, // cmap
      false, // neded-super-check
      false, // need-dead-zone-check
      J2SUndefined(node, env, scope)); // methods
}

/*---------------------------------------------------------------------*/
/*    J2SCall ...                                                      */
/*---------------------------------------------------------------------*/
function J2SCall(node, env, scope) {
   return new hopc.J2SCall(J2SLoc(node, env), // loc
      TCType(node, env.typechecker), // type
      null, // hint
      undefined, // range
      -1, // profid
      J2SExpr(node.expression, env, scope), // fun
      J2SSymbol("direct"), // protocol
      [ J2SUndefined(node, env, scope) ], // thisarg
      node.arguments.map(n => J2SExpr(n, env, scope))); // args
}

/*---------------------------------------------------------------------*/
/*    J2SNew ...                                                       */
/*---------------------------------------------------------------------*/
function J2SNew(node, env, scope) {
   return new hopc.J2SNew(J2SLoc(node, env), // loc
      TCType(node, env.typechecker), // type
      null, // hint
      undefined, // range
      [], // caches
      J2SExpr(node.expression, env, scope), // clazz
      J2SSymbol("direct"), // protocol
      node.arguments.map(n => J2SExpr(n, env, scope))); // args
}

/*---------------------------------------------------------------------*/
/*    J2SInit ...                                                      */
/*---------------------------------------------------------------------*/
function J2SInit(node, env, scope) {
   switch (node.kind) {
      case ts.SyntaxKind.PropertyAssignment:
	 return new hopc.J2SDataPropertyInit(J2SLoc(node, env), // loc
 	    J2SPropName(node.name, env, scope), // name
	    J2SExpr(node.initializer, env, scope)); // val
	 
      case ts.SyntaxKind.GetAccessor:
	 return new hopc.J2SAccessorPropertyInit(J2SLoc(node, env), // loc
 	    J2SPropName(node.name, env, scope), // name
	    J2SFunThis(node, env, scope, // get
 	       J2SDeclThis(node, env, scope), 
 	       J2SBlock(node.body, env, scope)),
	    J2SUndefined(node, env, scope)); //set
	    
      case ts.SyntaxKind.SetAccessor:
	 return new hopc.J2SAccessorPropertyInit(J2SLoc(node, env), // loc
 	    J2SPropName(node.name, env, scope), // name
	    J2SUndefined(node, env, scope), // get
	    J2SFunThis(node, env, scope, // set
 	       J2SDeclThis(node, env, scope), 
 	       J2SBlock(node.body, env, scope)));
	 
      case ts.SyntaxKind.ShorthandPropertyAssignment:
	 const ref = new hopc.J2SUnresolvedRef(J2SLoc(node, env), // loc
	    J2SSymbol("unknown"), // type
	    null, // hint
	    undefined, // range
	    false, // cache
	    J2SIdent(node.name, env, scope));
	 return new hopc.J2SDataPropertyInit(J2SLoc(node, env), // loc
 	    J2SPropName(node.name, env, scope), // name
	    J2SExpr(node.name, env, scope)); // val
	 
      default:
	    parseError(`Unsupported init expression "${node.getText()}" (${ts.SyntaxKind[node.kind]})`, node, env);
	 return J2SSymbol(`/* unknown init ${ts.SyntaxKind[node.kind]}@${env.source}:${node.pos} */_`);
   }
}

/*---------------------------------------------------------------------*/
/*    J2STemplate ...                                                  */
/*---------------------------------------------------------------------*/
function J2STemplate(node, env, scope) {
   const exprs = [ J2SString(node.head, node.head.text, env, scope) ];

   node.templateSpans.forEach(s => {
	 exprs.push(J2SExpr(s.expression, env, scope));
	 if (s.literal.text !== "") { 
	    exprs.push(J2SString(s.literal, s.literal.text, env, scope));
	 }
      });
   
   return new hopc.J2STemplate(J2SLoc(node, env), // loc
      J2SSymbol("string"), // type
      null, // hint
      undefined, // range
      exprs); // exprs
}

/*---------------------------------------------------------------------*/
/*    J2SRegExp ...                                                    */
/*---------------------------------------------------------------------*/
function J2SRegExp(node, env, scope) {
   const text = node.getText();
   const regexp = text.match(/[/]([^/]*)[/]([igm]*)/);
   
   if (!regexp) {
      parseError(`Unsupported regexp "${node.getText()}" (${ts.SyntaxKind[node.kind]})`, node, env);
      console.error("J2SRegExp illegal regular expression", node);
   } else {
      return new hopc.J2SRegExp(J2SLoc(node, env), // loc
      	 J2SSymbol("regexp"), // type
      	 null, // hint
      	 undefined, // range
      	 regexp[1], // val
      	 regexp[2], // flags
      	 false); // inline
   }
}

/*---------------------------------------------------------------------*/
/*    J2SExpr ...                                                      */
/*---------------------------------------------------------------------*/
function J2SExpr(node, env, scope) {
   switch (node.kind) {
      case ts.SyntaxKind.BinaryExpression:
	 return J2SBinary(node, env, scope);
	 
      case ts.SyntaxKind.CallExpression:
	 return J2SCall(node, env, scope);
	 
      case ts.SyntaxKind.NewExpression:
	 return J2SNew(node, env, scope);
	 
      case ts.SyntaxKind.ElementAccessExpression:
	 return new hopc.J2SAccess(J2SLoc(node, env), // loc
	    TCType(node, env.typechecker), // type
	    null, // hint
	    undefined, // range
	    J2SExpr(node.expression, env, scope), // obj
	    J2SExpr(node.argumentExpression, env, scope)); // field
	 
      case ts.SyntaxKind.FunctionExpression:
	 return J2SFun(node, env, scope);
	 
      case ts.SyntaxKind.ArrowFunction:
	 return J2SArrow(node, env, scope);
	 
      case ts.SyntaxKind.Identifier:
	 return new hopc.J2SUnresolvedRef(J2SLoc(node, env), // loc
	    TCType(node, env.typechecker), // type
	    null, // hint
	    undefined, // range
	    false, // cache
	    J2SIdent(node, env, scope));

      case ts.SyntaxKind.ThisKeyword:
	 return new hopc.J2SUnresolvedRef(J2SLoc(node, env), // loc
	    TCType(node, env.typechecker), // type
	    null, // hint
	    undefined, // range
	    false, // cache
	    J2SSymbol("this"));

      case ts.SyntaxKind.SuperKeyword:
	 return new hopc.J2SUnresolvedRef(J2SLoc(node, env), // loc
	    TCType(node, env.typechecker), // type
	    null, // hint
	    undefined, // range
	    false, // cache
	    J2SSymbol("super"));

      case ts.SyntaxKind.NumericLiteral:
	 const val = Number.parseFloat(node.text);
	 return new hopc.J2SNumber(J2SLoc(node, env), // loc
	    J2SSymbol(Number.isInteger(val) ? "integer" : "number"), // type
	    null, // hint
	    undefined, // range
	    val); //val
	 
      case ts.SyntaxKind.ObjectLiteralExpression:
	 return new hopc.J2SObjInit(J2SLoc(node, env), // loc
	    TCType(node, env.typechecker), // type
	    null, // hint
	    undefined, // range
	    node.properties.map(n => J2SInit(n, env, scope)), // inits
	    false, // cmap
	    false); // ronly
	 
      case ts.SyntaxKind.ArrayLiteralExpression:
	 return new hopc.J2SArray(J2SLoc(node, env), // loc
	    TCType(node, env.typechecker), // type
	    null, // hint
	    undefined, // range
	    node.elements.length, // len
	    node.elements.map(n => J2SExpr(n, env, scope))); // exprs
	 
      case ts.SyntaxKind.RegularExpressionLiteral:
	 return J2SRegExp(node, env, scope);
	 
      case ts.SyntaxKind.PropertyAccessExpression:
	 if (node.questionDotToken) {
	    const expr = new hopc.J2SUnary(J2SLoc(node, env), // loc
	       J2SSymbol("unknown"), // type
	       null, // hint
	       undefined, // range
	       J2SSymbol("?."), // op
	       J2SExpr(node.expression, env, scope)); // expression
	    return new hopc.J2SAccess(J2SLoc(node, env), // loc
	       TCType(node, env.typechecker), // type
	       null, // hint
	       undefined, // range
	       expr, // obj
	       J2SString(node.name, node.name.escapedText, env, scope)) // field
	 } else {
	    return new hopc.J2SAccess(J2SLoc(node, env), // loc
	       TCType(node, env.typechecker), // type
	       null, // hint
	       undefined, // range
	       J2SExpr(node.expression, env, scope), // obj
	       J2SString(node.name, node.name.escapedText, env, scope)); // field
	 }
	 
      case ts.SyntaxKind.ParenthesizedExpression:
	 return new hopc.J2SParen(J2SLoc(node, env), // loc
	    TCType(node, env.typechecker), // type
	    null, // hint
	    undefined, // range
	    J2SExpr(node.expression, env, scope)); // expression
	 
      case ts.SyntaxKind.StringLiteral:
	 return J2SString(node, node.text, env, scope);
	 
      case ts.SyntaxKind.FirstTemplateToken:
	 return new hopc.J2STemplate(J2SLoc(node, env), // loc
	    J2SSymbol("string"), // type
	    null, // hint
	    undefined, // range
	    [ J2SString(node, node.text, env, scope) ]); // exprs
	 
      case ts.SyntaxKind.TemplateExpression:
	 return J2STemplate(node, env, scope);
	 
      case ts.SyntaxKind.TrueKeyword:
	 return new hopc.J2SBool(J2SLoc(node, env), // loc
	    J2SSymbol("bool"), // type
	    null, // hint
	    undefined, // range
	    true); // val
	 
      case ts.SyntaxKind.FalseKeyword:
	 return new hopc.J2SBool(J2SLoc(node, env), // loc
	    J2SSymbol("bool"), // type
	    null, // hint
	    undefined, // range
	    false); // val
	 
      case ts.SyntaxKind.TypeOfExpression:
	 return new hopc.J2SUnary(J2SLoc(node, env), // loc
	    J2SSymbol("string"), // type
	    null, // hint
	    undefined, // range
	    J2SSymbol("typeof"), // op
	    J2SExpr(node.expression, env, scope)); // expression
	 
      case ts.SyntaxKind.ConditionalExpression:
	 return new hopc.J2SCond(J2SLoc(node, env), // loc
	    J2SSymbol("unknown"), // type
	    null, // hint
	    undefined, // range
	    J2SExpr(node.condition, env, scope), // test
	    J2SExpr(node.whenTrue, env, scope), // then
	    J2SExpr(node.whenFalse, env, scope)); // else

      case ts.SyntaxKind.PrefixUnaryExpression:
	 return J2SUnary(node, env, scope);
	 
      case ts.SyntaxKind.PostfixUnaryExpression:
	 return J2SPostPrefix(node, env, scope, hopc.J2SPostfix);
	 
      case ts.SyntaxKind.AwaitExpression:
	 return new hopc.J2SYield(J2SLoc(node, env), // loc
	    J2SSymbol("unknown"), // type
	    null, // hint
	    undefined, // range
	    J2SExpr(node.expression, env, scope), // expression
	    false, // generator
	    true); // _await
	 
      case ts.SyntaxKind.Undefined:
	 return J2SUndefined(node, env, scope);
	 
      case ts.SyntaxKind.NullKeyword: 
	 return new hopc.J2SNull(J2SLoc(node, env), // loc
      	    J2SSymbol("null"), // type
      	    null, // hint
      	    undefined); // range
	 
      case ts.SyntaxKind.StringKeyword: 
	 return new hopc.J2SUnresolvedRef(J2SLoc(node, env), // loc
	    J2SSymbol("unknown"), // type
	    null, // hint
	    undefined, // range
	    false, // cache
	    J2SSymbol("string"));
	 
      case ts.SyntaxKind.AsExpression:
	 return J2SExpr(node.expression, env, scope);
/* 	 return new hopc.J2SBinary(J2SLoc(node, env), // loc           */
/* 	    J2SSymbol("unknown"), // type                              */
/* 	    null, // hint                                              */
/* 	    undefined, // range                                        */
/* 	    J2SSymbol("as"), // op                                     */
/* 	    J2SExpr(node.expression, env, scope), // left              */
/* 	    J2SType(node.type, env, scope)); // right                  */
	 
      case ts.SyntaxKind.TypeReference:
	 return new hopc.J2SUnresolvedRef(J2SLoc(node, env), // loc
	    J2SSymbol("unknown"), // type
	    null, // hint
	    undefined, // range
	    false, // cache
	    J2SSymbol(typeToString(node.typeName)));
	 
      default:
         parseError(`Unsupported expression "${node.getText()}" (${ts.SyntaxKind[node.kind]})`, node, env);
	 return J2SUndefined(node, env, scope);
   }
}

/*---------------------------------------------------------------------*/
/*    J2SBlock ...                                                     */
/*---------------------------------------------------------------------*/
function J2SBlock(node, env, scope) {
   return new hopc.J2SBlock(J2SLoc(node, env), // loc
      node.statements.map(s => J2SStmt(s, env, scope)), // nodes
      J2SEndloc(node, env)); // endloc
}

/*---------------------------------------------------------------------*/
/*    J2SStmtExpr ...                                                  */
/*---------------------------------------------------------------------*/
function J2SStmtExpr(node, env, scope) {
   return new hopc.J2SStmtExpr(J2SLoc(node, env), // loc
      J2SExpr(node.expression, env, scope));
}

/*---------------------------------------------------------------------*/
/*    J2SVarDecls ...                                                  */
/*---------------------------------------------------------------------*/
function J2SVarDecls(node, env, scope) {
   return J2SVarDeclList(node.declarationList, env, scope);
}

/*---------------------------------------------------------------------*/
/*    J2SReturn ...                                                    */
/*---------------------------------------------------------------------*/
function J2SReturn(node, env, scope) {
   const expr = node.expression 
      ? J2SExpr(node.expression, env, scope)
      : J2SUndefined(node, env, scope);
   return new hopc.J2SReturn(J2SLoc(node, env), // loc
      false, // exit
      true, // tail
      undefined, // from
      expr); // expr
}

/*---------------------------------------------------------------------*/
/*    J2SDecl ...                                                      */
/*---------------------------------------------------------------------*/
function J2SDecl(node, env, scope) { 
   return new hopc.J2SDecl(J2SLoc(node, env), // loc
      J2SIdent(node.name, env, scope), // id
      false, // _scmid
      J2SKey(), // key
      true, // writable
      J2SSymbol("local"), // scope
      0, // usecnt
      false, // useinloop
      false, // escape
      0, // usage
      J2SSymbol("param"), // binder
      J2SType(node, env), // utype
      J2SType(undefined, env), // itype
      J2SType(undefined, env), // vtype
      J2SType(undefined, env), // mtype
      undefined, // irange
      undefined, // vrange
      null, // hint
      false); // export
}

/*---------------------------------------------------------------------*/
/*    J2SParam ...                                                     */
/*---------------------------------------------------------------------*/
function J2SParam(node, env, scope) { 
   if (node.initializer) {
      return new hopc.J2SDeclInit(J2SLoc(node, env), // loc
      	 J2SIdent(node.name, env, scope), // id
      	 false, // _scmid
      	 J2SKey(), // key
      	 true, // writable
      	 J2SSymbol("local"), // scope
      	 0, // usecnt
      	 false, // useinloop
      	 false, // escape
      	 0, // usage
      	 J2SSymbol("param"), // binder
      	 J2SSymbol("any"), // ctype
      	 J2SSymbol("any"), // utype
      	 J2SType(undefined, env), // itype
      	 J2SType(undefined, env), // vtype
      	 J2SType(undefined, env), // mtype
      	 undefined, // irange
      	 undefined, // vrange
      	 null, // hint
      	 false,
 	 J2SExpr(node.initializer, env, scope)); // export
   } else {
      return new hopc.J2SDecl(J2SLoc(node, env), // loc
      	 J2SIdent(node.name, env, scope), // id
      	 false, // _scmid
      	 J2SKey(), // key
      	 true, // writable
      	 J2SSymbol("local"), // scope
      	 0, // usecnt
      	 false, // useinloop
      	 false, // escape
      	 0, // usage
      	 J2SSymbol("param"), // binder
      	 J2SSymbol("any"), // ctype
      	 node.questionToken ? J2SSymbol("any") : J2SType(node.type, env), // utype
      	 J2SType(undefined, env), // itype
      	 J2SType(undefined, env), // vtype
      	 J2SType(undefined, env), // mtype
      	 undefined, // irange
      	 undefined, // vrange
      	 null, // hint
      	 false); // export
   }
}

/*---------------------------------------------------------------------*/
/*    J2SDeclThis ...                                                  */
/*---------------------------------------------------------------------*/
function J2SDeclThis(node, env, scope) { 
   return new hopc.J2SDecl(J2SLoc(node, env), // loc
      J2SSymbol("this"), // id
      J2SSymbol("this"), // _scmid
      J2SKey(), // key
      true, // writable
      J2SSymbol("local"), // scope
      0, // usecnt
      false, // useinloop
      false, // escape
      0, // usage
      J2SSymbol("var"), // binder
      J2SSymbol("any"), // ctype
      J2SType(undefined, env), // utype
      J2SType(undefined, env), // itype
      J2SType(undefined, env), // vtype
      J2SType(undefined, env), // mtype
      undefined, // irange
      undefined, // vrange
      null, // hint
      false); // export
}

/*---------------------------------------------------------------------*/
/*    J2SDeclExport ...                                                */
/*---------------------------------------------------------------------*/
function J2SDeclExport(node, env, scope) {
   
   function J2SExportName(node) {
      const id = J2SIdent(node.name, env, scope);
      const alias = node.propertyName && J2SIdent(node.propertyName, env, scope);
      return new hopc.J2SExport(J2SLoc(node, env), // loc
	 id, // id
	 alias || id); // alias
   }
   
   switch (node.exportClause.kind) {
      case ts.SyntaxKind.NamedExports:
	 return node.exportClause.elements.map(J2SExportName);
      default:
         parseError(`Unsupported export "${node.getText()}" (${ts.SyntaxKind[node.kind]})`, node, env);
	 console.error("J2SDeclExport unimplemented statement", 
	    ts.SyntaxKind[ node.kind ], J2SLoc(node, env));
   }
}
   
/*---------------------------------------------------------------------*/
/*    J2SDeclFun ...                                                   */
/*---------------------------------------------------------------------*/
function J2SDeclFun(node, env, scope) {
   return new hopc.J2SDeclFun(J2SLoc(node, env),  // loc
      J2SIdent(node.name, env, scope), // id
      false, // _scmid
      J2SKey(), // key
      false, // writable
      J2SSymbol("global"), // scope
      0, // usecnt
      false, // useinloop
      false, // escape
      0, // usage
      J2SSymbol("var"), // binder
      J2SSymbol("any"), // ctype
      J2SSymbol("function"), // utype
      J2SSymbol("function"), // itype
      J2SSymbol("function"), // vtype
      J2SType(undefined, env), // mtype
      undefined, // irange
      undefined, // vrange
      null, // hint
      false, // export
      J2SFun(node, env, "local"), // val
      false); // expression
}
   
/*---------------------------------------------------------------------*/
/*    J2SDeclMet ...                                                   */
/*---------------------------------------------------------------------*/
function J2SDeclMet(node, env, scope) {
   return new hopc.J2SDeclFun(J2SLoc(node, env),  // loc
      J2SIdent(node.name, env, scope), // name 
      false, // _scmid
      J2SKey(), // key
      false, // writable
      J2SSymbol("global"), // scope
      0, // usecnt
      false, // useinloop
      false, // escape
      0, // usage
      J2SSymbol("var"), // binder
      J2SSymbol("any"), // ctype
      J2SSymbol("function"), // utype
      J2SSymbol("function"), // itype
      J2SSymbol("function"), // vtype
      J2SType(undefined, env), // mtype
      undefined, // irange
      undefined, // vrange
      null, // hint
      false, // export
      J2SFunThis(node, env, "local"), // val
      false); // expression
}
   
/*---------------------------------------------------------------------*/
/*    J2SDeclClass ...                                                 */
/*---------------------------------------------------------------------*/
function J2SDeclClass(node, env, scope) {
   
   function isRecordByComment(node) {
      const text = node.getFullText();
      return text.match(/[/][/][ \t]*@sealed[ \t]*\n[ \t]*class /m);
   }
   
   function isRecordByDecorator(node) {
      return node.decorators?.find(e => e?.expression?.escapedText === "sealed");
   }
   
   const isRecord = isRecordByComment(node) || isRecordByDecorator(node);
   const binder = isRecord ? "let-opt" : "let";
   const ctor = isRecord ? hopc.J2SRecord : hopc.J2SClass;
   const clazz = J2SClass(node, env, "local", ctor);

   const clazzdecl = new hopc.J2SDeclClass(J2SLoc(node, env),  // loc
      J2SIdent(node.name, env, scope), // id 
      false, // _scmid
      J2SKey(), // key
      false, // writable
      J2SSymbol("global"), // scope
      0, // usecnt
      false, // useinloop
      false, // escape
      0, // usage
      J2SSymbol(binder), // binder
      J2SSymbol("any"), // ctype
      J2SSymbol("unknown"), // utype
      J2SSymbol("unknown"), // itype
      J2SSymbol("unknown"), // vtype
      J2SSymbol("unknown"), // mtype
      undefined, // irange
      undefined, // vrange
      null, // hint
      false, // export
      clazz); // val
   
   clazz.decl = clazzdecl;
   return new hopc.J2SVarDecls(J2SLoc(node, env), [ clazzdecl ]);
}

/*---------------------------------------------------------------------*/
/*    J2SBindingElement ...                                            */
/*---------------------------------------------------------------------*/
function J2SBindingElement(node, decl, env, scope) {
   const ref = new hopc.J2SRef(
      J2SLoc(node, env), // loc
      J2SSymbol("unknown"), // type
      null, // hint
      undefined, // range
      decl);
   const field = new hopc.J2SString(J2SLoc(node, env), // loc
      J2SSymbol("string"), // type
      null, // hint
      undefined, // range
      node.getText(), // value
      null, //escape
      false); // private
   const axs = new hopc.J2SAccess(
      J2SLoc(node, env), // loc
      J2SSymbol("unknown"), // type
      null, // hint
      undefined, // range
      ref, // obj
      field); // field
   const expr = new hopc.J2SDConsumer(
      J2SLoc(node, env),  // loc
      J2SSymbol("unknown"), // type
      null, // hint
      undefined, // range
      decl, // decl
      axs, // expr
      ["get", J2SSymbol("*"), field]); // path
      
   return new hopc.J2SDeclInit(
      J2SLoc(node, env),  // loc
      J2SIdent(node.name, env, scope), // id 
      false, // _scmid
      J2SKey(), // key
      true, // writable
      J2SSymbol(scope), // scope
      0, // usecnt
      false, // useinloop
      false, // escape
      0, // usage
      J2SSymbol("let"), // binder
      J2SSymbol("unknown"), // ctype
      J2SSymbol("unknown"), // ctype
      J2SType(undefined, env), // itype
      J2SType(undefined, env), // vtype
      J2SType(undefined, env), // mtype
      undefined, // irange
      undefined, // vrange
      null, // hint
      false, // export
      expr); // expr
}

/*---------------------------------------------------------------------*/
/*    J2SDeclVar ...                                                   */
/*---------------------------------------------------------------------*/
function J2SDeclVar(node, env, scope) {
   if (node.name.kind === ts.SyntaxKind.ObjectBindingPattern) {
      // MS: 14dec2022, this is a partial implementation that needs to
      // be completed.
      const decl = new hopc.J2SDeclInit(J2SLoc(node, env),  // loc
      	 J2SSymbol("%obj"), // id 
      	 false, // _scmid
      	 J2SKey(), // key
      	 true, // writable
      	 J2SSymbol(scope), // scope
      	 0, // usecnt
      	 false, // useinloop
      	 false, // escape
      	 0, // usage
      	 J2SSymbol("let"), // binder
      	 J2SSymbol("any"), // ctype
      	 J2SType(undefined, env), // utype
      	 J2SType(undefined, env), // itype
      	 J2SType(undefined, env), // vtype
      	 J2SType(undefined, env), // mtype
      	 undefined, // irange
      	 undefined, // vrange
      	 null, // hint
      	 false, // export
      	 undefined); // val
      const prod = new hopc.J2SDProducer(J2SLoc(node, env),  // loc
      	 J2SType("object", env), // type
         null, // hint
      	 undefined, // range
      decl,
      J2SExpr(node.initializer, env, scope),
      -1); // size
      decl.val = prod;
      return [decl].concat(node.name.elements.map(n => J2SBindingElement(n, decl, env, scope)));
   } else if (node.initializer) {
      return [new hopc.J2SDeclInit(J2SLoc(node, env),  // loc
      	 J2SIdent(node.name, env, scope), // id 
      	 false, // _scmid
      	 J2SKey(), // key
      	 true, // writable
      	 J2SSymbol(scope), // scope
      	 0, // usecnt
      	 false, // useinloop
      	 false, // escape
      	 0, // usage
      	 J2SSymbol("let"), // binder
      	 J2SSymbol("any"), // ctype
      	 J2SType(node, env), // utype
      	 J2SType(undefined, env), // itype
      	 J2SType(undefined, env), // vtype
      	 J2SType(undefined, env), // mtype
      	 undefined, // irange
      	 undefined, // vrange
      	 null, // hint
      	 false, // export
      	 J2SExpr(node.initializer, env, scope))]; // val
   } else {
      return [new hopc.J2SDecl(J2SLoc(node, env),  // loc
      	 J2SIdent(node.name, env, scope), // id 
      	 false, // _scmid
      	 J2SKey(), // key
      	 true, // writable
      	 J2SSymbol(scope), // scope
      	 0, // usecnt
      	 false, // useinloop
      	 false, // escape
      	 0, // usage
      	 J2SSymbol("var"), // binder
      	 J2SSymbol("any"), // ctype
      	 J2SType(node, env), // utype
      	 J2SType(undefined, env), // itype
      	 J2SType(undefined, env), // vtype
      	 J2SType(undefined, env), // mtype
      	 undefined, // irange
      	 undefined, // vrange
      	 null, // hint
      	 false)]; // export
   }
}

/*---------------------------------------------------------------------*/
/*    J2SVarDeclList ...                                               */
/*---------------------------------------------------------------------*/
function J2SVarDeclList(node, env, scope) {
   const decls = node.declarations.map(d => J2SDeclVar(d, env, scope));
   return new hopc.J2SVarDecls(
      J2SLoc(node, env), // loc
      Array.prototype.concat.apply([], decls)); // decls
}

/*---------------------------------------------------------------------*/
/*    J2SEnumDeclaration ...                                           */
/*---------------------------------------------------------------------*/
function J2SEnumDeclaration(node, env, scope) {
   
   function J2SMember(node, idx, env, scope) {
      if (node.initializer) {
	 return [ new hopc.J2SDataPropertyInit(J2SLoc(node, env), // loc
 	    	     J2SPropName(node.name, env, scope), // name
	    	     J2SExpr(node.initializer, env, scope)) ]; // val
      } else {
	 return [ new hopc.J2SDataPropertyInit(J2SLoc(node, env), // loc
 	    	     J2SPropName(node.name, env, scope), // name
	 	     new hopc.J2SNumber(J2SLoc(node, env), // loc
	    		J2SSymbol("integer"), // type
	    		null, // hint
	    		undefined, // range
	    		idx)), //val
		  new hopc.J2SDataPropertyInit(J2SLoc(node, env), // loc
	 	     new hopc.J2SNumber(J2SLoc(node, env), // loc
	    		J2SSymbol("integer"), // type
	    		null, // hint
	    		undefined, // range
	    		idx),
		     J2SPropName(node.name, node.name, env, scope)) ];
      }
   }
   
   return new hopc.J2SVarDecls(J2SLoc(node, env),
      [ new hopc.J2SDeclInit(J2SLoc(node, env),  // loc
      	   J2SIdent(node.name, env, scope), // id 
      	   false, // _scmid
      	   J2SKey(), // key
      	   false, // writable
      	   J2SSymbol(scope), // scope
      	   0, // usecnt
      	   false, // useinloop
      	   false, // escape
      	   0, // usage
      	   J2SSymbol("let"), // binder
           J2SSymbol("any"), // ctype
      	   J2SType(node, env), // utype
      	   J2SType(undefined, env), // itype
      	   J2SType(undefined, env), // vtype
      	   undefined, // irange
      	   undefined, // vrange
      	   null, // hint
      	   false, // export
      	   new hopc.J2SObjInit(J2SLoc(node, env), // loc
	      TCType(node, env.typechecker), // type
	      null, // hint
	      undefined, // range
	      node.members.flatMap((n, i) => J2SMember(n, i, env, scope)), // inits
	      false, // cmap
	      false)) ]); // ronly
}

/*---------------------------------------------------------------------*/
/*    J2SImport ...                                                    */
/*---------------------------------------------------------------------*/
function J2SImport(node, env, scope) {
   
   function J2SImportName(node) {
      const name = J2SIdent(node.name, env, scope);
      const alias = node.propertyName && J2SIdent(node.propertyName, env, scope);
      return new hopc.J2SImportName(J2SLoc(node, env), // loc
	 alias || name, // name
	 name); // alias
   }

   function J2SImportDefault(node, env, scope) {
      const loc = J2SLoc(node, env);
      const name = J2SSymbol("default");
      const id = node.importClause.name.escapedText;
      const importname = new hopc.J2SImportName(loc, "default", id);
      
      return new hopc.J2SImport(loc, // loc
      	 node.moduleSpecifier.text, // path
	 false, // ipath
	 J2SUndefined(node, env, scope), // dollarpath
	 [importname], // importNames
	 false, // iprgm
	 false); // lang
   }
      
   function J2SImportDynamic(node, env, scope) {
      const loc = J2SLoc(node, env);
      
      return new hopc.J2SImport(loc, // loc
      	 node.moduleSpecifier.text, // path
	 false, // ipath
	 J2SUndefined(node, env,scope), // dollarpath
	 null, // importNames
	 false, // iprgm
	 false); // lang
   }
      
   function J2SImportNames(node, env, scope) {
      const loc = J2SLoc(node, env);
      const names = 
      	 node.importClause.namedBindings.elements.map(J2SImportName);
      
      return new hopc.J2SImport(loc, // loc
      	 node.moduleSpecifier.text, // path
	 false, // ipath
	 J2SUndefined(node, env,scope), // dollarpath
	 names, // importNames
	 false, // iprgm
	 false); // lang
   }
   
   function J2SImportNamespace(node, env, scope) {
      const name = 
	 J2SIdent(node.importClause.namedBindings.name, env, scope);
      const names = [new hopc.J2SImportName(J2SLoc(node, env), // loc
	     		J2SSymbol("*"), // id
	     		name)];
      
      return new hopc.J2SImport(J2SLoc(node, env), // loc
      	 node.moduleSpecifier.text, // path
	 false, // ipath
	 J2SUndefined(node, env,scope), // dollarpath
	 names, // importNames
	 false, // iprgm
	 false); // lang
   }
   
   if (!node.importClause) {
      // import dynamic (not tested)
      return J2SImportDynamic(node, env, scope);
   } else if (node.importClause.namedBindings === undefined) {
      if (!node.importClause.name) {
      	 // import dynamic (not tested)
	 return J2SImportDynamic(node, env, scope);
      } else {
      	 // import the default export 
      	 return J2SImportDefault(node, env, scope);
      }
   } else {
      switch (node.importClause.namedBindings.kind) {
      	 case ts.SyntaxKind.NamespaceImport:
	    return J2SImportNamespace(node, env, scope);
	 
      	 default:
	    return J2SImportNames(node, env, scope);
      }
   }
}

/*---------------------------------------------------------------------*/
/*    J2SNop ...                                                       */
/*---------------------------------------------------------------------*/
function J2SNop(node, env, scope) {
   return new hopc.J2SNop(J2SLoc(node, env));
}

/*---------------------------------------------------------------------*/
/*    J2SFor ...                                                       */
/*---------------------------------------------------------------------*/
function J2SFor(node, env, scope) {
   const initializer = node.initializer ?
      (node.initializer.kind === ts.SyntaxKind.VariableDeclarationList 
	 ? J2SStmt(node.initializer, env, scope) 
	 : J2SExpr(node.initializer, env, scope))
      : J2SUndefined(node, env, scope);

   return new hopc.J2SFor(
      J2SLoc(node, env), // loc
      false, // need_bind_exit_break
      undefined, // id
      false, // need_bind_exit_continue,
      J2SStmt(node.statement, env, scope), //body
      initializer,
      node.condition
	 ? J2SExpr(node.condition, env, scope)
	 : J2SUndefined(node, env, scope),
      node.incrementor
	 ? J2SExpr(node.incrementor, env, scope)
	 : J2SUndefined(node, env, scope));
}

/*---------------------------------------------------------------------*/
/*    J2SForInOf ...                                                   */
/*---------------------------------------------------------------------*/
function J2SForInOf(node, env, scope, op) {
   const lhs = node.initializer.kind === ts.SyntaxKind.Identifier 
      ? new hopc.J2SStmtExpr(J2SLoc(node, env), 
          J2SExpr(node.expression, env, scope))
      : J2SStmt(node.initializer, env, scope);
   return new hopc.J2SForIn(J2SLoc(node, env), // loc
      false, // need_bind_exit_break
      undefined, // id
      false, // need_bind_exit_continue,
      J2SStmt(node.statement, env, scope), // body
      op, // op
      lhs, // lhs
      J2SExpr(node.expression, env, scope)); // obj
}

/*---------------------------------------------------------------------*/
/*    J2SWhile ...                                                     */
/*---------------------------------------------------------------------*/
function J2SWhile(node, env, scope) {
   return new hopc.J2SWhile(J2SLoc(node, env), // loc
      false, // need_bind_exit_break
      undefined, // id
      false, // need_bind_exit_continue
      J2SStmt(node.statement, env, scope), // body
      J2SExpr(node.expression, env, scope)); // test
}
      
/*---------------------------------------------------------------------*/
/*    J2SDo ...                                                        */
/*---------------------------------------------------------------------*/
function J2SDo(node, env, scope) {
   return new hopc.J2SDo(J2SLoc(node, env), // loc
      false, // need_bind_exit_break
      undefined, // id
      false, // need_bind_exit_continue
      J2SStmt(node.statement, env, scope), // body
      J2SExpr(node.expression, env, scope)); // test
}
      
/*---------------------------------------------------------------------*/
/*    J2SIf ...                                                        */
/*---------------------------------------------------------------------*/
function J2SIf (node, env, scope) {
   return new hopc.J2SIf(J2SLoc(node, env), // loc
      J2SExpr(node.expression, env, scope), // test
      J2SStmt(node.thenStatement, env, scope), // then
      node.elseStatement // else
	 ? J2SStmt(node.elseStatement, env, scope) 
	    : J2SNop(node, env, scope));
}

/*---------------------------------------------------------------------*/
/*    J2STry ...                                                       */
/*---------------------------------------------------------------------*/
function J2STry(node, env, scope) {
   function J2SCatch(node, env, scope) {
      return new hopc.J2SCatch(J2SLoc(node, env), // loc
 	 J2SParam(node.variableDeclaration, env, scope), // param
	 J2SStmt(node.block, env, scope)); // body
   }
   
   return new hopc.J2STry(J2SLoc(node, env), // loc
      J2SStmt(node.tryBlock, env, scope), // body
      node.catchClause // catch
	 ? J2SCatch(node.catchClause, env, scope)
	 : J2SNop(node),
      node.finallyBlock // finally
	 ? J2SStmt(node.finallyBlock, env, scope) 
         : J2SNop(node, env, scope));
}

/*---------------------------------------------------------------------*/
/*    J2SCaseBlock ...                                                 */
/*---------------------------------------------------------------------*/
function J2SCaseBlock(node, env, scope) {
   function J2SCaseClause(node) {
      switch (node.kind) {
	 case ts.SyntaxKind.CaseClause: 
	    return new hopc.J2SCase(
	       J2SLoc(node, env),
	       J2SExpr(node.expression, env, scope),
	       new hopc.J2SSeq(
		  J2SLoc(node, env),
		  node.statements.map(n => J2SStmt(n, env, scope))));
	    
	 case ts.SyntaxKind.DefaultClause:
	    return new hopc.J2SDefault(
	       J2SLoc(node, env),
	       J2SUndefined(node, env, scope),
	       new hopc.J2SSeq(
		  J2SLoc(node, env),
		  node.statements.map(n => J2SStmt(n, env, scope))));
	    
      	 default:
            parseError(`Unsupported case clause "${node.getText()}" (${ts.SyntaxKind[node.kind]})`, node, env);
	    return new hopc.J2SStmtExpr(J2SLoc(node, env), 
	       J2SUndefined(node, env, scope));
      }
   }
   
   return node.clauses.map(J2SCaseClause);
}

/*---------------------------------------------------------------------*/
/*    J2SSwitch ...                                                    */
/*---------------------------------------------------------------------*/
function J2SSwitch(node, env, scope) {
   return new hopc.J2SSwitch (J2SLoc(node, env), // loc
      true, // need_bind_exit_break
      undefined, // id
      J2SExpr(node.expression, env, scope), // key
      J2SCaseBlock(node.caseBlock, env, scope));
}

/*---------------------------------------------------------------------*/
/*    J2SStmt ...                                                      */
/*---------------------------------------------------------------------*/
function J2SStmt(node, env, scope) {
   switch (node.kind) {
      case ts.SyntaxKind.Block:
	 return J2SBlock(node, env, scope);

      case ts.SyntaxKind.ExportDeclaration:
	 env.exports = env.exports.concat(J2SDeclExport(node, env, scope));
	 return false;
	 
      case ts.SyntaxKind.ClassDeclaration: 
	 return J2SDeclClass(node, env, scope);
	 
      case ts.SyntaxKind.FunctionDeclaration: 
	 return J2SDeclFun(node, env, scope);
	 
      case ts.SyntaxKind.VariableDeclaration:
	 return J2SDeclVar(node, env, scope);
	 
      case ts.SyntaxKind.VariableDeclarationList: 
	 return J2SVarDeclList(node, env, scope);
	 
      case ts.SyntaxKind.EnumDeclaration:
	 return J2SEnumDeclaration(node, env, scope);
	 
      case ts.SyntaxKind.ReturnStatement:   
	 return J2SReturn(node, env, scope);
	 
      case ts.SyntaxKind.ExpressionStatement:   
	 return J2SStmtExpr(node, env, scope);
	 
      case ts.SyntaxKind.VariableStatement:
	 return J2SVarDecls(node, env, scope);

      case ts.SyntaxKind.ImportDeclaration:
	 return J2SImport(node, env, scope);
	 
      case ts.SyntaxKind.ForStatement:
	 return J2SFor(node, env, scope);
	 
      case ts.SyntaxKind.ForInStatement:
	 return J2SForInOf(node, env, scope, J2SSymbol("in"));
	 
      case ts.SyntaxKind.ForOfStatement:
	 return J2SForInOf(node, env, scope, J2SSymbol("of"));
	 
      case ts.SyntaxKind.WhileStatement:
	 return J2SWhile(node, env, scope);
	 
      case ts.SyntaxKind.DoStatement:
	 return J2SDo(node, env, scope);
	 
      case ts.SyntaxKind.IfStatement:
	 return J2SIf (node, env, scope);
	 
      case ts.SyntaxKind.EmptyStatement:
	 return J2SNop(node, env, scope);
	 
      case ts.SyntaxKind.TypeAliasDeclaration: 
	 env.types.push(J2SSymbol(node.name.escapedText));
	 break;
	 
      case ts.SyntaxKind.InterfaceDeclaration: 
	 env.types.push(J2SSymbol(node.name.escapedText));
	 return J2SNop(node, env, scope);
	 
      case ts.SyntaxKind.TryStatement:
	 return J2STry(node, env, scope);
	 
      case ts.SyntaxKind.ThrowStatement:
	 return new hopc.J2SThrow(J2SLoc(node, env),
	    J2SExpr(node.expression, env, scope));
	 
      case ts.SyntaxKind.SwitchStatement:
	 return J2SSwitch(node, env, scope);

      case ts.SyntaxKind.BreakStatement:
	 return new hopc.J2SBreak(J2SLoc(node, env), false, false);
	 
      case ts.SyntaxKind.TypeAliasDeclaration:
	 return J2SNop(node, env, scope);
	 
      case ts.SyntaxKind.EndOfFileToken:
	 return false;
	 
      default:
         parseError(`Unsupported statement "${node.getText()}" (${ts.SyntaxKind[node.kind]})`, node, env);
	 return new hopc.J2SStmtExpr(J2SLoc(node, env), 
	    J2SUndefined(node, env, scope));
   }
}

/*---------------------------------------------------------------------*/
/*    parseSealed ...                                                  */
/*---------------------------------------------------------------------*/
function parseSealed(file, node, env) {
   const ranges = ts.getLeadingCommentRanges(
      file.getFullText(), node.getFullStart());
   let res = -1;
   
   if (ranges?.length) {
      const r = ranges[ranges.length - 1];
      const comment = file.getFullText().slice(r.pos,r.end);
      const sealed = comment.match("//[ ]*@sealed[ \t]*$");

      if (sealed) {
	 env.sealed.push(r.end + 2);
      }
   }
}

/*---------------------------------------------------------------------*/
/*    main ...                                                         */
/*---------------------------------------------------------------------*/
function main() {
   const [, , src, tgt, main, , , debug] = process.argv;
   
   const emitjs = debug === "true";
   const opts = {noEmit: !emitjs, ... options};
   const prog = ts.createProgram([src], opts);
   let tc = prog.getTypeChecker();
   const file = prog.getSourceFile(src);
   let emitResult = prog.emit();
   errorBuffer = [];
   
   let allDiagnostics = 
      ts.getPreEmitDiagnostics(prog).concat(emitResult.diagnostics);

   const nodes = [];
   const env = { source: src, typechecker: tc, exports: [], types: [] };
   
   ts.forEachChild(file, n => {
      const m = J2SStmt(n, env, "global");

      if (m) nodes.push(m);
   });
      
   const prgm = new hopc.J2SProgram(`${src}:0`, // loc
      nodes, //nodes
      `${src}:nodes[ nodes.length - 1 ].end`, // endloc
      J2SSymbol("typescript"), // mode
      src, // path
      0, // pcache-size
      0, // rxcache-size
      0, // call-size
      src.replace(".ts", ""), // name
      main == "true", // main
      false, // module
      null, // cnsts
      null, // decls
      env.types, // types
      null, // headers
      null, // globals
      true, // direct-eval
      false, // source-map
      null, // imports
      env.exports); // exports

   if (allDiagnostics.length === 0 && errorBuffer.length === 0) {
      const ast = { __ast__: prgm };
      writeFileSync(tgt, hopc.tojson(ast));
      return 0;
   } else {
      console.log("[");
      allDiagnostics.forEach((diagnostic, i) => {
        let msg = ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n")
		    .replace(/"/g, '\\"')
	            .replace(/\n/g, '');
	    
    	 if (diagnostic.file) {
      	    let { line, character } = ts.getLineAndCharacterOfPosition(diagnostic.file, diagnostic.start);
	    console.log(`{"error": "${msg}", "at": {"file": "${diagnostic.file.fileName}", "loc": ${diagnostic.start}}}`);
    	 } else {
      	    console.log(`{"error": "${msg}"}`);
    	 }
	 if (i + 1 < allDiagnostics.length) {
	    console.log(",");
	 }
      });
      console.log(errorBuffer.map(JSON.stringify).join());
      console.log("]");
      return 1;
   }
}

process.exit(main());
