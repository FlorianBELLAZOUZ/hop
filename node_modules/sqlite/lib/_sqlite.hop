;*=====================================================================*/
;*    .../prgm/project/hop/hop/node_modules/sqlite/lib/_sqlite.hop     */
;*    -------------------------------------------------------------    */
;*    Author      :  Manuel Serrano                                    */
;*    Creation    :  Sun Jul  6 06:15:53 2014                          */
;*    Last change :  Sun Oct 15 18:51:39 2023 (serrano)                */
;*    Copyright   :  2014-23 Manuel Serrano                            */
;*    -------------------------------------------------------------    */
;*    SYSTIME JS bindings                                              */
;*=====================================================================*/

;*---------------------------------------------------------------------*/
;*    The module                                                       */
;*---------------------------------------------------------------------*/
(module _sqlite

   (library hopscript hop hopwidget nodejs)

   (cond-expand
      ((library sqlite)
       (library sqlite)))
   
   (cond-expand
      ((and enable-threads (library pthread) (library sqlite))
       (static (class sqliteasync::sqlite
		  (%this read-only)
		  (this read-only)
		  (cmaps read-only)
		  (queue::pair-nil (default '()))
		  (mutex::mutex read-only)
		  (condv::condvar read-only)
		  (sync-mutex::mutex read-only)
		  (sync-condv::condvar read-only)
		  (async read-only)))))
   
   (export (hopscript ::JsGlobalObject ::JsObject ::JsObject ::JsObject)))

;*---------------------------------------------------------------------*/
;*    js-function ...                                                  */
;*---------------------------------------------------------------------*/
(define-macro (js-function id name . size)
   `(js-make-function %this
       ,id
       (js-function-arity ,id)
       (js-function-info :name ,name :len 0)
       :size ,(if (pair? size) (car size) 1)))
   
;*---------------------------------------------------------------------*/
;*    hopscript ...                                                    */
;*---------------------------------------------------------------------*/
(define (hopscript %this this %scope %module)
   
   (js-export (Database format verbose)
      
      (define exports (js-get %module (& "exports") %this))
      
      (define worker (with-access::JsGlobalObject %this (worker) worker))
      
      (define (js-database this filename mode callback)
	 (with-access::JsGlobalObject %this (js-new-target)
	    (with-access::JsWrapper this (obj data)
	       (when (eq? js-new-target (js-undefined))
		  (js-raise-type-error %this 
		     "Database must be used as a constructor" this))
	       (async-sqlite-init! %this this filename mode callback))
	       (set! js-new-target (js-undefined))
	       (js-bind! %this this (& "filename")
		  :value filename
		  :writable #f
		  :enumerable #t
		  :configurable #f)))

      (define (js-database-alloc %this constructor::JsFunction)
	 (with-access::JsGlobalObject %this (js-new-target)
	    (set! js-new-target constructor)
	    (with-access::JsFunction constructor (constrmap)
	       (unless constrmap
		  (set! constrmap
		     (js-make-jsconstructmap :ctor constructor)))
	       (instantiateJsWrapper
		  (__proto__ database-prototype)
		  (obj #unspecified)
		  (cmap (js-make-jsconstructmap))
		  (data #f)))))

      (define (js-database-close this cb)
	 (let ((db (js-database-sqlite this %this)))
	    (async-schedule! this "close"
	       (lambda (%this this)
		  (with-access::JsWrapper this (obj)
		     (sqlite-close obj))
		  this))))

      (define (js-sqlite-get worker this db query proc)
	 (sqlite-get db
	    (lambda (keys vals)
	       (js-worker-push! worker "sqlite"
		  (lambda (%this)
		     (proc this
			(js-undefined)
			(instantiateJsObject
			   (cmap (js-table-cmap db keys))
			   (__proto__ (js-object-proto %this))
			   (elements (vector-map! js-string->jsstring vals)))))))
	    query))

      (define (js-database-get this &arguments::vector)
	 (multiple-value-bind (len callback completion)
	    (js-parse-sqlite-arguments &arguments #f)
	    (let ((db (js-database-sqlite this %this))
		  (query (js-sqlite-format %this &arguments len)))
	       ;; decoding optional arguments
	       (async-schedule! this "get"
		  (lambda (%this this)
		     (cond
			((not callback)
			 ;; no callback
			 (sqlite-get db
			    (lambda (keys vals) #unspecified)
			    query))
			((and (js-procedure? callback)
			      (with-access::JsProcedure callback (arity)
				 (=fx arity 3)))
			 ;; fast callback
			 (with-access::JsProcedure callback (procedure)
			    (js-sqlite-get worker this db query procedure)))
			(else
			 ;; slow callback
			 (js-sqlite-get worker this db query
			    (lambda (this err obj)
			       (js-call2 %this callback this err obj)))))))
	       this)))

      (define (js-sqlite-each worker this db query proc)
	 (let ((cmap #f))
	    (sqlite-for-each db
	       (lambda (keys vals)
		  (js-worker-push! worker "sqlite"
		     (lambda (%this)
			(unless cmap
			   (set! cmap (js-table-cmap db keys)))
			(proc this
			   (js-undefined)
			   (instantiateJsObject
			      (cmap cmap)
			      (__proto__ (js-object-proto %this))
			      (elements (vector-map! js-string->jsstring vals)))))))
	       query)))
      
      (define (js-database-each this &arguments::vector)
	 (multiple-value-bind (len callback completion)
	    (js-parse-sqlite-arguments &arguments #t)
	    (let ((db (js-database-sqlite this %this))
		  (query (js-sqlite-format %this &arguments len)))
	       ;; decoding optional arguments
	       (async-schedule! this "for-each"
		  (lambda (%this this)
		     (cond
			((not callback)
			 ;; no callback
			 (sqlite-for-each db
			    (lambda (keys vals) #unspecified)
			    query))
			((and (js-procedure? callback)
			      (with-access::JsProcedure callback (arity)
				 (=fx arity 3)))
			 ;; fast callback
			 (with-access::JsProcedure callback (procedure)
			    (js-sqlite-each worker this db query procedure)))
			(else
			 ;; slow callback
			 (js-sqlite-each worker this db query
			    (lambda (this err obj)
			       (js-call2 %this callback this err obj)))))
		     ;; completion call
		     (when (js-callable? completion)
			(js-worker-push! worker "sqlite"
			   (lambda (%this)
			      (js-call0 %this completion this))))))
	       this)))

      (define (js-database-run this &arguments::vector)
	 (multiple-value-bind (len callback completion)
	    (js-parse-sqlite-arguments &arguments #f)
	    (let ((db (js-database-sqlite this %this))
		  (query (js-sqlite-format %this &arguments len)))
	       ;; decoding optional arguments
	       (with-access::sqliteasync db (sync-mutex sync-condv mutex)
		  (let ((status (synchronize mutex
				   (sqlite-run db query))))
;* 		     (synchronize sync-mutex                           */
;* 			(async-schedule! this "run"                    */
;* 			   (lambda (%this this)                        */
;* 			      (set! status (sqlite-run db query))      */
;* 			      (synchronize sync-mutex                  */
;* 				 (condition-variable-signal! sync-condv)))) */
;* 			(condition-variable-wait! sync-condv sync-mutex)) */
		     (when (js-callable? callback)
			(js-worker-push! worker "sqlite"
			   (lambda (%this)
			      (if (eq? status #unspecified)
				  (js-call1 %this callback this '())
				  (js-call1 %this callback this
				     (js-alist->jsobject `((code . ,status) (errno . 1)) %this))))))
		     this)))))

      (define (js-tables this)
	 (let ((db (js-database-sqlite this %this)))
	    (js-vector->jsarray
	       (list->vector
		  (map! js-string->jsstring (sqlite-name-of-tables db)))
	       %this)))
	 
      (define (js-columns this name)
	 (let ((db (js-database-sqlite this %this)))
	    (js-vector->jsarray
	       (list->vector
		  (map! js-string->jsstring
		     (sqlite-table-name-of-columns db
			(js-tostring name %this))))
	       %this)))

      (define (js-size this name)
	 (let ((db (js-database-sqlite this %this)))
	    (sqlite-table-number-of-rows db
	       (js-tostring name %this))))

      (define (js-format this &arguments::vector)
	 (multiple-value-bind (len callback completion)
	    (js-parse-sqlite-arguments &arguments #f)
	    (let ((query (js-sqlite-format %this &arguments len)))
	       (js-string->jsstring query))))
	 
      (define database-prototype
	 (instantiateJsObject
	    (__proto__ (js-null))
	    (cmap (js-names->cmap
		     (vector-map js-string->name
			'#("close" "columns" "each" "get" "run" "size" "tables"))
		     :writable #f :enumerable #t :configurable #f))
	    (elements (vector
			 (js-function js-database-close "close")
			 (js-make-function %this js-columns
			    (js-function-arity 1 0)
			    (js-function-info :name "columns" :len 1))
			 (js-make-function %this js-database-each
			    (js-function-arity 1 0 'arguments-lazy)
			    (js-function-info :name "each" :len 1))
			 (js-make-function %this js-database-get
			    (js-function-arity 1 0 'arguments-lazy)
			    (js-function-info :name "get" :len 1))
			 (js-make-function %this js-database-run
			    (js-function-arity 1 0 'arguments-lazy)
			    (js-function-info :name "run" :len 1))
			 (js-make-function %this js-size
			    (js-function-arity 1 0)
			    (js-function-info :name "size" :len 1))
			 (js-make-function %this js-tables
			    (js-function-arity 0 0)
			    (js-function-info :name "tables" :len 1))
			 ))))
      
      ;; Database
      (define Database
	 (js-make-function %this
	    js-database
	    (js-function-arity 3 0)
	    (js-function-info :name "Database" :len 3)
	    :prototype database-prototype
	    :size 1
	    :alloc js-database-alloc))
      
      (js-bind! %this exports (& "Database")
	 :value Database
	 :writable #f
	 :enumerable #t)
      
      ;; format
      (define format
	 (js-make-function %this
	    js-format
	    (js-function-arity 1 0 'arguments-lazy)
	    (js-function-info :name "format" :len 1)
	    :size 1))
      
      (js-bind! %this exports (& "format")
	 :value format
	 :writable #f
	 :enumerable #t)
      
      ;; verbose
      (define verbose
	 (js-make-function %this
	    (lambda (this) exports)
	    (js-function-arity 1 0)
	    (js-function-info :name "verbose" :len 1)
	    :size 1))
      
      (js-bind! %this exports (& "verbose")
	 :value verbose
	 :writable #f
	 :enumerable #t)

      ;; configure sqlite
      (sqlite-config 'SQLITE_CONFIG_MULTITHREAD)
      #unspecified))

;*---------------------------------------------------------------------*/
;*    js-database-sqlite ...                                           */
;*---------------------------------------------------------------------*/
(define (js-database-sqlite this %this)
   (when (isa? this JsWrapper)
      (with-access::JsWrapper this (obj)
	 (if (isa? obj sqlite)
	     obj
	     (js-raise-type-error %this "Not a database \"~a\"" this)))))

;*---------------------------------------------------------------------*/
;*    async-sqlite-init! ...                                           */
;*    -------------------------------------------------------------    */
;*    Async sqlite db have to be created within a fresh thread         */
;*---------------------------------------------------------------------*/
(define (async-sqlite-init! %this this::JsWrapper filename mode callback)

   (define (init-db! %this this mutex condv)
      (with-access::JsGlobalObject %this (worker) 
	 (with-access::WorkerHopThread worker (%loop)
	    (with-access::JsWrapper this (obj)
	       (let ((async (instantiate::UvAsync (loop %loop))))
		  (uv-unref async)
		  (let ((db (instantiate::sqliteasync
			       (%this %this)
			       (this this)
			       (cmaps (create-hashtable
					 :size 16
					 :hash hash-keys
					 :eqtest equal-keys?))
			       (path (js-tostring filename %this))
			       (mutex mutex)
			       (condv condv)
			       (sync-mutex (make-mutex))
			       (sync-condv (make-condition-variable))
			       (async async))))
		     (set! obj db)
		     db))))))
   
   (define (thread-body %this this mutex::mutex condv::condvar) 
      (with-access::JsGlobalObject %this (worker) 
	 (with-access::JsWrapper this (obj)
	    (lambda ()
	       (thread-name-set! (current-thread) "sqlite")
	       (synchronize mutex
		  ;; depending on the threading mode the sqlite object
		  ;; must be created inside the thread or outside
		  (unless (isa? obj sqlite)
		     (init-db! %this this mutex condv))
		  (condition-variable-signal! condv))
	       (let loop ()
		  (let ((proc #f))
		     (synchronize mutex
			(with-access::sqliteasync obj (queue async)
			   (if (pair? queue)
			       (begin
				  (set! proc (car queue))
				  (set! queue (cdr queue)))
			       (begin
				  (uv-unref async)
				  (condition-variable-wait! condv mutex)))))
		     (if proc
			 (let ((res (proc %this this)))
			    (if (eq? res this)
				;; push a dummy call back to
				;; force the main loop to react
				;; to the termination of the
				;; sqlite thread
				(js-worker-push! worker "sqlite"
				   (lambda (%this)
				      #unspecified))
				(loop)))
			 (loop))))))))
   
   (cond-expand
      ((or (not enable-threads) (not (library pthread)))
       (js-raise-type-error %this "database require thread support" this))
      ((not (library sqlite))
       (js-raise-type-error %this "No native sqlite support" this))
      (else
       (let* ((mutex (make-mutex))
	      (condv (make-condition-variable))
	      (db (init-db! %this this mutex condv))
	      (th (instantiate::pthread
		     (body (thread-body %this this mutex condv)))))
	  (synchronize mutex
	     (thread-start! th)
	     (condition-variable-wait! condv mutex))))))

;*---------------------------------------------------------------------*/
;*    async-schedule! ...                                              */
;*---------------------------------------------------------------------*/
(define (async-schedule! this::JsWrapper name proc::procedure)
   (with-access::JsWrapper this (obj)
      (with-access::sqliteasync obj (queue condv mutex async)
	 (synchronize mutex
	    ;; mark the queue active to prevent premature app termination
	    (uv-ref async)
	    (if (pair? queue)
		(set-cdr! (last-pair queue) (cons proc '()))
		(set! queue (list proc)))
	    (condition-variable-signal! condv)))))

;*---------------------------------------------------------------------*/
;*    js-sqlite-format ...                                             */
;*---------------------------------------------------------------------*/
(define (js-sqlite-format %this::JsGlobalObject &arguments::vector len::long)

   (define (display-val val out)
      (cond
	 ((number? val)
	  (display val out))
	 ((string? val)
	  (let ((len (string-length val)))
	     (if (=fx len 0)
		 (display "''" out)
		 (begin
		    (display #\' out)
		    (do ((i 0 (+fx i 1)))
			((=fx i len))
			(let ((c (string-ref val i)))
			   (display c out)
			   (when (char=? c #\') (display #\' out))))
		    (display #\' out)))))
	 ((js-jsstring? val)
	  (display-val (js-jsstring->string val) out))
	 ((boolean? val)
	  (display (if val "TRUE" "FALSE") out))
	 ((eq? val #unspecified)
	  (display "NULL" out))
	 (else
	  (display-val (js-tostring val %this) out))))
   
   (define (get-key str idx)
      (let ((l (string-length str)))
	 (let loop ((i (+fx idx 1)))
	    (cond
	       ((=fx i l)
		(substring str idx i))
	       ((string-index "()[], \t" (string-ref str i))
		(substring str idx i))
	       (else
		(loop (+fx i 1)))))))

   (define (get-idx str idx)
      (let ((l (string-length str)))
	 (let loop ((i (+fx idx 1)))
	    (cond
	       ((=fx i l)
		(substring str idx i))
	       ((char-numeric? (string-ref str i))
		(loop (+fx i 1)))
	       (else
		(substring str idx i))))))

   (define (get-param-index param idx)
      (cond
	 ((js-array? (vector-ref param 1))
	  (js-array-index-ref (vector-ref param 1) idx %this))
	 ((js-object? (vector-ref param 1))
	  (js-get (vector-ref param 0) (js-index-name idx) %this))
	 ((>=fx (+fx 1 idx) len)
	  (js-raise-type-error %this "parameter out of range \"~a\"" idx))
	 (else
	  (vector-ref param (+fx 1 idx)))))

   (define (get-param-key param key)
      (js-get (vector-ref param 1) (js-string->name key) %this))
   
   (let ((str (js-tostring (vector-ref &arguments 0) %this)))
      (if (=fx len 0)
	  str
	  (let ((l (string-length str))
		(out (open-output-string)))
	     (let loop ((i 0)
			(instring #f)
			(idx 0))
		(when (<fx i l)
		   (case (string-ref str i)
		      ((#\?)
		       (cond
			  (instring
			   (display #\? out)
			   (loop (+fx i 1) instring idx))
			  ((=fx i (-fx l 1))
			   (display-val (get-param-index &arguments idx) out))
			  ((string-index "()[], \t" (string-ref str (+fx i 1)))
			   (display-val (get-param-index &arguments idx) out)
			   (loop (+fx i 1) instring (+fx idx 1)))
			  ((get-idx str (+fx i 1))
			   =>
			   (lambda (key)
			      (let* ((idx (string->integer key))
				     (val (get-param-index &arguments idx)))
				 (display-val val out)
				 (loop (+fx (+fx i 1) (string-length key)) instring idx))))
			  (else
			   (error "format not supported..." str i))))
		      ((#\$)
		       (if instring
			   (begin
			      (display #\$ out)
			      (loop (+fx i 1) instring idx))
			   (let* ((key (get-key str i))
				  (val (get-param-key &arguments key)))
			      (display-val val out)
			      (loop (+fx (+fx i 1) (string-length key)) instring idx))))
		      ((#\')
		       (display #\' out)
		       (loop (+fx i 1) (not instring) idx))
		      (else
		       (display (string-ref str i) out)
		       (loop (+fx i 1) instring idx)))))
	     (close-output-port out)))))

;*---------------------------------------------------------------------*/
;*    js-parse-sqlite-arguments ...                                    */
;*---------------------------------------------------------------------*/
(define (js-parse-sqlite-arguments &arguments::vector completion::bool)
   (let ((&len (vector-length &arguments)))
      (cond
	 ((and completion
	       (>fx &len 2)
	       (js-callable? (vector-ref &arguments (-fx &len 2)))
	       (js-callable? (vector-ref &arguments (-fx &len 1))))
	  ;; [, param, ...] [, callback] [, completion]
	  (cond
	     ((not (js-object? (vector-ref &arguments 1)))
	      (values (-fx &len 3) #f))
	     ((=fx &len 4)
	      (values 1 #f))
	     (else
	      (error "sqlite" "illegal arguments" &arguments))))
	 ((and (>fx &len 1)
	       (js-callable? (vector-ref &arguments (-fx &len 1))))
	  ;; [, param, ...] [, callback]
	  (cond
	     ((not (js-object? (vector-ref &arguments 1)))
	      (values (-fx &len 2) #f))
	     ((=fx &len 3)
	      (values 1 #f))
	     (else
	      (error "sqlite" "illegal arguments" &arguments))))
	 (else
	  ;; [, param, ...]
	  (cond
	     ((not (js-object? (vector-ref &arguments 1)))
	      (values (-fx &len 1) #f))
	     ((=fx &len 2)
	      (values 1 #f))
	     (else
	      (error "sqlite" "illegal arguments" &arguments)))))))

;*---------------------------------------------------------------------*/
;*    hash-keys ...                                                    */
;*---------------------------------------------------------------------*/
(define (hash-keys keys)
   (let loop ((i (-fx (vector-length keys) 1))
	      (n 17))
      (if (=fx i -1)
	  n
	  (let ((k (string-hash-number (vector-ref keys i))))
	     (loop (-fx i 1) (bit-xor n k))))))

;*---------------------------------------------------------------------*/
;*    equal-keys? ...                                                  */
;*---------------------------------------------------------------------*/
(define (equal-keys? v1 v2)
   (or (eq? v1 v2)
       (when (=fx (vector-length v1) (vector-length v2))
	  (let loop ((i (-fx (vector-length v1) 1)))
	     (cond
		((=fx i -1)
		 #t)
		((string=? (vector-ref v1 i) (vector-ref v2 i))
		 (loop (-fx i 1)))
		(else
		 #f))))))

;*---------------------------------------------------------------------*/
;*    js-table-cmap ...                                                */
;*---------------------------------------------------------------------*/
(define (js-table-cmap db keys)
   (with-access::sqliteasync db (cmaps)
      (hashtable-add! cmaps keys
	 (lambda (keys val)
	    (or val
		(js-names->cmap
		   (vector-map js-string->name keys)
		   :enumerable #t)))
	 keys #f)))
   
;*---------------------------------------------------------------------*/
;*    The return value for dynamic-load                                */
;*---------------------------------------------------------------------*/
hopscript

