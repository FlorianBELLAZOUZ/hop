/*=====================================================================*/
/*    serrano/prgm/project/hop/hop/node_modules/hopc/node/hopc.mjs     */
/*    -------------------------------------------------------------    */
/*    Author      :  manuel serrano                                    */
/*    Creation    :  Tue Oct 24 09:50:25 2023                          */
/*    Last change :  Sat Oct 28 08:01:29 2023 (serrano)                */
/*    Copyright   :  2023 manuel serrano                               */
/*    -------------------------------------------------------------    */
/*    ESM module                                                       */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    Import/Export                                                    */
/*---------------------------------------------------------------------*/
import { j2sParser } from "./parser.mjs";
import { Config } from "./config.mjs";
import { openInputFile, openInputString } from "./utils.mjs";
import { cons, list } from "./list.mjs";
export * from "./ast.mjs";
export { generate } from "./generate.mjs";

/*---------------------------------------------------------------------*/
/*    keywords                                                         */
/*---------------------------------------------------------------------*/
const keywordsSImple =
   ["DOT", "DOTS", "SEMICOLON", "COMMA", "LBRACE", "RBRACE", "LPAREN",
    "RPAREN", "ID", "DOLLAR", "LBRACKET", "RBRACKET", "OR", "BIT_OR",
    "STRING", "await", "break", "case", "catch", "const", "continue",
    "debugger", "default", "delete", "do", "else", "false", "finally",
    "for", "function", "if", "in", "instanceof", "let", "new", "null",
    "return", "switch", "this", "throw", "true", "try", "typeof", "var",
    "void", "while", "with", "yield", "class", "extends", "super",
    "static"];

const keywordsValue =
   [{key: "ELSE", val: "else"}, {key: "COLUMN", val: ":"},
    {key: "EGAL", val: "="}, {key: "NOTEGAL", val: "!="},
    {key: "EGALEGAL", val: "=="}, {key: "NOTEGALEGAL", val: "!=="},
    {key: "LT", val: "<"}, {key: "GT", val: ">"},
    {key: "LE", val: "<="}, {key: "GE", val: ">="},
    {key: "PLUS", val: "+"}, {key: "MINUS", val: "-"},
    {key: "MUL", val: "*"}, {key: "PERCENT", val: "%"},
    {key: "PLUSPLUS", val: "++"}, {key: "MINUSMINUS", val: "--"}, 
    {key: "SHIFTL", val: "<<"}, {key: "SHIFTR", val: ">>"},
    {key: "USHIFTR", val: ">>>"}, {key: "AMP", val: "&"},
    {key: "HAT", val: "^"}, {key: "BANG", val: "!"},
    {key: "TILDE", val: "~"}, {key: "AND", val: "&&"},
    {key: "PLUSEGAL", val: "+="}, {key: "MINUSEGAL", val: "-="},
    {key: "MULEGAL", val: "*="}, {key: "PERCENTEGAL", val: "%="},
    {key: "SHIFTLEGAL", val: "<<="}, {key: "SHIFTREGAL", val: ">>="},
    {key: "USHIFTREGAL", val: ">>>="}, {key: "AMPEGAL", val: "&="},
    {key: "HATEGAL", val: "^="}, {key: "DIVEGAL", val: "/="},
    {key: "DIV", val: "/"}, {key: "QUESTIONMARK", val: "?"},
    {key: "LARROW", val: "=>"}];

/*---------------------------------------------------------------------*/
/*    Parser ...                                                       */
/*---------------------------------------------------------------------*/
export class Parser {
   ip;
   controller = false;
   data = null;

   constructor() {
      keywordsSImple.forEach(id => this[id] = id);
      keywordsValue.forEach((key, val) => this[key] = val);
   }

   parse(path, conf = {}) {
      const ip = openInputFile(path.toString());
      const co = Object.assign({ parser: "program", "no-dialect": true }, conf);
      
      this.controller = false;
      return j2sParser(ip, new Config(co), this.data)
   }

   parseString(val, conf = {}) {
      const ip = openInputString(val);
      const co = Object.assign({ parser: "module", "no-dialect": true }, conf);

      this.controller = false;
      return j2sParser(ip, new Config(co), this.data);
   }

   plugins() {
      return this.data;
   }
   
   addPlugin(key, parser) {
      const plug = cons(key, this.pluginParse(parser));
      this.data = cons(plug, this.data);
   }

   removePlugin(key) {
      this.data = this.data.filter(e => car(e) !== key);
   }

   pluginParse(parser) {
      return (tok, decl, conf, ctrl) => {
	 this.controller = ctrl;
	 return jstoAST(parser.call(this, jsToken(tok), decl, conf));
      }
   }

   peekToken(token) {
      if (this.controller) {
	 return jsToken(this.controller[2]());
      } else {
	 throw "peekToken: detached plugin parser";
      }
   }

   consumeToken(token) {
      if (this.controller) {
	 return jsToken(this.controller[3](token.toString()));
      } else {
	 throw "consumeToken: detached plugin parser";
      }
   }
   
   consumeAny(token) {
      if (this.controller) {
	 return jsToken(this.controller[4]());
      } else {
	 throw "consumeAny: detached plugin parser";
      }
   }
   
   parseExpression() {
      if (this.controller) {
	 return this.controller[5](false, false, this.data);
      } else {
	 throw "parseExpression: detached plugin parser";
      }
   }

   parsePrimary() {
      if (this.controller) {
	 return this.controller[0](false, false, this.data);
      } else {
	 throw "parsePrimary: detached plugin parser";
      }
   }

   parsePrimaryDollar() {
      if (this.controller) {
	 return this.controller[1](false, false, this.data);
      } else {
	 throw "parsePrimaryDollar: detached plugin parser";
      }
   }

   parseCondExpression() {
      if (this.controller) {
	 return this.controller[8](false, false, true, this.data);
      } else {
	 throw "parseCondExpression: detached plugin parser";
      }
   }

   parseAssigEpxression() {
      if (this.controller) {
	 return this.controller[10](false, false, true, this.data);
      } else {
	 throw "parseAssigExpression: detached plugin parser";
      }
   }

   parseDollarEpxression() {
      if (this.controller) {
	 return this.controller[9](this.data);
      } else {
	 throw "parseDollarExpression: detached plugin parser";
      }
   }

   parseStatement() {
      if (this.controller) {
	 return this.controller[6](this.data);
      } else {
	 throw "parseStatement: detached plugin parser";
      }
   }

   parseBlock() {
      if (this.controller) {
	 return this.controller[7](this.data);
      } else {
	 throw "parseBlock: detached plugin parser";
      }
   }


}

/*---------------------------------------------------------------------*/
/*    jsToken ...                                                      */
/*---------------------------------------------------------------------*/
function jsToken(tok) {
   // backward compatibility
   tok.location = list("at", tok.loc.filename, tok.loc.offset);
   return tok;
}

/*---------------------------------------------------------------------*/
/*    jstoAST ...                                                      */
/*---------------------------------------------------------------------*/
function jstoAST(n) {
   return n;
}
   
