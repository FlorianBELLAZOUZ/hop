/*=====================================================================*/
/*    .../project/hop/hop/node_modules/hopc/node/sourcemap.mjs         */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Mon Feb 19 07:25:45 2024                          */
/*    Last change :  Mon Feb 19 08:02:27 2024 (serrano)                */
/*    Copyright   :  2024 Manuel Serrano                               */
/*    -------------------------------------------------------------    */
/*    Encode/Decode sourcemap files                                    */
/*    -------------------------------------------------------------    */
/*    See https://sourcemaps.info/spec.html                            */
/*=====================================================================*/
"use strict";

/*---------------------------------------------------------------------*/
/*    Import/Export                                                    */
/*---------------------------------------------------------------------*/
import { openSync, closeSync } from "fs";
import * as vlq from "./base64-vlq.mjs";
import { existsSync, readFileSync } from "node:fs";

export { load, unmap };

/*---------------------------------------------------------------------*/
/*    load ...                                                         */
/*    -------------------------------------------------------------    */
/*    Load a source map file.                                          */
/*---------------------------------------------------------------------*/
function load(file) {
   return unmap(JSON.parse(readFileSync(file)));
}

/*---------------------------------------------------------------------*/
/*    unmap ...                                                        */
/*    -------------------------------------------------------------    */
/*    Unmap a source file. Return a array of lines. Each line is an    */
/*    array of { tgtCol, source, srcLine, srcCol, name }               */
/*---------------------------------------------------------------------*/
function unmap(sourceMap) {
   const { version, sources, names, mappings } = sourceMap;

   if (version !== 3) {
      throw `unmap: unsupported Source Map version number ${version}`;
   }

   const allSegs =  mappings.split(";")
      .map(g => g.split(",").map(decodeSegment));

   // patch the relative segement counters that appart col are all
   // relative to the previous occurrence of the counter
   for (let i = 0, srcIndex = 0, srcLine = 0, srcCol = 0, srcName = 0;
	i < allSegs.length;
	i++) {
      const segs = allSegs[i];
      for (let j = 0; j < segs.length; j++) {
	 const seg = segs[j];
	 // columns are relative to the previous segment and are
	 // reset at each new line
	 if (j > 0) {
	    seg.tgtCol += segs[j - 1].tgtCol;
	 }

	 if (seg.srcIndex !== undefined) {
	    srcIndex += seg.srcIndex; seg.srcIndex = srcIndex;
	    srcLine += seg.srcLine; seg.srcLine = srcLine;
	    srcCol += seg.srcCol; seg.srcCol = srcCol;

	    if (seg.srcName !== undefined) {
	       srcName += seg.srcName; seg.srcName += srcName;
	       src.name = names[seg.srcName];
	    }
	 }
      }
   }
   return allSegs;
}
	 
/*---------------------------------------------------------------------*/
/*    decode ...                                                       */
/*---------------------------------------------------------------------*/
function decode() {
}

/*---------------------------------------------------------------------*/
/*    decodeSegment ...                                                */
/*    -------------------------------------------------------------    */
/*    A segment is made of 1,4 or 5 variable length fields. The        */
/*    fields are:                                                      */
/*                                                                     */
/*      1. The zero-based starting column of the line in the           */
/*         generated code that the segment represents.                 */
/*      2. If present, an zero-based index into the "sources" list.    */
/*      3. If present, the zero-based starting line in the original    */
/*         source represented.                                         */
/*      4. If present, the zero-based starting column of the line      */
/*         in the source represented.                                  */
/*      5. If present, the zero-based index into the "names" list      */
/*         associated with this segment.                               */
/*---------------------------------------------------------------------*/
export function decodeSegment(str) {
   const len = str.length;
   const { value: tgtCol, index: iindex } = vlq.decode(str, 0);
   if (iindex === len) {
      // size 1 segment
      return { tgtCol };
   } else {
      const { value: srcIndex, index: lindex } = vlq.decode(str, iindex);
      const { value: srcLine, index: cindex } = vlq.decode(str, lindex);
      const { value: srcCol, index: nindex } = vlq.decode(str, cindex);
      
      if (nindex === len) {
	 // size 4 segment
	 return { tgtCol, srcIndex, srcLine, srcCol };
      } else {
	 // size 5 segment
	 const { value: srcName } = vlq.decode(str, nindex);
	 return { tgtCol, srcIndex, srcLine, srcCol, srcName };
      }
   }
}


	 
	 
      
      
       
