/*=====================================================================*/
/*    .../project/hop/3.7.x/node_modules/hopc/node/j2slexer.mjs        */
/*    -------------------------------------------------------------    */
/*    Author      :  manuel serrano                                    */
/*    Creation    :  Sat Sep 16 12:26:16 2023                          */
/*    Last change :  Tue Nov 21 09:07:14 2023 (serrano)                */
/*    Copyright   :  2023 manuel serrano                               */
/*    -------------------------------------------------------------    */
/*    JavaScript lexer                                                 */
/*=====================================================================*/
"use strict";
"use hopscript";

/*---------------------------------------------------------------------*/
/*    The module                                                       */
/*---------------------------------------------------------------------*/
import { Token } from "./token.mjs";
import { Lexer, makeLoc } from "./reader.mjs";

/*---------------------------------------------------------------------*/
/*    jsRules ...                                                      */
/*---------------------------------------------------------------------*/
const jsRules = [
   // blank
   {rx: /[ \t]+/y, type: "BLANK"},
   {rx: /[ \t]*[\n][ \t]*/y, type: "NEWLINE"},
   // comments
   {rx: /\/\/[^\n\r]*/y, type: "LINECOMMENT" },
   {rx: /\/[*](?:[^*]|[*][^/])*[*]+\//my, type: "COMMENT" },
   // numbers
   {rx: /0|[1-9][0-9]*/y, type: "NUMBER" },
   // dollar
   {rx: /[$]{/y, type: "DOLLAR" },
   // identifiers
   {rx: /[$_a-zA-Z][$_a-zA-Z0-9]*/y, type: "ID"},
   // parenthesis
   {rx: /{/y, type: "LBRACE"},
   {rx: /}/y, type: "RBRACE"},
   {rx: /\(/y, type: "LPAREN"},
   {rx: /\)/y, type: "RPAREN"},
   {rx: /\[/y, type: "LBRACKET"},
   {rx: /\]/y, type: "RBRACKET"},
   // punctuation
   {rx: /#/y, type: "SHARP"},
   {rx: /[.]/y, type: "DOT"},
   {rx: /;/y, type: "SEMICOLON"},
   {rx: /:/y, type: ":"},
   {rx: /,/y, type: "COMMA"},
   {rx: /[|]/y, type: "BIT_OR"},
   {rx: /[|][|]/y, type: "OR"},
   // bitwise
   {rx: /\|/y, type: "BIT_OR"},
   {rx: /[-<>+*%&^!~:=?\/]/y, type: "__SELF__"},
   {rx: /<=|>=|=?=?=|!=?=?|[*][*]|[+][+]|--|<<|>>|>>>|&&|[+]=|-=|[*]=|%=|<<=|>>=|>>>=|&=|\^=|\/=|[*][*]=|[?][?]|[?][.]|[?][?]=/y, type: "__SELF__"},
   {rx: /=>/y, type: "=>"},
   {rx: /[.]{3}/y, type: "DOTS"},
   // strings
   {rx: /"([^"\r\n]*)"|'([^'\r\n]*)'/y, type: "STRING"},
   // HTML
   {rx: /<!--[^-][-]*->/y, type: "HTMLCOMMENT"},
   {rx: /<[0-9]*[_0-9a-zA-Z][0-9a-zA-Z_.:]*>/y, type: "OTAG"},
   {rx: /<\/[0-9]*[_0-9a-zA-Z][0-9a-zA-Z_.:]*>/y, type: "CTAG"},
   {rx: /<[0-9]*[_0-9a-zA-Z][0-9a-zA-Z_.:]*[ \t\n]+(?:[0-9]*[_0-9a-zA-Z][0-9a-zA-Z_.:]*|[$][{]|\/?>)/y, type: "OHTML"},
   {rx: /<[0-9]*[_0-9a-zA-Z][0-9a-zA-Z_.:]*\/>/y, type: "HTML"},
   {rx: /<![0-9]*[_0-9a-zA-Z][0-9a-zA-Z_.:]*[^>]+>/y, type: "DOCTYPE"}
];

/*---------------------------------------------------------------------*/
/*    reserved keywords                                                */
/*---------------------------------------------------------------------*/
const keyword = new Map([
   ["await", true],
   ["break", true],
   ["case", true],
   ["catch", true],
   ["const", true],
   ["continue", true],
   ["debugger", true],
   ["default", true],
   ["delete", true],
   ["do", true],
   ["else", true],
   ["false", true],
   ["finally", true],
   ["for", true],
   ["function", true],
   ["if", true],
   ["in", true],
   ["instanceof", true],
   ["let", true],
   ["new", true],
   ["null", true],
   ["return", true],
   ["switch", true],
   ["this", true],
   ["throw", true],
   ["true", true],
   ["try", true],
   ["typeof", true],
   ["var", true],
   ["void", true],
   ["while", true],
   ["with", true],
   ["yield", true],
   // es2015 classes
   ["class", true],
   ["extends", true],
   ["super", true]]);
			
const reserved = new Map([
   ["enum", true],
   ["export", true],
   ["import", true]]);

const future = new Map([
   ["implements", true],
   ["interface", true],
   ["package", true],
   ["private", true],
   ["protected", true],
   ["public", true]]);

/*---------------------------------------------------------------------*/
/*    J2SLexer ...                                                     */
/*---------------------------------------------------------------------*/
/* @sealed */
class J2SLexer extends Lexer {
   eof(port, ...opts) {
      return new Token("EOF", "eof", makeLoc(port));
   }

   error(port, ...opts) {
      const str = port.buffer.substring(port.offset, port.offset + 20);
      return new Token("ERROR", str + "...", makeLoc(port));
   }

   match(port, val, rule, ...opts) {
      switch (rule.type) {
	 case "BLANK":
	 case "COMMENT":
	 case "LINECOMMENT":
	    return { res: "", ignore: true };
	 case "ID":
	    if (keyword.get(val)) {
	       const res = new Token(val, val, makeLoc(port));
	       return { res, ignore: false };
	    } else if (reserved.get(val)) {
	       const res = new Token("RESERVED", val, makeLoc(port));
	       return { res, ignore: false };
	    } else {
	       const res = new Token(rule.type, val, makeLoc(port));
	       return { res, ignore: false };
	    }
	 case "STRING": {
	    const res = new Token("STRING", val.substring(1, val.length-1), makeLoc(port));
	    return { res, ignore: false };
	 }
	 case "OHTML": {
	    const i = val.match(/[ \t\n]/).index;
	    const res = new Token("OHTML", val.substring(0, i), makeLoc(port));
	    port.offset -= (val.length - i);
	    return { res, ignore: false };
	 }
	 case "__SELF__": {
	    const res = new Token(val, val, makeLoc(port));
	    return { res, ignore: false };
	 }
	 default: {
	    const res = new Token(rule.type, val, makeLoc(port));
	    return { res, ignore: false };
	 }
      }
   }
}

/*---------------------------------------------------------------------*/
/*    jsLexer ...                                                      */
/*---------------------------------------------------------------------*/
const jsLexer = new J2SLexer(jsRules);

/*---------------------------------------------------------------------*/
/*    j2sLexer ...                                                     */
/*---------------------------------------------------------------------*/
export function j2sLexer() {
   return jsLexer;
}

/*---------------------------------------------------------------------*/
/*    rxLexer ...                                                      */
/*---------------------------------------------------------------------*/
const rxLexer = new J2SLexer([]);

/*---------------------------------------------------------------------*/
/*    j2sRegexLexer ...                                                */
/*---------------------------------------------------------------------*/
export function j2sRegexLexer() {
   return rxLexer;
}
