/*=====================================================================*/
/*    .../hop/work/NODE/node_modules/@hop/hopc/lib/html.mjs            */
/*    -------------------------------------------------------------    */
/*    Author      :  manuel serrano                                    */
/*    Creation    :  Sun Sep 17 16:21:38 2023                          */
/*    Last change :  Fri Jan 19 08:51:56 2024 (serrano)                */
/*    Copyright   :  2023-24 manuel serrano                            */
/*    -------------------------------------------------------------    */
/*    HTML parser                                                      */
/*=====================================================================*/
"use strict";

/*---------------------------------------------------------------------*/
/*    The module                                                       */
/*---------------------------------------------------------------------*/
import { configGet, configAdd } from "./config.mjs";
import { Lexer, makeLoc, Location, read_rp, locOffset } from "./reader.mjs";
import { J2SString, J2SUndefined, J2SCall } from "./ast.mjs";
import { tokenType, tokenValue, tokenLoc, Token } from "./token.mjs";
import { inputPortName, inputPortPosition, } from "./utils.mjs";
import { nullp, pairp, cons, car, cdr, list, length,
	 reverse$, reverse, append,
	 map, map$, find, filter, filterMap, forEach } from "./list.mjs";
import { j2sTagtoexpr } from "./parser.mjs";
import { $ioParseError } from "./error.mjs";

/*---------------------------------------------------------------------*/
/*    htmlParser ...                                                   */
/*---------------------------------------------------------------------*/
export function htmlParser(port, conf, parser, plugins, tag, sep) {
   const lang = configGet(conf, "language", "hopscript");

   if (tag) {
      const xmlGrammar = new XMLLexer(xmlRules, 
				      /* stack */ null,
				      /* stricttag */ lang === "hopscript",
				      /* strictattr */ false,
				      /* decoder */ x => x,
				      /* encoding */ undefined,
				      /* lang */ lang,
				      /* conf */ conf,
				      /* parser */ parser,
				      /* plugins */ plugins);
      // move at the open tag location
      port.offset = tokenLoc(tag).offset;
      return read_rp(xmlGrammar, port);
   } else {
      while (true) {
	 const xmlGrammar = new XMLLexer(xmlRules,
					 /* stack */ null,
					 /* stricttag */ lang === "hopscript",
					 /* strictattr */ false,
					 /* decoder */ x => x,
					 /* encoding */ undefined,
					 /* lang */ lang,
					 /* conf */ conf,
					 /* parser */ parser,
					 /* plugins */ plugins);
					 
	 const v = read_rp(xmlGrammar, port);

	 if (v instanceof J2SString) {
	    if (v.value.match(/[^ \n\t]/)) {
	       return v;
	    }
	 } else {
	    return v;
	 }
      }
   }
}

/*---------------------------------------------------------------------*/
/*    xmlRules ...                                                     */
/*---------------------------------------------------------------------*/
const xmlRules = [
   // blank
   {rx: /[ \t\n\r]+/y, type: "BLANK"},
   {rx: /[ \t]*[\n][ \t]*/y, type: "NEWLINE"},
   {rx: /<[a-zA-Z!?][a-zA-Z0-9:_.-]*>/y, type: "OHTML"},
   {rx: /<\/[a-zA-Z!?][a-zA-Z0-9:_.-]*>/y, type: "CHTML"},
   {rx: /<[a-zA-Z!?][a-zA-Z0-9:_.-]*[ \n\t\r]/y, type: "OTAG"},
   {rx: /(?:[^<$~]|[$~][^{])+/y, type: "STRING"}
];

/*---------------------------------------------------------------------*/
/*    XMLLexer ...                                                     */
/*---------------------------------------------------------------------*/
/* @sealed */
class XMLLexer extends Lexer {
   #stack;
   #stricttag;
   #strictattr;
   #decoder;
   #encoding;
   #lang;
   #conf;
   #parser;
   #plugins;

   constructor(rules, stack, stricttag, strictattr, decoder, encoding, lang, conf, parser, plugins) {
      super(rules);
      this.#stack = stack;
      this.#stricttag = stricttag;
      this.#strictattr = strictattr;
      this.#decoder = decoder;
      this.#encoding = encoding;
      this.#lang = lang;
      this.#conf = conf;
      this.#parser = parser;
      this.#plugins = plugins;
   }

   eof(port) {
      return new Token("EOF", "eof", makeLoc(port));
   }

   error(port) {
      const str = port.buffer.substring(port.offset, port.offset + 20);
      return new Token("ERROR", str + "...", makeLoc(port));
   }

   pushIgnore(node) {
      this.#stack = cons(node, this.#stack);
      return { res: false, ignore: true };
   }

   pushNodeIgnore(stack, val) {
      if (stack.length === 0) {
	 return {res: val, ignore: false};
      } else {
	 return this.push(val);
      }
   }

   openTag(type, sym, attributes, port) {
      const prop = htmlElementsProperties[sym];

      if (prop && prop.empty) {
	 const tag = new Token(type, sym, makeLoc(port));
	 const node = makeDomCreate(tag, attributes, [], this.#lang, this.#conf);
	 return this.pushNodeIgnore(node);
      } else if (prop && prop.script) {
	 const tag = new Token(type, sym, makeLoc(port));
	 const script = htmlParseScript(port, this.#conf, this.#plugins);
	 const node = makeDomCreate(tag, attributes, [script], this.#lang, this.#conf);
	 return this.pushNodeIgnore(node);
      } else {
	 const tag = new Token(type, sym, makeLoc(port));
	 const el = new Element(tag, attributes, prop && prop.children);
	 const s = findSpecial(this.#stack);

	 if (s) {
	    const sp = elementProp(s);
	    const spchd = sp && sp.children;

	    if (spchd === "inline") {
	    } else if (spchd === "flow") {
	    } else if (spchd instanceof Array) {
	       if (spchd.indexOf(sym) >= 0) {
		  console.error("not implemented");
	       }
	    }
	 }

	 return this.pushIgnore(el);
      }
   }

   match(port, val, rule) {
      switch (rule.type) {
	 case "BLANK":
	 case "STRING": {
	    const props = {
	       escape: ["escape"],
	       val: val,
	       loc: makeLoc(port)
	    }
	    return this.pushIgnore(new J2SString(props));
	 }
	 case "OHTML": {
	    const str = val.toUpperCase();
	    return this.openTag("OHTML", str, null, port);
	 }
	 case "CHTML": {
	    const sym = "<" + val.substring(2, val.length).toUpperCase();
	    if (htmlEmptyElementp(sym)) {
	       return  { res: "", ignore: true };
	    } else {
	       this.#stack = reduceStackUpTo(this.#stack, sym, this.#lang, this.#conf, port, true);
	       if (this.#stack.cdr === null) {
		  return {res: this.#stack.car, ignore: false };
	       } else if (this.#stack.every(o => o instanceof J2SString && o.val.match(/[ \t\n]*/))) {
		  return { res: this.#stack.car, ignore: false };
	       } else {
		  return { res: "", ignore: true };
	       }
	    }
	 }
	 default:
	    console.error("DEFAULT...", rule.type);
      }
   }
}

/*---------------------------------------------------------------------*/
/*    makeDomCreate ...                                                */
/*---------------------------------------------------------------------*/
function makeDomCreate(tag, attributes, body, lang, conf) {
   const attrs = null;
   const abody = null;

   forEach(x => {
      if (x instanceof J2SDataPropertyInit) {
	 attrs = cons(x, attrs);
      } else if (x instanceof J2SExpr) {
	 const val = new J2SString({loc, val: ""});
	 const xp = new J2SDataPropertyInit({loc, name: x, val: val});
	 attrs = cons(xp, attrs);
      } else {
	 return xmlParseError("wrong attribute", tag.value, cadr(loc), caddr(loc));
      }
   }, attributes);
   const loc = tag.loc;
   const inits = reverse$(attrs);
   let a = (inits === null)
      ? new J2SUndefined({loc, type: "undefined"})
      : new J2SObjInit({loc, inits});
   
   return new J2SCall({loc: loc,
		       fun: j2sTagtoexpr(tag, true),
		       thisargs: list(undefined),
		       args: cons(a, body)});
}

/*---------------------------------------------------------------------*/
/*    element ...                                                      */
/*---------------------------------------------------------------------*/
/* @sealed */
class Element {
   tag;
   attributes;
   prop;
   
   constructor(tag, attributes, prop) {
      this.tag = tag;
      this.attributes = attributes;
      this.prop = prop;
   }
}

/*---------------------------------------------------------------------*/
/*    htmlElementsProperties ...                                       */
/*---------------------------------------------------------------------*/
const htmlElementsProperties = {
   "<ADDRESS>": {block: true},
   "<AREA>": {empty: true},
   "<BASE>": {empty: true},
   "<BASEFONT>": {empty: true},
   "<BLOCKQUOTE>": {block: true},
   "<BR>": {empty: true},
   "<COL>": {empty: true},
   "<COLGROUP>": {chidren: ["<COL>"]},
   "<DIV>": {block: true},
   "<DL>": {block: true, children: ["<DD>", "<DT>"]},
   "<DD>": {item: true, children: "flow", "etag-optional": true},
   "<DT>": {item: true, children: "inline", "etag-optional": true},
   "<FIELDSET>": {block: true},
   "<FORM>": {block: true},
   "<FRAME>": {empty: true},
   "<HR>": {empty: true, block: true},
   "<H1>": {block: true},
   "<H2>": {block: true},
   "<H3>": {block: true},
   "<H4>": {block: true},
   "<H5>": {block: true},
   "<H6>": {block: true},
   "<IMG>": {empty: true},
   "<INPUT>": {empty: true},
   "<ISINDEX>": {empty: true},
   "<LI>": {"etag-optional": true},
   "<LINK>": {empty: true},
   "<META>": {empty: true},
   "<NOSCRIPT>": {block: true},
   "<OL>": {block: true},
   "<P>": {block: true, children: "inline", "etag-optional": true},
   "<PARAM>": {empty: true},
   "<PRE>": {block: true},
   "<SCRIPT>": {script: true},
   "<TABLE>": {block: true},
   "<UL>": {block: true}
};
   
/*---------------------------------------------------------------------*/
/*    htmlEmptyElements ...                                            */
/*---------------------------------------------------------------------*/
const htmlEmptyElements = [ "AREA", "BASE", "BASEFONT", "BR", "COL", "FRAME",
			    "HR", "IMG", "INPUT", "ISINDEX", "LINK",
			    "META", "PARAM" ];

/*---------------------------------------------------------------------*/
/*    findSpecial ...                                                  */
/*---------------------------------------------------------------------*/
function findSpecial(stack) {
   return find(e => false, stack);
}

/*---------------------------------------------------------------------*/
/*    htmlEmptyElementp ...                                            */
/*---------------------------------------------------------------------*/
function htmlEmptyElementp(tag) {
   return htmlEmptyElements.indexOf(tag) >= 0;
}

/*---------------------------------------------------------------------*/
/*    htmlPropertyEtagOptionalp ...                                    */
/*---------------------------------------------------------------------*/
function htmlPropertyEtagOptionalp(prop) {
   return prop["etag-optional"];
}
   
/*---------------------------------------------------------------------*/
/*    reduceStackUpTo ...                                              */
/*---------------------------------------------------------------------*/
function reduceStackUpTo(stack, ctag, lang, conf, port, stricttag) {
   
   function tagname(tag) {
      return tag.substring(1, tag.length - 1);
   }

   let stk = stack
   let args = null;
   
   while (true) {
      if (stk === null) {
	 return xmlParseError("wrong closing tag", tagname(ctag), inputPortName(port), inputPortPosition(port));
      } else if (!(stk.car instanceof Element)) {
	 args = cons(stack.car, args);
	 stk = stk.cdr;
      } else if (stk.car.tag.value === ctag) {
	 const tag = stk.car.tag;
	 const attrs = stk.car.attributes;
	 const node = makeDomCreate(tag, attrs, args, lang, conf);
	 return cons(node, stk.cdr);
      } else if (htmlPropertyEtagOptionalp(stk.car.tag.value)) {
	 const tag = stk.car.tag;
	 const attrs = stk.car.attributes;
	 args = cons(makeDomCreate(tag, attrs, args, lang, conf), null);
	 stk = stk.cdr;
      } else if (stricttag) {
	 return xmlParseError(`tag mismatch: </${tagname(stk.car.tag.value)}> expected, </${tagname(ctag)}> provided`, undefined, inputPortName(port), inputPortPosition(port));
      } else {
	 return stk;
      }
   }
}

/*---------------------------------------------------------------------*/
/*    xmlParseError ...                                                */
/*---------------------------------------------------------------------*/
function xmlParseError(msg, obj, name, pos) {
   throw new $ioParseError({proc: "xml-parse", msg: msg, obj: obj, fname: name, location: pos });
}

