/*=====================================================================*/
/*    .../hop/work/NODE/node_modules/@hop/hopc/lib/html.mjs            */
/*    -------------------------------------------------------------    */
/*    Author      :  manuel serrano                                    */
/*    Creation    :  Sun Sep 17 16:21:38 2023                          */
/*    Last change :  Thu Jan 18 18:44:02 2024 (serrano)                */
/*    Copyright   :  2023-24 manuel serrano                            */
/*    -------------------------------------------------------------    */
/*    HTML parser                                                      */
/*=====================================================================*/
"use strict";

/*---------------------------------------------------------------------*/
/*    The module                                                       */
/*---------------------------------------------------------------------*/
import { configGet, configAdd } from "./config.mjs";
import { Lexer, makeLoc, Location, read_rp, locOffset } from "./reader.mjs";
import { J2SString } from "./ast.mjs";
import { tokenType, tokenValue, tokenLoc, Token } from "./token.mjs";
import { inputPortName, inputPortPosition, } from "./utils.mjs";
import { nullp, pairp, cons, car, cdr, list, length,
	 reverse$, reverse, append,
	 map, map$, find, filter, filterMap } from "./list.mjs";
import { j2sTagtoexpr } from "./parser.mjs";

/*---------------------------------------------------------------------*/
/*    htmlParser ...                                                   */
/*---------------------------------------------------------------------*/
export function htmlParser(port, conf, parser, plugins, tag, sep) {
   const lang = configGet(conf, "language", "hopscript");
   console.error("htmlParse lang=", lang, "tag=", tag);
   if (tag) {
      // move at the open tag location
      port.offset = tokenLoc(tag).offset;
      
      return read_rp(xmlGrammar, port,
		     /* stack */ [],
		     /* stricttag */ lang === "hopscript",
		     /* strictattr */ false,
		     /* decoder */ x => x,
		     /* encoding */ undefined,
		     /* lang */ lang,
		     /* conf */ conf,
		     /* parser */ parser,
		     /* plugins */ plugins);
   } else {
      while (true) {
	 const v = read_rp(xmlGrammar, port,
			   /* stack */ [],
			   /* stricttag */ lang === "hopscript",
			   /* strictattr */ false,
			   /* decoder */ x => x,
			   /* encoding */ undefined,
			   /* lang */ lang,
			   /* conf */ conf,
			   /* parser */ parser,
			   /* plugins */ plugins);

	 if (v instanceof J2SString) {
	    if (v.value.match(/[^ \n\t]/)) {
	       return v;
	    }
	 } else {
	    return v;
	 }
      }
   }
}

/*---------------------------------------------------------------------*/
/*    xmlRules ...                                                     */
/*---------------------------------------------------------------------*/
const xmlRules = [
   // blank
   {rx: /[ \t\n\r]+/y, type: "BLANK"},
   {rx: /[ \t]*[\n][ \t]*/y, type: "NEWLINE"},
   {rx: /<[a-zA-Z!?][a-zA-Z0-9:_.-]*>/y, type: "OHTML"},
   {rx: /<\/[a-zA-Z!?][a-zA-Z0-9:_.-]*>/y, type: "CHTML"},
   {rx: /<[a-zA-Z!?][a-zA-Z0-9:_.-]*[ \n\t\r]/y, type: "OTAG"},
   {rx: /(?:[^<$~]|[$~][^{])+/y, type: "STRING"}
];

/*---------------------------------------------------------------------*/
/*    XMLLexer ...                                                     */
/*---------------------------------------------------------------------*/
/* @sealed */
class XMLLexer extends Lexer {
   eof(port, stack, stricttag, strictattr, decoder, encoding, lang, conf, parser, plugins) {
      return new Token("EOF", "eof", makeLoc(port));
   }

   error(port, stack, stricttag, strictattr, decoder, encoding, lang, conf, parser, plusing) {
      const str = port.buffer.substring(port.offset, port.offset + 20);
      return new Token("ERROR", str + "...", makeLoc(port));
   }

   match(port, val, rule, stack, stricttag, strictattr, decoder, encoding, lang, conf, parser, plugins) {
      switch (rule.type) {
	 case "BLANK":
	 case "STRING": {
	    const props = {
	       escape: ["escape"],
	       val: val,
	       loc: makeLoc(port)
	    }
	    return pushIgnore(stack, new J2SString(props));
	 }
	 case "OHTML": {
	    const str = val.toUpperCase();
	    return openTag("OHTML", str, null, port, stack, lang, conf, plugins);
	 }
	 case "CHTML": {
	    const sym = val.substring(2, val.length-1).toUpperCase();
	    if (htmlEmptyElementp(sym)) {
	       return  { res: "", ignore: true };
	    } else {
	       stack = reduceStackUpTo(stack, sym, lang, conf, port, true);
	       if (stack.cdr === null) {
		  return stack.car;
	       } else if (stack.every(o => o instanceof J2SString && o.val.match(/[ \t\n]*/))) {
		  return stack.car;
	       } else {
		  return { res: "", ignore: true };
	       }
	    }
	 }
	 default:
	    console.error("DEFAULT...", rule.type);
      }
   }
}

/*---------------------------------------------------------------------*/
/*    pushIgnore ...                                                   */
/*---------------------------------------------------------------------*/
function pushIgnore(stack, tok) {
   stack.push(tok);
   return { res: "", ignore: true };
}

/*---------------------------------------------------------------------*/
/*    pushNodeIgnore ...                                               */
/*---------------------------------------------------------------------*/
function pushNodeIgnore(stack, val) {
   if (stack.length === 0) {
      return {res: val, ignore: false};
   } else {
      stack.push(val);
      return {res: false, ignore: true};
   }
}

/*---------------------------------------------------------------------*/
/*    makeDomCreate ...                                                */
/*---------------------------------------------------------------------*/
function makeDomCreate(tag, attributes, body, lang, conf) {
   const attrs = null;
   const abody = null;

   attributes.forEach(x => {
      if (x instanceof J2SDataPropertyInit) {
	 ...
      } else if (x instanceof J2SExpr) {
	 ...
      } else {
	 return xmlParseError("wrong attribute", tag.value, cadr(loc), caddr(loc));
      }
   }
   const loc = tag.loc;
   const inits = reverse(attrs);
   let a = (inits === null)\
      ? new J2SUndefined({loc, type: "undefined"})
      : new J2SObjInit({loc, inits});
   
   return new J2SCall({loc: loc,
		       fun: j2sTagtoexpr(tag, true),
		       thisargs: list(undefined),
		       args: cons(a, body)});
}

/*---------------------------------------------------------------------*/
/*    element ...                                                      */
/*---------------------------------------------------------------------*/
/* @sealed */
class Element {
   tag;
   attributes;
   prop;
   
   constructor(tag, attributes, prop) {
      this.tag = tag;
      this.attributes = attributes;
      this.prop = prop;
   }
}

/*---------------------------------------------------------------------*/
/*    htmlElementsProperties ...                                       */
/*---------------------------------------------------------------------*/
const htmlElementsProperties = {
   "<ADDRESS>": {block: true},
   "<AREA>": {empty: true},
   "<BASE>": {empty: true},
   "<BASEFONT>": {empty: true},
   "<BLOCKQUOTE>": {block: true},
   "<BR>": {empty: true},
   "<COL>": {empty: true},
   "<COLGROUP>": {chidren: ["<COL>"]},
   "<DIV>": {block: true},
   "<DL>": {block: true, children: ["<DD>", "<DT>"]},
   "<DD>": {item: true, children: "flow", "etag-optional": true},
   "<DT>": {item: true, children: "inline", "etag-optional": true},
   "<FIELDSET>": {block: true},
   "<FORM>": {block: true},
   "<FRAME>": {empty: true},
   "<HR>": {empty: true, block: true},
   "<H1>": {block: true},
   "<H2>": {block: true},
   "<H3>": {block: true},
   "<H4>": {block: true},
   "<H5>": {block: true},
   "<H6>": {block: true},
   "<IMG>": {empty: true},
   "<INPUT>": {empty: true},
   "<ISINDEX>": {empty: true},
   "<LI>": {"etag-optional": true},
   "<LINK>": {empty: true},
   "<META>": {empty: true},
   "<NOSCRIPT>": {block: true},
   "<OL>": {block: true},
   "<P>": {block: true, children: "inline", "etag-optional": true},
   "<PARAM>": {empty: true},
   "<PRE>": {block: true},
   "<SCRIPT>": {script: true},
   "<TABLE>": {block: true},
   "<UL>": {block: true}
};
   
/*---------------------------------------------------------------------*/
/*    openTag ...                                                      */
/*---------------------------------------------------------------------*/
function openTag(type, sym, attributes, port, stack, lang, conf, plugins) {
   const prop = htmlElementsProperties[sym];

   if (prop && prop.empty) {
      const tag = new Token(type, sym, makeLoc(port));
      const node = makeDomCreate(tag, attributes, [], lang, conf);
      return pushNodeIgnore(stack, node);
   } else if (prop && prop.script) {
      const tag = new Token(type, sym, makeLoc(port));
      const script = htmlParseScript(port, conf, plugins);
      const node = makeDomCreate(tag, attributes, [script], lang, conf);
      return pushNodeIgnore(stack, node);
   } else {
      const tag = new Token(type, sym, makeLoc(port));
      const el = new Element(tag, attributes, prop && prop.children);
      const s = findSpecial(stack);

      if (s) {
	 const sp = elementProp(s);
	 const spchd = sp && sp.children;

	 if (spchd === "inline") {
	 } else if (spchd === "flow") {
	 } else if (spchd instanceof Array) {
	    if (spchd.indexOf(sym) >= 0) {
	       console.error("not implemented");
	    }
	 }
      }

      return pushIgnore(stack, el);
   }
}

/*---------------------------------------------------------------------*/
/*    findSpecial ...                                                  */
/*---------------------------------------------------------------------*/
function findSpecial(stack) {
   return stack.find(e => false);
}

/*---------------------------------------------------------------------*/
/*    htmlEmptyElements ...                                            */
/*---------------------------------------------------------------------*/
const htmlEmptyElements = [ "AREA", "BASE", "BASEFONT", "BR", "COL", "FRAME",
			    "HR", "IMG", "INPUT", "ISINDEX", "LINK",
			    "META", "PARAM" ];

/*---------------------------------------------------------------------*/
/*    htmlEmptyElementp ...                                            */
/*---------------------------------------------------------------------*/
function htmlEmptyElementp(tag) {
   return htmlEmptyElements.indexOf(tag) >= 0;
}

/*---------------------------------------------------------------------*/
/*    reduceStackUpTo ...                                              */
/*---------------------------------------------------------------------*/
function reduceStackUpTo(stack, ctag, lang, conf, port, stricttag) {
   
   function tagname(tag) {
      return tag.substring(1, tag.length - 1);
   }

   let stk = stack
   let args = null;
   
   while (true) {
      if (stk === null) {
	 return xmlParseError("wrong closing tag", tagname(ctag), inputPortName(port), inputPortPosition(port));
      } else if (!(stack.car instanceof XMLElement)) {
	 args = cons(stack.car, args);
	 stk = stk.cdr;
      } else if (stk.car.tag.value === ctag) {
	 const tag = stk.car.tag;
	 const attrs = stk.car.attributes;
	 const node = makeDomeCreate(tag, attrs, args, lang, conf);
	 return cons(node, stk.cdr);
      } else if (htmlPropertyEtagOptionalp(stk.car.tag.value)) {
	 const tag = stk.car.tag;
	 const attrs = stk.car.attributes;
	 args = cons(makeDomeCreate(tag, attrs, args, lang conf), null);
	 stk = stk.cdr;;
      } else if (stricttag) {
	 return xmlParseError("tag mismatch", `</${tagname(stk.car.tag.value)}> expected, </${tagname(ctag)}> provided`, inputPortName(port), inputPortPosition(port));
      } else {
	 return stk;
      }
   }
}

/*---------------------------------------------------------------------*/
/*    xmlParseError ...                                                */
/*---------------------------------------------------------------------*/
function xmlParseError(msg, obj, name, pos) {
   throw $ioParseError({proc: "xml-parse", msg: msg, obj: obj, fname: name, location: pos });
   
/*---------------------------------------------------------------------*/
/*    xmlGrammar ...                                                   */
/*---------------------------------------------------------------------*/
const xmlGrammar = new XMLLexer(xmlRules);

