/*=====================================================================*/
/*    serrano/prgm/project/hop/hop2js/html.mjs                         */
/*    -------------------------------------------------------------    */
/*    Author      :  manuel serrano                                    */
/*    Creation    :  Sun Sep 17 16:21:38 2023                          */
/*    Last change :  Mon Sep 18 09:22:51 2023 (serrano)                */
/*    Copyright   :  2023 manuel serrano                               */
/*    -------------------------------------------------------------    */
/*    HTML parser                                                      */
/*=====================================================================*/
"use strict";

/*---------------------------------------------------------------------*/
/*    The module                                                       */
/*---------------------------------------------------------------------*/
import { configGet, configAdd$ } from "./config.mjs";
import { Lexer, makeLoc, Location, read_rp, locOffset } from "./reader.mjs";
import { J2SString } from "./ast.mjs";
import { tokenType, tokenValue, tokenLoc, Token} from "./token.mjs";
import { nullp, pairp, cons, car, cdr, list, length,
	 reverse$, reverse, append,
	 map, map$, find, filter, filterMap } from "./list.mjs";

/*---------------------------------------------------------------------*/
/*    htmlParser ...                                                   */
/*---------------------------------------------------------------------*/
export function htmlParser(port, conf, parser, plugins, tag, sep) {
   const lang = configGet(conf, "language", "hopscript");
   if (tag) {
      // move at the open tag location
      port.offset = tokenLoc(tag).offset;
      
      return read_rp(xmlGrammar, port,
		     /* stack */ [],
		     /* stricttag */ lang === "hopscript",
		     /* strictattr */ false,
		     /* decoder */ x => x,
		     /* encoding */ undefined,
		     /* lang */ lang,
		     /* conf */ conf,
		     /* parser */ parser,
		     /* plugins */ plugins);
   } else {
      while (true) {
	 const v = read_rp(xmlGrammar, port,
			   /* stack */ [],
			   /* stricttag */ lang === "hopscript",
			   /* strictattr */ false,
			   /* decoder */ x => x,
			   /* encoding */ undefined,
			   /* lang */ lang,
			   /* conf */ conf,
			   /* parser */ parser,
			   /* plugins */ plugins);

	 if (v instanceof J2SString) {
	    if (v.val.match(/[^ \n\t]/)) {
	       return v;
	    }
	 } else {
	    return v;
	 }
      }
   }
}

/*---------------------------------------------------------------------*/
/*    xmlRules ...                                                     */
/*---------------------------------------------------------------------*/
const xmlRules = [
   // blank
   {rx: /[ \t\n\r]+/y, type: "BLANK"},
   {rx: /[ \t]*[\n][ \t]*/y, type: "NEWLINE"},
   {rx: /<[a-zA-Z!?][a-zA-Z0-9:_.-]*>"/y, type: "OHTML"},
   {rx: /<[a-zA-Z!?][a-zA-Z0-9:_.-]*[ \n\t\r]/y, type: "OTAG"}
];

/*---------------------------------------------------------------------*/
/*    XMLLexer ...                                                     */
/*---------------------------------------------------------------------*/
/* @sealed */
class XMLLexer extends Lexer {
   eof(port, stack, stricttag, strictattr, decoder, encoding, lang, conf, parser, plugins) {
      return new Token("EOF", "eof", makeLoc(port));
   }

   error(port, stack, stricttag, strictattr, decoder, encoding, lang, conf, parser, plusing) {
      const str = port.buffer.substring(port.offset, port.offset + 20);
      return new Token("ERROR", str + "...", makeLoc(port));
   }

   match(port, val, rule, stack, stricttag, strictattr, decoder, encoding, lang, conf, parser, plugins) {
      switch (rule.type) {
	 case "BLANK": {
	    const props = {
	       escape: ["escape"],
	       val: val,
	       loc: makeLoc(port)
	    }
	    return pushIgnore(stack, new J2SString(props));
	 }
	 case "OTAG": {
	    const str = val.toUpperCase();
	    return openTag("HTML", str, null, port, stack, lang, conf, plugins);
	 }
      }
   }
}

/*---------------------------------------------------------------------*/
/*    pushIgnore ...                                                   */
/*---------------------------------------------------------------------*/
function pushIgnore(stack, tok) {
   stack.push(tok);
   return { res: "", ignore: true };
}

/*---------------------------------------------------------------------*/
/*    pushNodeIgnore ...                                               */
/*---------------------------------------------------------------------*/
function pushNodeIgnore(stack, val) {
   if (stack.length === 0) {
      return {res: val, ignore: false};
   } else {
      stack.push(val);
      return {res: false, ignore: true};
   }
}

/*---------------------------------------------------------------------*/
/*    makeDomCreate ...                                                */
/*---------------------------------------------------------------------*/
function makeDomCreate(tag, attributes, body, lang, conf) {
   return new J2SCall({loc: loc,
		       fun: j2sTagExpr(tag, true),
		       thisargs: list(undefined),
		       args: cons(a, body)});
}

/*---------------------------------------------------------------------*/
/*    element ...                                                      */
/*---------------------------------------------------------------------*/
/* @sealed */
class Element {
   tag;
   attributes;
   prop;
   
   constructor(tag, attributes, prop) {
      this.tag = tag;
      this.attributes = attributes;
      this.prop = prop;
   }
}

/*---------------------------------------------------------------------*/
/*    htmlElementsProperties ...                                       */
/*---------------------------------------------------------------------*/
const htmlElementsProperties = {
   "<ADDRESS>": {block: true},
   "<AREA>": {empty: true},
   "<BASE>": {empty: true},
   "<BASEFONT>": {empty: true},
   "<BLOCKQUOTE>": {block: true},
   "<BR>": {empty: true},
   "<COL>": {empty: true},
   "<COLGROUP>": {chidren: ["<COL>"]},
   "<DIV>": {block: true},
   "<DL>": {block: true, children: ["<DD>", "<DT>"]},
   "<DD>": {item: true, children: "flow", "etag-optional": true},
   "<DT>": {item: true, children: "inline", "etag-optional": true},
   "<FIELDSET>": {block: true},
   "<FORM>": {block: true},
   "<FRAME>": {empty: true},
   "<HR>": {empty: true, block: true},
   "<H1>": {block: true},
   "<H2>": {block: true},
   "<H3>": {block: true},
   "<H4>": {block: true},
   "<H5>": {block: true},
   "<H6>": {block: true},
   "<IMG>": {empty: true},
   "<INPUT>": {empty: true},
   "<ISINDEX>": {empty: true},
   "<LI>": {"etag-optional": true},
   "<LINK>": {empty: true},
   "<META>": {empty: true},
   "<NOSCRIPT>": {block: true},
   "<OL>": {block: true},
   "<P>": {block: true, children: "inline", "etag-optional": true},
   "<PARAM>": {empty: true},
   "<PRE>": {block: true},
   "<SCRIPT>": {script: true},
   "<TABLE>": {block: true},
   "<UL>": {block: true}
};
   
/*---------------------------------------------------------------------*/
/*    openTag ...                                                      */
/*---------------------------------------------------------------------*/
function openTag(type, sym, attributes, port, stack, lang, conf, plugins) {
   const prop = htmlElementsProperties[sym];

   if (prop && prop.empty) {
      const tag = new Token(type, sym, makeLoc(port));
      const node = makeDomCreate(tag, attributes, [], lang, conf);
      return pushNodeIgnore(stack, node);
   } else if (prop && prop.script) {
      const tag = new Token(type, sym, makeLoc(port));
      const script = htmlParseScript(port, conf, plugins);
      const node = makeDomCreate(tag, attributes, [script], lang, conf);
      return pushNodeIgnore(stack, node);
   } else {
      const tag = new Token(type, sym, makeLoc(port));
      const el = new Element(tag, attributes, prop && prop.children);
      const s = findSpecial(stack);

      if (s) {
	 const sp = elementProp(s);
	 const spchd = sp && sp.children;

	 if (spchd === "inline") {
	 } else if (spchd === "flow") {
	 } else if (spchd instanceof Array) {
	    if (spchd.indexOf(sym) >= 0) {
	       console.error("not implemented");
	    }
	 }
      }

      return pushIgnore(stack, el);
   }
}

/*---------------------------------------------------------------------*/
/*    findSpecial ...                                                  */
/*---------------------------------------------------------------------*/
function findSpecial(stack) {
   return stack.find(e => false);
}

/*---------------------------------------------------------------------*/
/*    xmlGrammar ...                                                   */
/*---------------------------------------------------------------------*/
const xmlGrammar = new XMLLexer(xmlRules);

