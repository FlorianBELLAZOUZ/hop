;*=====================================================================*/
;*    serrano/prgm/project/hop/3.7.x/node_modules/hopc/mkjsast.scm     */
;*    -------------------------------------------------------------    */
;*    Author      :  Manuel Serrano                                    */
;*    Creation    :  Tue Jul  1 16:05:56 2014                          */
;*    Last change :  Thu Dec  7 08:22:49 2023 (serrano)                */
;*    Copyright   :  2014-23 Manuel Serrano                            */
;*    -------------------------------------------------------------    */
;*    Build the JS Ast from the Bigloo type class hierarchy            */
;*=====================================================================*/

;*---------------------------------------------------------------------*/
;*    The module                                                       */
;*---------------------------------------------------------------------*/
(module mkjsast
   (main main))

;*---------------------------------------------------------------------*/
;*    main ...                                                         */
;*---------------------------------------------------------------------*/
(define (main argv)
   (cond
      ((string=? (cadr argv) "hop")
       (call-with-input-file (string-append (caddr argv) ".scm")
	  (lambda (ip)
	     (match-case (read ip)
		((module ?- ??- (export . ?clauses) . ?-)
		 (print "// generated by " (pwd) "/mkjast.scm")
		 (print "\"use strict\"")
		 (newline)
		 (print tojson)
		 (let ((env (filter-map parse-class clauses)))
		    (for-each (lambda (c) (print-class-hop c env)) env)))))))
      ((string=? (cadr argv) "node")
       (call-with-input-file (string-append (caddr argv) ".scm")
	  (lambda (ip)
	     (match-case (read ip)
		((module ?- ??- (export . ?clauses) . ?-)
		 (print "// generated by " (pwd) "/mkjast.scm")
		 (print "\"use strict\"")
		 (newline)
		 (print "import { Cons, array2list } from \"./list.mjs\";")
		 (newline)
		 (let ((env (filter-map parse-class clauses)))
		    (for-each (lambda (c) (print-class-node c env)) env)
		    ;; global export
		    (printf "export let ast = { ~(, )\n}\n"
		       (filter-map (lambda (c)
				      (let ((name (car c)))
					 (format "\"~a\": ~a" name name)))
			  env))))))))))

;*---------------------------------------------------------------------*/
;*    tojson ...                                                       */
;*---------------------------------------------------------------------*/
(define tojson
   "export function tojson( obj ) {
  if( !(obj instanceof Object) ) {
     if( obj === undefined ) {
	return '{ \"__undefined__\": \"undefined\" }';
     } else {
        return JSON.stringify( obj );
     }
  } else if( 'tojson' in obj ) {
     return obj.tojson();
  } else if( obj instanceof Array ) {
     return '[' + obj.map( tojson ).join( \",\" ) + ']';
  } else if( '__ast__' in obj ) {
     return '{ \"__ast__\": ' + obj.__ast__.tojson() + '}';
  } else if( obj instanceof Object ) {
     return '{' + Object.keys( obj ).map( function( k ) {
          return '\"' + k + '\": ' + tojson( obj[ k ] );
       } ).join( \",\" ) + '}';
  } else {
     return obj.toString();
  }
};")

;*---------------------------------------------------------------------*/
;*    print-class-hop ...                                              */
;*---------------------------------------------------------------------*/
(define (print-class-hop class env)

   (define (tojson name fields)
      (printf "Object.defineProperty( ~a.prototype, 'tojson', { value: function() {\n" name)
      (printf "   return '{ \"__node__\": \"~a\"'" name)
      (for-each (lambda (f)
		   (if (cadr f)
		       (printf "\n      + ', \"~a\":' + (this.~a ? '{ \"__ref__\":' +  this.~a.key + '}' : false)"
			  (car f) (car f) (car f))
		       (printf "\n      + ', \"~a\":' + tojson( this[ \"~a\" ] )"
			  (car f) (car f))))
	 fields)
      (display "\n      + '}';\n")
      (printf "}, enumerable: false } ); \n"))
   
   (match-case class
      ((?- #t . ?-)
       ;; already printed class
       #unspecified)
      ((?name #f #f ?fields)
       ;; root class
       (set-car! (cdr class) #t)
       (printf "export function ~a(~(, )) {\n" name (map arg-name fields))
       (printf "   this.__node__ = \"~a\";\n" name)
       (for-each (lambda (f)
		    (printf "   this[~s] = ~a;\n"
		       (symbol->string (car f)) (arg-name f))) fields)
       (printf "}\n")
       (when (any cdr fields)
	  (tojson name fields))
       (newline))
      ((?name #f ?super ?fields)
       ;; unprinted subclass
       (let* ((fields fields)
	      (superfields (class-superfields super env))
	      (allfields (append superfields fields)))
	  (set-car! (cdr class) #t)
	  (printf "export function ~a(~(, )) {\n" name (map arg-name allfields))
	  (if (pair? superfields)
	      (printf "   ~a.call(this, ~(, ));\n"
		 super (map arg-name superfields))
	      (printf "   ~a.call( this );\n" super))
	  (for-each (lambda (f)
		       (printf "   this[~s] = ~a;\n"
			  (symbol->string (car f)) (arg-name f)))
	     fields)
	  (printf "   this.__node__ = \"~a\";\n" name)
	  (printf "}\n")
	  (printf "~a.prototype = new ~a;\n" name super)
	  (tojson name allfields)))))

;*---------------------------------------------------------------------*/
;*    *ast-decl-key* ...                                               */
;*---------------------------------------------------------------------*/
(define *ast-decl-key* 0)

;*---------------------------------------------------------------------*/
;*    ast-decl-key ...                                                 */
;*---------------------------------------------------------------------*/
(define (ast-decl-key)
   (let ((v (+fx 1 *ast-decl-key*)))
      (set! *ast-decl-key* v)
      v))

;*---------------------------------------------------------------------*/
;*    print-class-node ...                                             */
;*    -------------------------------------------------------------    */
;*    The constructor is complex because of backward compatibilty.     */
;*    The are three usage cases, each corresponding to a prototocole:  */
;*                                                                     */
;*      1- the constructor is used as a plain function, i.e., not a    */
;*         constructor, invokes recursively with protocol 3.           */
;*                                                                     */
;*      2- the first element (the "loc") is a pair (this is used       */
;*         by the HipHop parser). All but the first elements are       */
;*         JavaScript values that have to be converted as Scheme       */
;*         values.                                                     */
;*                                                                     */
;*      3- The first element is an array (this is used by the          */
;*         hopc/parser). All the elements have to be converted         */
;*         from JavaScript to Scheme.                                  */
;*---------------------------------------------------------------------*/
(define (print-class-node class env)

   (define (arg-prop arg)
      (let ((name (arg-name arg))
	    (typ (arg-type arg)))
	 (if (memq typ '(pair pair-nil))
	     (format "\"~a\": array2list(~a)" name name)
	     (format "\"~a\": ~a" name name))))

   (define (tojs val)
      (match-case val
	 (#f "false")
	 (#t "true")
	 (#unspecified "undefined")
	 ((and (? number?)) val)
	 ((and (? string?)) (format "~s" val))
	 (((kwote quote) (and ?sym (? symbol?))) (format "'~a'" (symbol->string sym)))
	 (((kwote quote) ()) "null")
	 ((ast-decl-key) (ast-decl-key))
	 ((usage (quote ())) "{}")
	 ((gensym (quote ?sym)) (format "'~a'" (symbol->string (gensym sym))))
	 ((pwd) (format "~s" (pwd)))
	 (else (error (car class) "Unspported default value" val))))

   (define (print-class name super fields)
      (printf "export function ~a(~(, )) {\n" name (map arg-name fields))
      (printf "  if (!new.target) {\n")
      (printf "    return new ~a({~(, )});\n" name (map arg-prop fields))
      (printf "  } else {\n")
      (printf "    this.$class = '~a';\n" name)
      (printf "    if (~a) {\n" (arg-name (car fields)))
      (printf "      if (~a instanceof Cons) {\n" (arg-name (car fields)))
      (printf "        this.~a = ~a;\n" (arg-name (car fields)) (arg-name (car fields)))
      (for-each (lambda (field)
		   (let ((n (arg-field field))
			 (p (arg-name field)))
		      (cond
			 ((memq (arg-type field) '(pair pair-nil))
			  (printf "        this~a = array2list(~a);\n" n p))
			 ((eq? (arg-type field) 'symbol)
			  ;; symbol.toString() -> "Symbol(the-string)"
			  (printf "        this~a = typeof(~a) === 'symbol' ? ~a.toString().slice(7,-1) : ~a;\n" n p p p))
			 (else
			  (printf "        this~a = ~a;\n" n p)))))
	 (cdr fields))
      (printf "      } else {\n")
      (for-each (lambda (field)
		   (let ((n (arg-name field))
			 (d (cadddr field)))
		      (when (pair? d)
			 (printf "        this.~a = ~a;\n" n (tojs (cadr d))))))
	 (cdr fields))
      (printf "        Object.assign(this, ~a);\n" (arg-name (car fields)) (arg-name (car fields)))
      (printf"       }\n")
      (printf "    }\n")
      (printf "  }\n")
      (printf "}\n")
      (when super
	 (printf "~a.prototype = new ~a();\n" name super))
      (printf "~a.prototype.duplicate = function(prop) {\n" name)
      (printf "   const o = new ~a({});\n" name)
      (printf "   Object.assign(o, prop);\n" name)
      (printf "   return o;\n")
      (printf "}\n")
      (newline))
      
   (match-case class
      ((?- #t . ?-)
       ;; already printed class
       #unspecified)
      ((?name #f #f ?fields)
       ;; root class
       (set-car! (cdr class) #t)
       (print-class name #f fields))
      ((?name #f ?super ?fields)
       ;; unprinted subclass
       (let* ((fields fields)
	      (superfields (class-superfields super env))
	      (allfields (append superfields fields)))
	  (set-car! (cdr class) #t)
	  (print-class name super allfields)))))

;*---------------------------------------------------------------------*/
;*    arg-name ...                                                     */
;*---------------------------------------------------------------------*/
(define (arg-name f)
   (case (car f)
      ((|else|) '_else)
      ((|catch|) '_catch)
      ((|finally|) '_finally)
      ((|import|) '_import)
      ((|export|) '_export)
      ((|method|) '_method)
      ((|function|) '_function)
      ((|super|) '_super)
      ((|static|) '_static)
      ((|await|) '_await)
      ((|private|) '_private)
      (else (string->symbol
	       (string-replace (string-replace (symbol->string (car f)) #\- #\_)
		  #\% #\$)))))

;*---------------------------------------------------------------------*/
;*    arg-field ...                                                    */
;*---------------------------------------------------------------------*/
(define (arg-field f)
   (let ((s (symbol->string (car f))))
      (if (string-index s "-%")
	  (string-append "[\"" s "\"]")
	  (string-append "." s))))

;*---------------------------------------------------------------------*/
;*    arg-type ...                                                     */
;*---------------------------------------------------------------------*/
(define (arg-type f)
   (caddr f))

;*---------------------------------------------------------------------*/
;*    arg-default ...                                                  */
;*---------------------------------------------------------------------*/
(define (arg-default f)
   (find (lambda (x)
	    (and (pair? x) (eq? (car x) 'default)))
      f))

;*---------------------------------------------------------------------*/
;*    class-superfields ...                                            */
;*---------------------------------------------------------------------*/
(define (class-superfields class env)
   (let ((clazz (assq class env)))
      (match-case clazz
	 ((?- ?- #f ?fields)
	  fields)
	 ((?- ?- ?super ?fields)
	  (append (class-superfields super env) fields)))))
   
;*---------------------------------------------------------------------*/
;*    parse-class ...                                                  */
;*---------------------------------------------------------------------*/
(define (parse-class clause)
   (match-case clause
      (((or class abstract-class final-class wide-class) ?name . ?fields)
       (multiple-value-bind (id type)
	  (parse-class-id name)
	  (list id #f type (filter-map parse-class-field fields))))
      (else
       #f)))

;*---------------------------------------------------------------------*/
;*    id-regexp ...                                                    */
;*---------------------------------------------------------------------*/
(define id-regexp (pregexp "([^:]+)::([^:]+)"))

;*---------------------------------------------------------------------*/
;*    parse-class-id ...                                               */
;*---------------------------------------------------------------------*/
(define (parse-class-id id)
   (let ((m (pregexp-match id-regexp (symbol->string id))))
      (if (pair? m)
	  (values (string->symbol (cadr m)) (string->symbol (caddr m)))
	  (values id #f))))

;*---------------------------------------------------------------------*/
;*    parse-class-field ...                                            */
;*---------------------------------------------------------------------*/
(define (parse-class-field field)
   (match-case field
      ((? symbol?)
       (multiple-value-bind (id type)
	  (parse-class-id field)
	  (list id #f type #f)))
      ((?name . ?opts)
       (let ((info (find (lambda (e) (and (pair? e) (eq? (car e) 'info))) opts))
	     (def  (find (lambda (e) (and (pair? e) (eq? (car e) 'default))) opts)))
	  (if (or (not info) (not (member "nojson" (cadr (cadr info)))))
	      (multiple-value-bind (id type)
		 (parse-class-id name)
		 (list id (and info (member "jsonref" (cadr (cadr info)))) type def))
	      #f)))
      (else
       (error "parse-class-field" "wrong class field" field))))
