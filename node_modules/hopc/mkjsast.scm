;*=====================================================================*/
;*    serrano/prgm/project/hop/hop/node_modules/hopc/mkjsast.scm       */
;*    -------------------------------------------------------------    */
;*    Author      :  Manuel Serrano                                    */
;*    Creation    :  Tue Jul  1 16:05:56 2014                          */
;*    Last change :  Fri Oct 27 08:55:09 2023 (serrano)                */
;*    Copyright   :  2014-23 Manuel Serrano                            */
;*    -------------------------------------------------------------    */
;*    Build the JS Ast from the Bigloo type class hierarchy            */
;*=====================================================================*/

;*---------------------------------------------------------------------*/
;*    The module                                                       */
;*---------------------------------------------------------------------*/
(module mkjsast
   (main main))

;*---------------------------------------------------------------------*/
;*    main ...                                                         */
;*---------------------------------------------------------------------*/
(define (main argv)
   (cond
      ((string=? (cadr argv) "hop")
       (call-with-input-file (string-append (caddr argv) ".scm")
	  (lambda (ip)
	     (match-case (read ip)
		((module ?- ??- (export . ?clauses) . ?-)
		 (print "// generated by " (pwd) "/mkjast.scm")
		 (print "\"use strict\"")
		 (newline)
		 (print tojson)
		 (let ((env (filter-map parse-class clauses)))
		    (for-each (lambda (c) (print-class-hop c env)) env)))))))
      ((string=? (cadr argv) "node")
       (call-with-input-file (string-append (caddr argv) ".scm")
	  (lambda (ip)
	     (match-case (read ip)
		((module ?- ??- (export . ?clauses) . ?-)
		 (print "// generated by " (pwd) "/mkjast.scm")
		 (print "\"use strict\"")
		 (newline)
		 (print "import * as simpleAst from \"./simple-ast.mjs\";")
		 (print "import { array2list} from \"./list.mjs\";")
		 (let ((env (filter-map parse-class clauses)))
		    (for-each (lambda (c) (print-class-node c env)) env)
		    ;; global export
		    (printf "export const ast = { ~(, )\n}\n"
		       (filter-map (lambda (c)
				      (let ((name (car c)))
					 (format "\"~a\": ~a" name name)))
			  env))))))))))

;*---------------------------------------------------------------------*/
;*    tojson ...                                                       */
;*---------------------------------------------------------------------*/
(define tojson
   "export function tojson( obj ) {
  if( !(obj instanceof Object) ) {
     if( obj === undefined ) {
	return '{ \"__undefined__\": \"undefined\" }';
     } else {
        return JSON.stringify( obj );
     }
  } else if( 'tojson' in obj ) {
     return obj.tojson();
  } else if( obj instanceof Array ) {
     return '[' + obj.map( tojson ).join( \",\" ) + ']';
  } else if( '__ast__' in obj ) {
     return '{ \"__ast__\": ' + obj.__ast__.tojson() + '}';
  } else if( obj instanceof Object ) {
     return '{' + Object.keys( obj ).map( function( k ) {
          return '\"' + k + '\": ' + tojson( obj[ k ] );
       } ).join( \",\" ) + '}';
  } else {
     return obj.toString();
  }
};
exports.tojson = tojson;\n")

;*---------------------------------------------------------------------*/
;*    print-class-hop ...                                              */
;*---------------------------------------------------------------------*/
(define (print-class-hop class env)

   (define (tojson name fields)
      (printf "Object.defineProperty( ~a.prototype, 'tojson', { value: function() {\n" name)
      (printf "   return '{ \"__node__\": \"~a\"'" name)
      (for-each (lambda (f)
		   (if (cadr f)
		       (printf "\n      + ', \"~a\":' + (this.~a ? '{ \"__ref__\":' +  this.~a.key + '}' : false)"
			  (car f) (car f) (car f))
		       (printf "\n      + ', \"~a\":' + tojson( this[ \"~a\" ] )"
			  (car f) (car f))))
	 fields)
      (display "\n      + '}';\n")
      (printf "}, enumerable: false } ); \n"))
   
   (match-case class
      ((?- #t . ?-)
       ;; already printed class
       #unspecified)
      ((?name #f #f ?fields)
       ;; root class
       (set-car! (cdr class) #t)
       (printf "export function ~a( ~(, ) ) {\n" name (map arg-name fields))
       (printf "   this.__node__ = \"~a\";\n" name)
       (for-each (lambda (f)
		    (printf "   this[ ~s ] = ~a;\n"
		       (symbol->string (car f)) (arg-name f))) fields)
       (printf "}\n")
       (when (any cdr fields)
	  (tojson name fields))
       (printf "exports.~a = ~a;\n" name name)
       (newline))
      ((?name #f ?super ?fields)
       ;; unprinted subclass
       (let* ((fields fields)
	      (superfields (class-superfields super env))
	      (allfields (append superfields fields)))
	  (set-car! (cdr class) #t)
	  (printf "export function ~a( ~(, ) ) {\n" name (map arg-name allfields))
	  (if (pair? superfields)
	      (printf "   ~a.call( this, ~(, ) );\n"
		 super (map arg-name superfields))
	      (printf "   ~a.call( this );\n" super))
	  (for-each (lambda (f)
		       (printf "   this[ ~s ] = ~a;\n"
			  (symbol->string (car f)) (arg-name f)))
	     fields)
	  (printf "   this.__node__ = \"~a\";\n" name)
	  (printf "}\n")
	  (printf "~a.prototype = new ~a;\n" name super)
	  (tojson name allfields)
	  (printf "exports.~a = ~a;\n\n" name name)))))

;*---------------------------------------------------------------------*/
;*    print-class-node ...                                             */
;*---------------------------------------------------------------------*/
(define (print-class-node class env)

   (define (arg-prop arg)
      (let ((name (arg-name arg))
	    (typ (arg-type arg)))
	 (if (memq typ '(pair pair-nil))
	     (format "\"~a\": array2list(~a)" name name)
	     (format "\"~a\": ~a" name name))))
   
   (match-case class
      ((?- #t . ?-)
       ;; already printed class
       #unspecified)
      ((?name #f #f ?fields)
       ;; root class
       (set-car! (cdr class) #t)
       (printf "export function ~a(~(, )) { " name (map arg-name fields))
       (printf "return simpleAst.~a({~(, )}) }\n" name (map arg-prop fields)))
      ((?name #f ?super ?fields)
       ;; unprinted subclass
       (let* ((fields fields)
	      (superfields (class-superfields super env))
	      (allfields (append superfields fields)))
	  (set-car! (cdr class) #t)
	  (printf "export function ~a(~(, )) { " name (map arg-name allfields))
	  (printf "return new simpleAst.~a({~(, )}) }\n" name (map arg-prop allfields))))))

;*---------------------------------------------------------------------*/
;*    arg-name ...                                                     */
;*---------------------------------------------------------------------*/
(define (arg-name f)
   (case (car f)
      ((|else|) '_else)
      ((|catch|) '_catch)
      ((|finally|) '_finally)
      ((|import|) '_import)
      ((|export|) '_export)
      ((|method|) '_method)
      ((|function|) '_function)
      ((|super|) '_super)
      ((|static|) '_static)
      ((|await|) '_await)
      ((|private|) '_private)
      (else (string->symbol
	       (string-replace (string-replace (symbol->string (car f)) #\- #\_)
		  #\% #\$)))))

;*---------------------------------------------------------------------*/
;*    arg-type ...                                                     */
;*---------------------------------------------------------------------*/
(define (arg-type f)
   (caddr f))

;*---------------------------------------------------------------------*/
;*    class-superfields ...                                            */
;*---------------------------------------------------------------------*/
(define (class-superfields class env)
   (let ((clazz (assq class env)))
      (match-case clazz
	 ((?- ?- #f ?fields)
	  fields)
	 ((?- ?- ?super ?fields)
	  (append (class-superfields super env) fields)))))
   
;*---------------------------------------------------------------------*/
;*    parse-class ...                                                  */
;*---------------------------------------------------------------------*/
(define (parse-class clause)
   (match-case clause
      (((or class abstract-class final-class wide-class) ?name . ?fields)
       (multiple-value-bind (id type)
	  (parse-class-id name)
	  (list id #f type (filter-map parse-class-field fields))))
      (else
       #f)))

;*---------------------------------------------------------------------*/
;*    id-regexp ...                                                    */
;*---------------------------------------------------------------------*/
(define id-regexp (pregexp "([^:]+)::([^:]+)"))

;*---------------------------------------------------------------------*/
;*    parse-class-id ...                                               */
;*---------------------------------------------------------------------*/
(define (parse-class-id id)
   (let ((m (pregexp-match id-regexp (symbol->string id))))
      (if (pair? m)
	  (values (string->symbol (cadr m)) (string->symbol (caddr m)))
	  (values id #f))))

;*---------------------------------------------------------------------*/
;*    parse-class-field ...                                            */
;*---------------------------------------------------------------------*/
(define (parse-class-field field)
   (match-case field
      ((? symbol?)
       (multiple-value-bind (id type)
	  (parse-class-id field)
	  (list id #f type)))
      ((?name . ?opts)
       (let ((info (find (lambda (e) (and (pair? e) (eq? (car e) 'info))) opts)))
	  (if (or (not info) (not (member "nojson" (cadr (cadr info)))))
	      (multiple-value-bind (id type)
		 (parse-class-id name)
		 (list id (and info (member "jsonref" (cadr (cadr info)))) type))
	      #f)))
      (else
       (error "parse-class-field" "wrong class field" field))))
