;*=====================================================================*/
;*    .../project/hop/hop/node_modules/hopc/hop/_js2scheme.hop         */
;*    -------------------------------------------------------------    */
;*    Author      :  Manuel Serrano                                    */
;*    Creation    :  Tue Jul 17 09:48:30 2018                          */
;*    Last change :  Sat Jun  8 06:27:06 2024 (serrano)                */
;*    Copyright   :  2018-24 Manuel Serrano                            */
;*    -------------------------------------------------------------    */
;*    JS2Scheme wrapper.                                               */
;*=====================================================================*/

;*---------------------------------------------------------------------*/
;*    The module                                                       */
;*---------------------------------------------------------------------*/
(module _js2scheme
   
   (library hopscript hop nodejs js2scheme)
   
   (export (hopscript ::JsGlobalObject ::JsObject ::JsObject ::JsObject)))
	   
;*---------------------------------------------------------------------*/
;*    hopscript ...                                                    */
;*---------------------------------------------------------------------*/
(define (hopscript %this this %scope %module)
   
   (js-export (Parser generate compile dump)
      
      (define exports (js-get %module (& "exports") %this))
      
      (define controller #f)
      
      (define (plugin-parse parser this)
	 (unless (isa? parser JsFunction)
	    (js-raise-type-error %this
	       "plugin-parse: wrong parser [~a]" parser))
	 (lambda (tok decl conf ctrl)
	    (set! controller ctrl)
	    (js->ast %this
	       (js-call3 %this parser this
		  (token->js tok)
		  (if (string? decl) (js-string->jsstring decl) decl)
		  conf))))
      
      (define (first-plugin this::JsWrapper)
	 (with-access::JsWrapper this (data)
	    (car (last-pair data))))
      
      (define parse
	 (js-make-function %this
	    (lambda (this path conf)
	       (if (and (isa? this JsWrapper)
			(with-access::JsWrapper this (obj)
			   (eq? obj 'J2SParser)))
		   (let ((filename (js-tostring path %this)))
		      (if (file-exists? filename)
			  (with-access::JsWrapper this (data)
			     (call-with-input-file filename
				(lambda (ip)
				   (set! controller #f)
				   (j2s-parser ip
				      (cons* :debug (bigloo-debug)
					 :module-name (symbol->string (gensym))
					 :plugin-init (cdr (first-plugin this))
					 conf)
				      data))))
			  (raise
			     (instantiate::&io-file-not-found-error
				(proc "parse")
				(msg "file not found")
				(obj filename)))))
		   (js-raise-type-error %this 
		      "js->ast: not a parser [~a]" this)))
	    (js-function-arity 2 0)
	    (js-function-info :name "parse" :len 1)))
      
      (define parseString
	 (js-make-function %this
	    (lambda (this val conf)
	       (if (and (isa? this JsWrapper)
			(with-access::JsWrapper this (obj)
			   (eq? obj 'J2SParser)))
		   (with-access::JsWrapper this (data)
		      (call-with-input-string (js-tostring val %this)
			 (lambda (ip)
			    (set! controller #f)
			    (j2s-parser ip
			       (cons* :debug (bigloo-debug)
				  :module-name (symbol->string (gensym))
				  conf)
			       data))))
		   (js-raise-type-error %this 
		      "js->ast: not a parser [~a]" this)))
	    (js-function-arity 2 0)
	    (js-function-info :name "parseString" :len 1)))
      
      (define (token->js token)
	 (with-access::JsGlobalObject %this (js-object)
	    (let ((tok (js-new0 %this js-object)))
	       (js-bind! %this tok (& "type")
		  :value (js-string->jsstring (symbol->string! (car token)))
		  :writable #f)
	       (js-bind! %this tok (& "value")
		  :value (cond
			    ((symbol? (cdr token))
			     (js-string->jsstring (symbol->string (cdr token))))
			    ((string? (cdr token))
			     (js-string->jsstring (cdr token)))
			    (else
			     (cdr token)))
		  :writable #f)
	       (js-bind! %this tok (& "filename")
		  :value (js-string->jsstring (cadr (cer token)))
		  :writable #f)
	       (js-bind! %this tok (& "pos")
		  :value (caddr (cer token))
		  :writable #f)
	       (js-bind! %this tok (& "location")
		  :value (cer token)
		  :writable #f
		  :enumerable #f)
	       tok)))
      
      (define parser-prototype
	 (with-access::JsGlobalObject %this (js-object)
	    (let ((obj (js-new0 %this js-object)))
	       (js-bind! %this obj (& "parse")
		  :value parse
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parseString")
		  :value parseString
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "plugins")
		  :get (js-make-function %this
			  (lambda (this)
			     (with-access::JsWrapper this (data)
				data))
			  (js-function-arity 0 0)
			  (js-function-info :name "get" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "addPlugin")
		  :value (js-make-function %this
			    (lambda (this key parser)
			       (with-access::JsWrapper this (data)
				  (set-cdr! data
				     (cons
					(cons (string->symbol
						 (js-tostring key %this))
					   (plugin-parse parser this))
					(cdr data)))))
			    (js-function-arity 2 0)
			    (js-function-info :name "addPlugin" :len 2))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "removePlugin")
		  :value (js-make-function %this
			    (lambda (this key)
			       (with-access::JsWrapper this (data)
				  (let* ((k (string->symbol
					       (js-tostring key %this)))
					 (c (assq k data)))
				     (delete! c data))))
			    (js-function-arity 1 0)
			    (js-function-info :name "removePlugin" :len 2))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "peekToken")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (token->js
				      ((vector-ref controller 2)))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "peekToken" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "consumeToken")
		  :value (js-make-function %this
			    (lambda (this token)
			       (if (vector? controller)
				   (token->js
				      ((vector-ref controller 3)
				       (string->symbol
					  (js-tostring token %this))))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 1 0)
			    (js-function-info :name "consumeToken" :len 1))
		  :writable #f
		  :enumerable #t)
	       
	       (js-bind! %this obj (& "consumeAny")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (token->js ((vector-ref controller 4)))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "consumeAny" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parseExpression")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (with-access::JsWrapper this (data)
				      ((vector-ref controller 5) #f #f data))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "parseExpression" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parsePrimary")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (with-access::JsWrapper this (data)
				      ((vector-ref controller 0) #f #f data))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "parsePrimary" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parsePrimaryDollar")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (with-access::JsWrapper this (data)
				      ((vector-ref controller 1) #f #f data))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "parsePrimaryDollar" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parseCondExpression")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (with-access::JsWrapper this (data)
				      ((vector-ref controller 8) #f #f #t data))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "parseCondExpression" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parseAssigExpression")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (with-access::JsWrapper this (data)
				      ((vector-ref controller 10) #f #f #t data))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "parseAssigExpression" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parseDollarExpression")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (with-access::JsWrapper this (data)
				      ((vector-ref controller 9) data))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "parseDollarExpression" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parseStatement")
		  :value (js-make-function %this
			    (lambda (this token)
			       (if (vector? controller)
				   (with-access::JsWrapper this (data)
				      ((vector-ref controller 6) data))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 1 0)
			    (js-function-info :name "parseStatement" :len 1))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parseBlock")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (with-access::JsWrapper this (data)
				      ((vector-ref controller 7) data))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "parseBlock" :len 0))
		  :writable #f
		  :enumerable #t)
	       (for-each (lambda (s)
			    (let ((j (js-ascii-name->jsstring s)))
			       (js-bind! %this obj j :value j :writable #f)))
		  '("DOT" "DOTS" "SEMICOLON" "COMMA" "LBRACE" "RBRACE" "LPAREN"
		    "RPAREN" "ID" "DOLLAR" "LBRACKET" "RBRACKET" "OR" "BIT_OR"
		    "STRING" "await" "break" "case" "catch" "const" "continue"
		    "debugger" "default" "delete" "do" "else" "false" "finally"
		    "for" "function" "if" "in" "instanceof" "let" "new" "null"
		    "return" "switch" "this" "throw" "true" "try" "typeof" "var"
		    "void" "while" "with" "yield" "class" "extends" "super"
		    "static"))
	       (for-each (lambda (ns)
			    (js-bind! %this obj (js-ascii-name->jsstring (car ns))
			       :value (js-ascii->jsstring (cadr ns))
			       :writable #f))
		  '(("ELSE" "else") ("COLUMN" ":") ("EGAL" "=") ("NOTEGAL" "!=")
		    ("EGALEGAL" "==") ("NOTEGALEGAL" "!==")
		    ("LT" "<") ("GT" ">") ("LE" "<=") ("GE" ">=")
		    ("PLUS" "+") ("MINUS" "-") ("MUL" "*") ("PERCENT" "%")
		    ("PLUSPLUS" "++") ("MINUSMINUS" "--") 
		    ("SHIFTL" "<<") ("SHIFTR" ">>") ("USHIFTR" ">>>")
		    ("AMP" "&") ("HAT" "^") ("BANG" "!") ("TILDE" "~") ("AND" "&&")
		    ("PLUSEGAL" "+=") ("MINUSEGAL" "-=") ("MULEGAL" "*=") 
		    ("PERCENTEGAL" "%=") ("SHIFTLEGAL" "<<=") ("SHIFTREGAL" ">>=")
		    ("USHIFTREGAL" ">>>=") ("AMPEGAL" "&=") ("HATEGAL" "^=")
		    ("DIVEGAL" "/=") ("DIV" "/") ("QUESTIONMARK" "?")
		    ("LARROW" "=>")))
	       obj)))

      (define Parser
	 (with-access::JsGlobalObject %this (js-function-prototype)
	    (js-make-function %this
	       (lambda (this)
		  (with-access::JsGlobalObject %this (js-new-target)
		     (if (eq? js-new-target (js-undefined))
			 (js-raise-type-error %this 
			    "Parser must be used as a constructor" this)
			 (begin
			    (set! js-new-target (js-undefined))
			    this))))
	       (js-function-arity 0 0)
	       (js-function-info :name "Parser" :len 0)
	       :__proto__ js-function-prototype
	       :alloc (lambda (%this ctor::JsFunction)
			 (with-access::JsGlobalObject %this (js-new-target)
			    (let ((p (instantiate::JsWrapper
					(obj 'J2SParser)
					(cmap (js-make-jsconstructmap))
					(data (list (cons (gensym) #f))))))
			       (set! js-new-target ctor)
			       (js-object-proto-set! p parser-prototype)
			       (js-object-mode-set! p (js-object-default-mode))
			       p)))
	       :prototype parser-prototype)))

      (define generate
	 (js-make-function %this
	    (lambda (this ast conf)
	       (tprint "generate ast=" (typeof ast))
	       (if (isa? ast J2SProgram)
		   (with-access::J2SProgram ast (nodes path)
		      (ast->js %this ast))
		   (js-raise-type-error %this
		      "Not a Hopjs ast" ast)))
	    (js-function-arity 2 0)
	    (js-function-info :name "generate" :len 2)))

      (define compile
	 (js-make-function %this
		   (lambda (this ipath opath)
		      (let ((tgt (j2s-compile ipath "/tmp")))
			 (if (eq? opath (js-undefined))
			     (js-string->jsstring 
				(call-with-output-string
				   (lambda (op)
				      (pp tgt op))))
			     (call-with-output-file (js-tostring opath %this)
				(lambda (op)
				   (pp tgt op)
				   opath)))))
		   (js-function-arity 2 0)
		   (js-function-info :name "compile" :len 2)))

      (define dump
	 (js-make-function %this
		   (lambda (this node)
		      (js-string->jsstring 
			 (call-with-output-string
			    (lambda (s)
			       (pp (j2s->sexp node) s)))))
		   (js-function-arity 1 0)
		   (js-function-info :name "dump" :len 1)))
      
      (js-bind! %this exports (& "Parser")
	 :value Parser
	 :writable #f :enumerable #t)
      
      (js-bind! %this exports (& "compile")
	 :value compile
	 :writable #f
	 :enumerable #t)
      
      (js-bind! %this exports (& "dump")
	 :value dump
	 :writable #f
	 :enumerable #t)))

;*---------------------------------------------------------------------*/
;*    env-debug-compile ...                                            */
;*---------------------------------------------------------------------*/
(define env-debug-compile
   (let ((env (getenv "NODE_DEBUG")))
      (when (string? env)
	 (or (string=? env "compile")
	     (string-prefix? "compile," env)
	     (string-suffix? ",compile" env)
	     (string-contains env ",compile,")))))

;*---------------------------------------------------------------------*/
;*    ast->js ...                                                      */
;*---------------------------------------------------------------------*/
(define (ast->js %this ast::J2SProgram)
   (with-access::J2SProgram ast (path)
      (when env-debug-compile
	 (let ((target "string"))
	    (fprint (current-error-port) (hop-color 1 "" path)
	       " [loader] -> "
	       (if target (hop-color 2 "" target) ""))))
      (with-handler
	 (lambda (err)
	    (fprint (current-error-port) "loader compilation failed for \""
	       path "\"")
	    (exception-notify err)
	    (raise err))
	 (j2s-compile (js->ast %this ast)
	    :warning-global #f
	    :driver (j2s-javascript-driver)
	    :loader-resolve (nodejs-make-j2s-loader %this)))))

;*---------------------------------------------------------------------*/
;*    js->ast ...                                                      */
;*---------------------------------------------------------------------*/
(define (js->ast %this n)

   (define (symbol-field? clazz f)
      (or (eq? (class-field-type f) 'symbol)
	  (and (eq? clazz J2SFun) (eq? (class-field-name f) 'idthis))
	  (eq? (class-field-name f) '_scmid)))
   
   (define (jsobject->node js)
      (let* ((cname (js-tostring (js-get js (& "__node__") %this) %this))
	     (clazz (find-class (string->symbol cname)))
	     (ctor (class-constructor clazz))
	     (inst ((class-allocator clazz)))
	     (fields (class-all-fields clazz)))
	 ;; instance fields
	 (let loop ((i (-fx (vector-length fields) 1)))
	    (when (>=fx i 0)
	       (let* ((f (vector-ref-ur fields i))
		      (n (class-field-name f))
		      (jn (js-string->name (symbol->string! n))))
		  (cond
		     ((js-has-property js jn %this)
		      (let ((v (js->node (js-get js jn %this))))
			 ((class-field-mutator f)
			  inst
			  (cond
			     ((eq? (class-field-type f) 'symbol)
			      (cond
				 ((symbol? v)
				  v)
				 ((string? v)
				  (string->symbol v))
				 (else
				  (js-raise-type-error %this 
				     (format "js->ast: bad field type ~a.~a, string expected, ~~a provided"
					cname n)
				     v))))
			     ((eq? (class-field-type f) 'pair-nil)
			      (cond
				 ((or (null? v) (pair? v))
				  v)
				 ((vector? v)
				  (vector->list v))
				 (else
				  (js-raise-type-error/loc %this
				     (let ((f (find-class-field clazz 'loc)))
					(when (class-field? f)
					   ((class-field-accessor f) inst)))
				     (format "js->ast: bad field type ~a.~a, vector expected, ~~a provided"
					cname n)
				     v))))
			     ((eq? (class-field-type f) 'pair)
			      (cond
				 ((pair? v)
				  v)
				 ((vector? v)
				  (vector->list v))
				 (else
				  (js-raise-type-error/loc %this
				     (let ((f (find-class-field clazz 'loc)))
					(when (class-field? f)
					   ((class-field-accessor f) inst)))
				     (format "js->ast: bad field type ~a.~a, vector expected, ~~a provided"
					cname n)
				     v))))
			     ((eq? (class-field-type f) 'uint32)
			      (if (null? v)
				  (if (class-field-default-value? f)
				      (class-field-default-value f)
				      #u32:0)
				  v))
			     ((symbol-field? clazz f)
			      (if (string? v)
				  (string->symbol v)
				  v))
			     (else
			      v)))))
		     ((class-field-default-value? f)
		      ((class-field-mutator f)
		       inst (class-field-default-value f)))
		     ((not (member "nojson" (class-field-info f)))
		      (js-inspect-object js)
		      (error "js->ast"
			 (format "Missing field \"~a\"" n) cname)))
		  (loop (-fx i 1)))))
	 ;; constructor
	 (when (procedure? ctor) ctor inst)
	 inst))

   (define (node->node node)
      (let* ((clazz (object-class node))
	     (cname (class-name clazz))
	     (ctor (class-constructor clazz))
	     (inst ((class-allocator clazz)))
	     (fields (class-all-fields clazz)))
	 ;; instance fields
	 (let loop ((i (-fx (vector-length fields) 1)))
	    (when (>=fx i 0)
	       (let* ((f (vector-ref-ur fields i))
		      (n (class-field-name f))
		      (v ((class-field-accessor f) node)))
		  (cond
		     ((isa? v J2SNode)
		      ((class-field-mutator f) inst (js->node v)))
		     ((pair? v)
		      ((class-field-mutator f) inst (map js->node v)))
		     ((js-object? v)
		      ((class-field-mutator f) inst (jsobject->node v)))
		     (else
		      ((class-field-mutator f) inst v)))
		  (loop (-fx i 1)))))
	 ;; constructor
	 (when (procedure? ctor) ctor inst)
	 inst))

   (define (js->node n)
      (cond
	 ((isa? n J2SNode)
	  (node->node n))
	 ((or (isa? n JsString) (isa? n JsStringLiteral))
	  (js-jsstring->string n))
	 ((isa? n JsSymbolLiteral)
	  (with-access::JsSymbolLiteral n (val)
	     (string->symbol (js-jsstring->string val))))
	 ((isa? n JsArray)
	  (map! js->node (jsarray->list n %this)))
	 ((isa? n JsObject)
	  (let ((n (jsobject->node n)))
	     (if (isa? n J2SNode)
		 (with-access::J2SNode n (loc)
		    (map! js->node loc)
		    n)
		 n)))
	 (else
	  n)))

   (js->node n))
