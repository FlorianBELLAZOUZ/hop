;*=====================================================================*/
;*    .../project/hop/hop/node_modules/hopc/lib/_js2scheme.hop         */
;*    -------------------------------------------------------------    */
;*    Author      :  Manuel Serrano                                    */
;*    Creation    :  Tue Jul 17 09:48:30 2018                          */
;*    Last change :  Thu Dec  9 09:53:35 2021 (serrano)                */
;*    Copyright   :  2018-21 Manuel Serrano                            */
;*    -------------------------------------------------------------    */
;*    JS2Scheme wrapper.                                               */
;*=====================================================================*/

;*---------------------------------------------------------------------*/
;*    The module                                                       */
;*---------------------------------------------------------------------*/
(module _js2scheme
   
   (library hopscript hop hopwidget nodejs js2scheme)
   
   (export (hopscript ::JsGlobalObject ::JsObject ::JsObject ::JsObject)))
	   
;*---------------------------------------------------------------------*/
;*    hopscript ...                                                    */
;*---------------------------------------------------------------------*/
(define (hopscript %this this scope module)
   (&with!
      
      (define exports (js-get module (& "exports") %this))
      
      (define controller #f)
      
      (define parse
	 (js-make-function %this
	    (lambda (this path)
	       (if (and (isa? this JsWrapper)
			(with-access::JsWrapper this (obj)
			   (eq? obj 'J2SParser)))
		   (let ((filename (js-tostring path %this)))
		      (if (file-exists? filename)
			  (with-access::JsWrapper this (data)
			     (call-with-input-file filename
				(lambda (ip)
				   (set! controller #f)
				   (j2s-parser ip
				      `(:debug ,(bigloo-debug)
					  :module-name ,(symbol->string (gensym)))
				      data))))
			  (raise
			     (instantiate::&io-file-not-found-error
				(proc "parse")
				(msg "file not found")
				(obj filename)))))
		   (js-raise-type-error %this 
		      "js->ast: not a parser [~a]" this)))
	    (js-function-arity 1 0)
	    (js-function-info :name "parse" :len 1)))

      (define parseString
	 (js-make-function %this
	    (lambda (this val)
	       (if (and (isa? this JsWrapper)
			(with-access::JsWrapper this (obj)
			   (eq? obj 'J2SParser)))
		   (with-access::JsWrapper this (data)
		      (call-with-input-string (js-tostring val %this)
			 (lambda (ip)
			    (set! controller #f)
			    (j2s-parser ip
			       `(:debug ,(bigloo-debug)
				   :module-name ,(symbol->string (gensym)))
			       data))))
		   (js-raise-type-error %this 
		      "js->ast: not a parser [~a]" this)))
	    (js-function-arity 1 0)
	    (js-function-info :name "parseString" :len 1)))
      
      (define (token->js token)
	 (with-access::JsGlobalObject %this (js-object)
	    (let ((tok (js-new0 %this js-object)))
	       (js-bind! %this tok (& "type")
		  :value (js-string->jsstring (symbol->string! (car token)))
		  :writable #f)
	       (js-bind! %this tok (& "value")
		  :value (cond
			    ((symbol? (cdr token))
			     (js-string->jsstring (symbol->string (cdr token))))
			    ((string? (cdr token))
			     (js-string->jsstring (cdr token)))
			    (else
			     (cdr token)))
		  :writable #f)
	       (js-bind! %this tok (& "filename")
		  :value (js-string->jsstring (cadr (cer token)))
		  :writable #f)
	       (js-bind! %this tok (& "pos")
		  :value (caddr (cer token))
		  :writable #f)
	       (js-bind! %this tok (& "location")
		  :value (cer token)
		  :writable #f
		  :enumerable #f)
	       tok)))
      
      (define parser-prototype
	 (with-access::JsGlobalObject %this (js-object)
	    (let ((obj (js-new0 %this js-object)))
	       (js-bind! %this obj (& "parse")
		  :value parse
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parseString")
		  :value parseString
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "plugins")
		  :get (js-make-function %this
			  (lambda (this)
			     (with-access::JsWrapper this (data)
				data))
			  (js-function-arity 0 0)
			  (js-function-info :name "get" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "addPlugin")
		  :value (js-make-function %this
			    (lambda (this key parser)
			       (with-access::JsWrapper this (data)
				  (set-cdr! data
				     (cons
					(cons (string->symbol
						 (js-tostring key %this))
					   (lambda (tok decl ctrl)
					      (set! controller ctrl)
					      (js->ast %this
						 (js-call2 %this parser this
						    (token->js tok) decl))))
					(cdr data)))))
			    (js-function-arity 2 0)
			    (js-function-info :name "addPlugin" :len 2))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "removePlugin")
		  :value (js-make-function %this
			    (lambda (this key)
			       (with-access::JsWrapper this (data)
				  (let* ((k (string->symbol
					       (js-tostring key %this)))
					 (c (assq k data)))
				     (delete! c data))))
			    (js-function-arity 1 0)
			    (js-function-info :name "removePlugin" :len 2))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "peekToken")
		  :value (js-make-function %this
			    (lambda (this token)
			       (if (vector? controller)
				   (token->js
				      ((vector-ref controller 2)))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 1 0)
			    (js-function-info :name "peekToken" :len 1))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "consumeToken")
		  :value (js-make-function %this
			    (lambda (this token)
			       (if (vector? controller)
				   (token->js
				      ((vector-ref controller 3)
				       (string->symbol
					  (js-tostring token %this))))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 1 0)
			    (js-function-info :name "consumeToken" :len 1))
		  :writable #f
		  :enumerable #t)
	       
	       (js-bind! %this obj (& "consumeAny")
		  :value (js-make-function %this
			    (lambda (this token)
			       (if (vector? controller)
				   (token->js ((vector-ref controller 4)))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 1 0)
			    (js-function-info :name "consumeAny" :len 1))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parseExpression")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (with-access::JsWrapper this (data)
				      ((vector-ref controller 5) #f #f data))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "parseExpression" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parsePrimary")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (with-access::JsWrapper this (data)
				      ((vector-ref controller 0) #f #f data))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "parsePrimary" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parsePrimaryDollar")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (with-access::JsWrapper this (data)
				      ((vector-ref controller 1) #f #f data))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "parsePrimaryDollar" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parseStatement")
		  :value (js-make-function %this
			    (lambda (this token)
			       (if (vector? controller)
				   (with-access::JsWrapper this (data)
				      ((vector-ref controller 6) data))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 1 0)
			    (js-function-info :name "parseStatement" :len 1))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parseBlock")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (with-access::JsWrapper this (data)
				      ((vector-ref controller 7) data))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "parseBlock" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parseCondExpression")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (with-access::JsWrapper this (data)
				      ((vector-ref controller 8) #f #f #t data))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "parseCondExpression" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parseDollarExpression")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (with-access::JsWrapper this (data)
				      ((vector-ref controller 9) data))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "parseDollarExpression" :len 0))
		  :writable #f
		  :enumerable #t)
	       (for-each (lambda (s)
			    (let ((j (js-ascii-name->jsstring s)))
			       (js-bind! %this obj j :value j :writable #f)))
		  '("DOT" "DOTS" "SEMICOLON" "COMMA" "LBRACE" "RBRACE" "LPAREN"
		    "RPAREN" "ID" "DOLLAR" "LBRACKET" "RBRACKET" "OR" "BIT_OR"
		    "STRING" "await" "break" "case" "catch" "const" "continue"
		    "debugger" "default" "delete" "do" "else" "false" "finally"
		    "for" "function" "if" "in" "instanceof" "let" "new" "null"
		    "return" "switch" "this" "throw" "true" "try" "typeof" "var"
		    "void" "while" "with" "yield" "class" "extends" "super"
		    "static"))
	       (for-each (lambda (ns)
			    (js-bind! %this obj (js-ascii-name->jsstring (car ns))
			       :value (js-ascii->jsstring (cadr ns))
			       :writable #f))
		  '(("ELSE" "else") ("COLUMN" ":") ("EGAL" "=") ("NOTEGAL" "!=")
		    ("EGALEGAL" "==") ("NOTEGALEGAL" "!==")
		    ("LT" "<") ("GT" ">") ("LE" "<=") ("GE" ">=")
		    ("PLUS" "+") ("MINUS" "-") ("MUL" "*") ("PERCENT" "%")
		    ("PLUSPLUS" "++") ("MINUSMINUS" "--") 
		    ("SHIFTL" "<<") ("SHIFTR" ">>") ("USHIFTR" ">>>")
		    ("AMP" "&") ("HAT" "^") ("BANG" "!") ("TILDE" "~") ("AND" "&&")
		    ("PLUSEGAL" "+=") ("MINUSEGAL" "-=") ("MULEGAL" "*=") 
		    ("PERCENTEGAL" "%=") ("SHIFTLEGAL" "<<=") ("SHIFTREGAL" ">>=")
		    ("USHIFTREGAL" ">>>=") ("AMPEGAL" "&=") ("HATEGAL" "^=")
		    ("DIVEGAL" "/=") ("DIV" "/") ("QUESTIONMARK" "?")
		    ("LARROW" "=>")))
	       obj)))
      
      (with-access::JsGlobalObject %this (js-function-prototype)
	 (js-bind! %this exports (& "Parser")
	    :value (js-make-function %this
		      (lambda (this)
			 (with-access::JsGlobalObject %this (js-new-target)
			    (if (eq? js-new-target (js-undefined))
				(js-raise-type-error %this 
				   "Parser must be used as a constructor" this)
				(begin
				   (set! js-new-target (js-undefined))
				   this))))
		      (js-function-arity 0 0)
		      (js-function-info :name "Parser" :len 0)
		      :__proto__ js-function-prototype
		      :alloc (lambda (%this ctor::JsFunction)
				(with-access::JsGlobalObject %this (js-new-target)
				   (let ((p (instantiate::JsWrapper
					       (obj 'J2SParser)
					       (cmap (js-make-jsconstructmap))
					       (data (list (cons (gensym) #f))))))
				      (set! js-new-target ctor)
				      (js-object-proto-set! p parser-prototype)
				      (js-object-mode-set! p (js-object-default-mode))
				      p)))
		      :prototype parser-prototype)
	    :writable #f :enumerable #t))
      
      (js-bind! %this exports (& "compile")
	 :value (js-make-function %this
		   (lambda (this ipath opath)
		      (let ((tgt (j2s-compile ipath "/tmp")))
			 (if (eq? opath (js-undefined))
			     (js-string->jsstring 
				(call-with-output-string
				   (lambda (op)
				      (pp tgt op))))
			     (call-with-output-file (js-tostring opath %this)
				(lambda (op)
				   (pp tgt op)
				   opath)))))
		   (js-function-arity 2 0)
		   (js-function-info :name "compile" :len 2))
	 :writable #f
	 :enumerable #t)))
			 
;*---------------------------------------------------------------------*/
;*    js->ast ...                                                      */
;*---------------------------------------------------------------------*/
(define (js->ast %this n)

   (define (symbol-field? clazz f)
      (or (eq? (class-field-type f) 'symbol)
	  (and (eq? clazz J2SFun) (eq? (class-field-name f) 'idthis))
	  (eq? (class-field-name f) '_scmid)))
   
   (define (jsobject->node js)
      (let* ((cname (js-tostring (js-get js (& "__node__") %this) %this))
	     (clazz (find-class (string->symbol cname)))
	     (ctor (class-constructor clazz))
	     (inst ((class-allocator clazz)))
	     (fields (class-all-fields clazz)))
	 ;; instance fields
	 (let loop ((i (-fx (vector-length fields) 1)))
	    (when (>=fx i 0)
	       (let* ((f (vector-ref-ur fields i))
		      (n (class-field-name f))
		      (jn (js-string->name (symbol->string! n))))
		  (cond
		     ((js-has-property js jn %this)
		      (let ((v (js->node (js-get js jn %this))))
			 ((class-field-mutator f)
			  inst
			  (cond
			     ((eq? (class-field-type f) 'symbol)
			      (if (string? v)
				  (string->symbol v)
				  (js-raise-type-error %this 
				     (format "js->ast: bad field type ~a.~a, string expected, ~~a provided"
					cname n)
				     v)))
			     ((eq? (class-field-type f) 'pair-nil)
			      (cond
				 ((or (null? v) (pair? v))
				  v)
				 ((vector? v)
				  (vector->list v))
				 (else
				  (js-raise-type-error/loc %this
				     (let ((f (find-class-field clazz 'loc)))
					(when (class-field? f)
					   ((class-field-accessor f) inst)))
				     (format "js->ast: bad field type ~a.~a, vector expected, ~~a provided"
					cname n)
				     v))))
			     ((eq? (class-field-type f) 'pair)
			      (cond
				 ((pair? v)
				  v)
				 ((vector? v)
				  (vector->list v))
				 (else
				  (js-raise-type-error/loc %this
				     (let ((f (find-class-field clazz 'loc)))
					(when (class-field? f)
					   ((class-field-accessor f) inst)))
				     (format "js->ast: bad field type ~a.~a, vector expected, ~~a provided"
					cname n)
				     v))))
			     ((eq? (class-field-type f) 'uint32)
			      (if (null? v)
				  (if (class-field-default-value? f)
				      (class-field-default-value f)
				      #u32:0)
				  v))
			     ((symbol-field? clazz f)
			      (if (string? v)
				  (string->symbol v)
				  v))
			     (else
			      v)))))
		     ((class-field-default-value? f)
		      ((class-field-mutator f)
		       inst (class-field-default-value f)))
		     ((not (member "nojson" (class-field-info f)))
		      (js-debug-object js)
		      (error "js->ast"
			 (format "Missing field \"~a\"" n) cname)))
		  (loop (-fx i 1)))))
	 ;; constructor
	 (when (procedure? ctor) ctor inst)
	 inst))

   (define (js->node n)
      (cond
	 ((isa? n J2SNode)
	  n)
	 ((or (isa? n JsString) (isa? n JsStringLiteral))
	  (js-jsstring->string n))
	 ((isa? n JsSymbolLiteral)
	  (with-access::JsSymbolLiteral n (val)
	     (string->symbol (js-jsstring->string val))))
	 ((isa? n JsArray)
	  (map! js->node (jsarray->list n %this)))
	 ((isa? n JsObject)
	  (let ((n (jsobject->node n)))
	     (if (isa? n J2SNode)
		 (with-access::J2SNode n (loc)
		    (map! js->node loc)
		    n)
		 n)))
	 (else
	  n)))

   (js->node n))
