;*=====================================================================*/
;*    .../project/hop/3.2.x/node_modules/hopc/lib/_js2scheme.hop       */
;*    -------------------------------------------------------------    */
;*    Author      :  Manuel Serrano                                    */
;*    Creation    :  Tue Jul 17 09:48:30 2018                          */
;*    Last change :  Wed Oct  3 07:44:37 2018 (serrano)                */
;*    Copyright   :  2018 Manuel Serrano                               */
;*    -------------------------------------------------------------    */
;*    JS2Scheme wrapper.                                               */
;*=====================================================================*/

;*---------------------------------------------------------------------*/
;*    The module                                                       */
;*---------------------------------------------------------------------*/
(module _js2scheme
   
   (library hopscript hop hopwidget nodejs js2scheme)
   
   (export (hopscript ::JsGlobalObject ::JsObject ::JsObject ::JsObject))

   (static (class J2SParser::JsObject
	      (plugins::pair-nil (default (list (cons #f #f)))))))
	   
;*---------------------------------------------------------------------*/
;*    hopscript ...                                                    */
;*---------------------------------------------------------------------*/
(define (hopscript %this this scope module)
   
   (define exports (js-get module 'exports %this))

   (define controller #f)
      
   (define parse
      (js-make-function %this
	 (lambda (this path)
	    (if (isa? this J2SParser)
		(let ((filename (js-tostring path %this)))
		   (if (file-exists? filename)
		       (with-access::J2SParser this (plugins)
			  (call-with-input-file filename
			     (lambda (ip)
				(set! controller #f)
				(j2s-parser ip
				   `(:debug ,(bigloo-debug)
				       :module-name ,(symbol->string (gensym)))
				   plugins))))
		       (raise
			  (instantiate::&io-file-not-found-error
			     (proc "parse")
			     (msg "file not found")
			     (obj filename)))))
		(js-raise-type-error %this 
		   "js->ast: not a parser ~a" this)))
	 1 'parse))

   (define (token->js token)
      (with-access::JsGlobalObject %this (js-object)
	 (let ((tok (js-new0 %this js-object)))
	    (js-bind! %this tok 'type
	       :value (symbol->string! (car token))
	       :writable #f)
	    (js-bind! %this tok 'value
	       :value (cond
			 ((symbol? (cdr token))
			  (js-string->jsstring (symbol->string (cdr token))))
			 ((string? (cdr token))
			  (js-string->jsstring (cdr token)))
			 (else
			  (cdr token)))
	       :writable #f)
	    (js-bind! %this tok 'filename
	       :value (js-string->jsstring (cadr (cer token)))
	       :writable #f)
	    (js-bind! %this tok 'pos
	       :value (caddr (cer token))
	       :writable #f)
	    (js-bind! %this tok 'location
	       :value (cer token)
	       :writable #f
	       :enumerable #f)
	    tok)))
   
   (define parser-prototype
      (with-access::JsGlobalObject %this (js-object)
	 (let ((obj (js-new0 %this js-object)))
	    (js-bind! %this obj 'parse
	       :value parse
	       :writable #f
	       :enumerable #t)
	    (js-bind! %this obj 'plugins
	       :get (js-make-function %this
		       (lambda (this)
			  (with-access::J2SParser this (plugins)
			     plugins))
		       0 'get)
	       :writable #f
	       :enumerable #t)
	    (js-bind! %this obj 'addPlugin
	       :value (js-make-function %this
			 (lambda (this key parser)
			    (with-access::J2SParser this (plugins)
			       (set-cdr! plugins
				  (cons
				     (cons (string->symbol
					      (js-tostring key %this))
					(lambda (tok decl ctrl)
					   (set! controller ctrl)
					   (js->ast %this
					      (js-call2 %this parser this
						 (token->js tok) decl))))
				     (cdr plugins)))))
			 2 'addPlugin)
	       :writable #f
	       :enumerable #t)
	    (js-bind! %this obj 'removePlugin
	       :value (js-make-function %this
			 (lambda (this key)
			    (with-access::J2SParser this (plugins)
			       (let* ((k (string->symbol
					    (js-tostring key %this)))
				      (c (assq k plugins)))
				  (set! plugins (delete! c plugins)))))
			 2 'removePlugin)
	       :writable #f
	       :enumerable #t)
	    (js-bind! %this obj 'peekToken
	       :value (js-make-function %this
			 (lambda (this token)
			    (if (vector? controller)
				(token->js
				   ((vector-ref controller 2)))
				(js-raise-type-error %this
				   "detached plugin parser" this)))
			 1 'peekToken)
	       :writable #f
	       :enumerable #t)
	    (js-bind! %this obj 'consumeToken
	       :value (js-make-function %this
			 (lambda (this token)
			    (if (vector? controller)
				(token->js
				   ((vector-ref controller 3)
				    (string->symbol
				       (js-tostring token %this))))
				(js-raise-type-error %this
				   "detached plugin parser" this)))
			 1 'consumeToken)
	       :writable #f
	       :enumerable #t)
	    
	    (js-bind! %this obj 'consumeAny
	       :value (js-make-function %this
			 (lambda (this token)
			    (if (vector? controller)
				(token->js ((vector-ref controller 4)))
				(js-raise-type-error %this
				   "detached plugin parser" this)))
			 1 'consumeAny)
	       :writable #f
	       :enumerable #t)
	    (js-bind! %this obj 'parseExpression
	       :value (js-make-function %this
			 (lambda (this)
			    (if (vector? controller)
				((vector-ref controller 5) #f #f)
				(js-raise-type-error %this
				   "detached plugin parser" this)))
			 0 'parseExpression)
	       :writable #f
	       :enumerable #t)
	    (js-bind! %this obj 'parseStatement
	       :value (js-make-function %this
			 (lambda (this token)
			    (if (vector? controller)
				((vector-ref controller 6))
				(js-raise-type-error %this
				   "detached plugin parser" this)))
			 1 'parseStatement)
	       :writable #f
	       :enumerable #t)
	    (js-bind! %this obj 'parseBlock
	       :value (js-make-function %this
			 (lambda (this)
			    (if (vector? controller)
				((vector-ref controller 7))
				(js-raise-type-error %this
				   "detached plugin parser" this)))
			 0 'parseBlock)
	       :writable #f
	       :enumerable #t)
	    (js-bind! %this obj 'parseThisBlock
	       :value (js-make-function %this
			 (lambda (this)
			    (let ((self (instantiate::J2SDecl
					   (loc `(at "_js2scheme" 0))
					   (_scmid 'this)
					   (id 'this))))
			       (if (vector? controller)
				   (let ((block ((vector-ref controller 9) self)))
				      (js-alist->jsobject
					 `((:self . ,self) (:block . ,block))
					 %this))
				   (js-raise-type-error %this
				      "detached plugin parser" this))))
			 0 'parseThisBlock)
	       :writable #f
	       :enumerable #t)
	    (js-bind! %this obj 'parseCondExpression
	       :value (js-make-function %this
			 (lambda (this)
			    (if (vector? controller)
				((vector-ref controller 8) #f)
				(js-raise-type-error %this
				   "detached plugin parser" this)))
			 0 'parseCondExpression)
	       :writable #f
	       :enumerable #t)
	    (js-bind! %this obj 'parseDollarExpression
	       :value (js-make-function %this
			 (lambda (this)
			    (if (vector? controller)
				((vector-ref controller 10))
				(js-raise-type-error %this
				   "detached plugin parser" this)))
			 0 'parseDollarExpression)
	       :writable #f
	       :enumerable #t)
	    (for-each (lambda (s)
			 (js-bind! %this obj s
			    :value (symbol->string! s) :writable #f))
	       '(DOT DOTS SEMICOLON COMMA LBRACE RBRACE LPAREN RPAREN ID DOLLAR
		 LBRACKET RBRACKET OR BIT_OR STRING
		 await break case catch const continue debugger default
		 delete do else false finally for function if in instanceof
		 let new null return switch this throw true try typeof var
		 void while with yield class extends super static))
	    (for-each (lambda (ns)
			 (js-bind! %this obj (car ns)
			    :value (cadr ns) :writable #f))
	       '((ELSE "else") (COLUMN ":") (EGAL "=") (NOTEGAL "!=")
		 (EGALEGAL "==") (NOTEGALEGAL "!==")
		 (LT "<") (GT ">") (LE "<=") (GE ">=")
		 (PLUS "+") (MINUS "-") (MUL "*") (PERCENT "%")
		 (PLUSPLUS "++") (MINUSMINUS "--") 
		 (SHIFTL "<<") (SHIFTR ">>") (USHIFTR ">>>")
		 (AMP "&") (HAT "^") (BANG "!") (TILDE "~") (AND "&&")
		 (PLUSEGAL "+=") (MINUSEGAL "-=") (MULEGAL "*=") 
		 (PERCENTEGAL "%=") (SHIFTLEGAL "<<=") (SHIFTREGAL ">>=")
		 (USHIFTREGAL ">>>=") (AMPEGAL "&=") (HATEGAL "^=")
		 (DIVEGAL "/=") (DIV "/") (QUESTIONMARK "?")
		 (LARROW "=>")))
	    obj)))

   (with-access::JsGlobalObject %this (js-function-prototype)
      (js-bind! %this exports 'Parser
	 :value (js-make-function %this (lambda (this) (js-undefined)) 0 'Parser
		   :__proto__ js-function-prototype
		   :prototype parser-prototype
		   :construct (lambda (_)
				 (instantiate::J2SParser
				    (__proto__ parser-prototype)
				    (cmap (instantiate::JsConstructMap))
				    (plugins (list (cons #f #f))))))
	 :writable #f :enumerable #t))
   
   (js-bind! %this exports 'compile
      :value (js-make-function %this
		(lambda (this ipath opath)
		   (let ((tgt (j2s-compile ipath "/tmp")))
		      (if (eq? opath (js-undefined))
			  (js-string->jsstring 
			     (call-with-output-string
				(lambda (op)
				   (pp tgt op))))
			  (call-with-output-file (js-tostring opath %this)
			     (lambda (op)
				(pp tgt op)
				opath)))))
		2 'compile)
      :writable #f
      :enumerable #t))
			 
;*---------------------------------------------------------------------*/
;*    js->ast ...                                                      */
;*---------------------------------------------------------------------*/
(define (js->ast %this n)

   (define (symbol-field? clazz f)
      (or (eq? (class-field-type f) 'symbol)
	  (and (eq? clazz J2SFun) (eq? (class-field-name f) 'idthis))))
   
   (define (jsobject->node js)
      (let* ((cname (js-tostring (js-get js '__node__ %this) %this))
	     (clazz (find-class (string->symbol cname)))
	     (ctor (class-constructor clazz))
	     (inst ((class-allocator clazz)))
	     (fields (class-all-fields clazz)))
	 ;; instance fields
	 (let loop ((i (-fx (vector-length fields) 1)))
	    (when (>=fx i 0)
	       (let* ((f (vector-ref-ur fields i))
		      (n (class-field-name f)))
;* 		  (tprint "c=" cname " n=" n                           */
;* 		     " " (typeof (js-get js n %this)) "/"              */
;* 		     (class-field-type f))                             */
		  (cond
		     ((js-has-property js n %this)
		      (let ((v (js->node (js-get js n %this))))
			 ((class-field-mutator f)
			  inst
			  (cond
			     ((eq? (class-field-type f) 'symbol)
			      (if (string? v)
				  (string->symbol v)
				  (js-raise-type-error %this 
				     (format "js->ast: bad field type ~a.~a, string expected, ~~a provided"
					cname n)
				     (typeof v))))
			     ((eq? (class-field-type f) 'pair-nil)
			      (cond
				 ((or (null? v) (pair? v))
				  v)
				 ((vector? v)
				  (vector->list v))
				 (else
				  (js-raise-type-error %this 
				     (format "js->ast: bad field type ~a.~a, vector expected, ~~a provided"
					cname n)
				     (typeof v)))))
			     ((symbol-field? clazz f)
			      (if (string? v)
				  (string->symbol v)
				  v))
			     (else
			      v)))))
		     ((class-field-default-value? f)
		      ((class-field-mutator f)
		       inst (class-field-default-value f)))
		     ((not (member "nojson" (class-field-info f)))
		      (error "js->ast"
			 (format "Missing field \"~a\"" n) cname)))
		  (loop (-fx i 1)))))
	 ;; constructor
	 (when (procedure? ctor) ctor inst)
	 inst))

   (define (js->node n)
      (cond
	 ((isa? n J2SNode)
	  n)
	 ((isa? n JsString)
	  (js-jsstring->string n))
	 ((or (isa? n JsString) (isa? n JsStringLiteral))
	  (js-jsstring->string n))
	 ((isa? n JsArray)
	  (map! (lambda (c) (js->node (car c))) (jsarray->list n %this)))
	 ((isa? n JsObject)
	  (jsobject->node n))
	 (else
	  n)))

   (js->node n))

;*---------------------------------------------------------------------*/
;*    ast->js ...                                                      */
;*---------------------------------------------------------------------*/
(define (ast->js ast %this)
   (if (pair? ast)
       (js-vector->jsarray (list->vector ast) %this)
       ast))
