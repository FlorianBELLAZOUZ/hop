/*=====================================================================*/
/*    serrano/prgm/project/hop/3.2.x/node_modules/cpp/lib/cpp.js       */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Tue Mar 13 07:37:34 2018                          */
/*    Last change :  Fri Apr 27 05:33:24 2018 (serrano)                */
/*    Copyright   :  2018 Manuel Serrano                               */
/*    -------------------------------------------------------------    */
/*    CPP Hop.js language                                              */
/*=====================================================================*/
"use hopscript";

/*---------------------------------------------------------------------*/
/*    imports                                                          */
/*---------------------------------------------------------------------*/
const fs = require( "fs" );
const path = require( "path" );
const util = require( "util" );
const system = require( "./system.hop" ).system;

/*---------------------------------------------------------------------*/
/*    global configuration                                             */
/*---------------------------------------------------------------------*/
const config = require( "./cpprc.json" );
const cpprc = path.join( require( hop.config ).rcDirectory, "cpprc.js" );

/*---------------------------------------------------------------------*/
/*    vlqEncode ...                                                    */
/*---------------------------------------------------------------------*/
function vlqEncode( o ) {
   return #:js-string->jsstring( #:base64-vlq-encode( o ) );
}

/*---------------------------------------------------------------------*/
/*    getTarget ...                                                    */
/*---------------------------------------------------------------------*/
function getTarget( file ) {
   const cache = path.join( require( hop.config ).cacheDir, "cpp" );

   if( !fs.existsSync( cache ) ) {
      fs.mkdirSync( cache );
   } else if( !fs.statSync( cache ).isDirectory ) {
      throw `Not a directory ${cache}`;
   }

   return path.join( cache, path.basename( file, "js" ) +  "cpp.js" );
}

/*---------------------------------------------------------------------*/
/*    generateMappings ...                                             */
/*---------------------------------------------------------------------*/
function generateMappings( mappings ) {

   function encodeMapping( m, oldm ) {
      return vlqEncode( 0 )
	 + vlqEncode( m.sindex - oldm.sindex )
	 + vlqEncode( m.snum - oldm.snum )
	 + vlqEncode( 0 );
   }

   if( mappings.length == 0 ) {
      return "";
   } else {
      let res = "";

      for( let i = 0, g = 0, s = 0, pm = { sindex: 0, snum: 0 };
	   i < mappings.length;
	   i++ ) {
	 res += ";" + encodeMapping( mappings[ i ], pm );
	 pm = mappings[ i ];
      }

      return res;
   }
}
      
/*---------------------------------------------------------------------*/
/*    generateSourceMap ...                                            */
/*---------------------------------------------------------------------*/
function generateSourceMap( path, sources, target, mappings ) {
   const smap = {
      version: 3,
      file: target,
      sourceRoot: "",
      sources: sources,
      names: [],
      mappings: generateMappings( mappings )
   }

   fs.writeFileSync( path, JSON.stringify( smap ) );
}
   
/*---------------------------------------------------------------------*/
/*    sourceMap ...                                                    */
/*    -------------------------------------------------------------    */
/*    Uses the # N path cpp annotations to generate a JS source-map.   */
/*    This function modifies the file itself and returns the path      */
/*    name of the generated source-map file.                           */
/*---------------------------------------------------------------------*/
function sourceMap( source, file ) {
   const port = #:open-input-file( #:js-jsstring->string( file + "" ) );
   const res = file + ".map";
   let lines = "";
   let sources = [];
   let sindex = 0;
   let current = source;
   let mappings = [];

   try {
      let gnum = 0;
      let snum = 0;
      
      while( true ) {
	 let line = #:read-line( port );
	 let m;
	 
	 if( #:eof-object?( line ) ) break;

	 line = #:js-string->jsstring( line );

	 if( m = line.match( /# ([0-9]+) "([^"]+)".*/ ) ) {
	    // a line information
	    if( fs.existsSync( m[ 2 ] ) ) {
	       current = m[ 2 ];
	       snum = parseInt( m[ 1 ] );
	    }
	    lines += "// " + line + "\n";
	    mappings.push( { gnum: gnum, snum: snum, sindex: sindex } );
	    gnum++;
	 } else if( line.match( /#.*/ ) ) {
	    // skip that line
	 } else {
	    let sindex = sources.indexOf( current );
	    if( sindex < 0 ) {
	       // add the source
	       sources.push( current );
	       sindex = sources.length - 1;
	    }
	    // add the line
	    lines += line+ "\n";
	    // add the map information
	    mappings.push( { gnum: gnum, snum: snum, sindex: sindex } );
	    gnum++, snum++;
	 }
      }
   } finally {
      #:close-input-port( port );
      fs.unlinkSync( file );
      fs.writeFileSync( file, lines + "//# sourceMappingURL=" + res + "\n" );

      generateSourceMap( res, sources, file, mappings );
   }

   return res;
}
      
/*---------------------------------------------------------------------*/
/*    modified ...                                                     */
/*---------------------------------------------------------------------*/
function modified( src, tgt ) {
   return fs.statSync( src ).mtime > fs.statSync( tgt ).mtime;
}

/*---------------------------------------------------------------------*/
/*    Symbol.compiler ...                                              */
/*---------------------------------------------------------------------*/
exports[ Symbol.compiler ] = (file, options) => {
   const defopts = fs.exists( cpprc ) ? require( cpprc ) : false;
   const cc = (options && options.cc)
	 || (defopts && defopts.cc)
	 || (config && config.cc)
	 || require( hop.config ).bigloo[ "c-compiler" ];
   const cmd = (options && options.cmd)
	 || (defopts && defopts.cmd)
	 || (config && config.cmd)
	 || config.commandLine;
   const target = (options && options.target)
	 || getTarget( file );
   const P = (options && options.disableLinenumOpt)
	 || (defopts && defopts.disableLinenumOpt)
	 || (config && config.disableLinenumOpt)
	 || "";
   const srcMap = (options ? options.sourceMappingURL : #:bigloo-debug() > 0);

   if( !fs.existsSync( target ) || modified( file, target ) ) {
      const status = system( util.format( cmd, cc, srcMap ? "" : P, file, target ) );
      if( status != 0 ) {
	 throw `compilation failed with status ${status}`;
      }
   }

   if( srcMap ) {
      const smap = sourceMap( file, target );
      return { type: "filename", value: target, sourceMappingURL: smap };
   } else {
      return { type: "filename", value: target };
   }
}
