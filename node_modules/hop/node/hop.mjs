/*=====================================================================*/
/*    serrano/prgm/project/hop/hop/node_modules/hop/node/hop.mjs       */
/*    -------------------------------------------------------------    */
/*    Author      :  manuel serrano                                    */
/*    Creation    :  Tue Oct 24 09:50:25 2023                          */
/*    Last change :  Thu May  2 17:44:26 2024 (serrano)                */
/*    Copyright   :  2023-24 manuel serrano                            */
/*    -------------------------------------------------------------    */
/*    ESM module                                                       */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    Import/Export                                                    */
/*---------------------------------------------------------------------*/
import { createRequire } from 'node:module';
import { basename, dirname, normalize, relative, join, isAbsolute } from "node:path";
import { existsSync, statSync, readFileSync } from "node:fs";
import * as http from "node:http";
import * as https from "node:https";
import { URL, pathToFileURL, fileURLToPath } from 'node:url';
import { cwd } from "node:process";
import * as loader from "@hop/hopc/hop-loader.mjs";
import { UserAuth, WWWAuthenticate } from "./auth.mjs";
import { ServerEvent } from "./event.mjs";
import { init as configInit, parseCommandLine } from "./config.mjs";
import { format } from "node:util";

export * from "./html.mjs";
export { parseCommandLine } from "./config.mjs";
export { Hop,
	 Response, HTTPResponseFile, HTTPResponseString,
	 HTTPResponseAuthentication, HTTPResponseHTML };

/*---------------------------------------------------------------------*/
/*    Dynamique require                                                */
/*---------------------------------------------------------------------*/
const require = createRequire(import.meta.url);

/*---------------------------------------------------------------------*/
/*    Default parameters                                               */
/*---------------------------------------------------------------------*/
export const isServer = true;
const hopBase = "/hop";

/*---------------------------------------------------------------------*/
/*    Hop ...                                                          */
/*---------------------------------------------------------------------*/
/* @sealed */
class Hop {
   #filesTable = new Map();
   #urlsTable = new Map();
   #FileSvc;
   #fileURL;
   #broadcast;
   #key = Math.round(Math.random() * 100000);
   #hop;
   #serverEvent;

   auth;
   ports = { http: 0, https: 0 };
   config;
   backend;
   
   static cnt = 0;
   
   constructor(config) {
      this.config = configInit(config);

      // server/event initialization
      const se = this.#serverEvent = new ServerEvent(this, hopResponse);
      
      // backend initialization
      let mod;
      switch (this.config.engine) {
	 case "hop": mod = "./hop-backend.hop"; break;
	 case "express": mod = "./express-backend.js"; break;
	 case "node": mod = "./node-backend.js"; break;
	 default: throw new TypeError(`Illlegal engine "${this.config.engine}"`);
      }
      this.backend = require(mod).init(this, se.registerWebsocket.bind(se));

      // user authentication initialization
      this.auth = new UserAuth(this);

      // static files
      this.#fileURL = `/hop/${Hop.cnt++}/${this.#key}`;
      this.#FileSvc = this.backend.get(this.#fileURL, getFile.bind(this));

      // server/event registration service
      new ServiceImpl(this, function (pt) { se.init(req, pt) }, "server/event/init");
      
      // pre-register the hop client side runtime system
      const url = this.#fileURL + "?k=" + this.#filesTable.size;
      this.#filesTable.set("@hop/hop", url);
      this.#urlsTable.set(url, require.resolve("../client.mjs"));
   }

   listen() {
      return this.backend.listen();
   }

   url(filename) {
      const old = this.#filesTable.get(filename);

      if (old) {
	 return old;
      } else {
	 const url = this.#fileURL + "?k=" + this.#filesTable.size;
	 this.#filesTable.set(filename, url);
	 this.#urlsTable.set(url, filename);

	 return url;
      }
   }

   path(url) {
      return this.#urlsTable.get(url);
   }
   
   Service(fun, optOrUrl) {
      if (this instanceof Hop) {
	 const impl = new ServiceImpl(this, fun, optOrUrl);
	 const f = (...args) => new Frame(impl, args);
	 f.dollar = () => impl.dollar();
	 return f;
      } else {
	 throw new TypeError(`Service: "this" is not an Hop instance -- ${this}`);
      }
   }

   broadcast(evt, val) {
      return this.#serverEvent.broadcast(evt, val)
   }
}

/*---------------------------------------------------------------------*/
/*    getFile ...                                                      */
/*    -------------------------------------------------------------    */
/*    Deliver static files                                             */
/*---------------------------------------------------------------------*/
function getFile(req, res) {
   const filename = this.path(req.url);

   if (!filename) {
      console.error(`file "${req.url}" not found.`);
      res,status(404);
      res.send("File not found!");
   } else if (this.auth.authorizedPath(req, filename)) {
      res.status(200);
      res.sendFile(filename);
   } else {
      req.hop = this;
      return hopResponse(req, res, HTTPResponseAuthentication());
   }
}

/*---------------------------------------------------------------------*/
/*    serviceUrl ...                                                   */
/*---------------------------------------------------------------------*/
function serviceUrl(file) {
   if (file[0] === "/") {
      return file;
   } else {
      return hopBase + "/" + file;
   }
}

/*---------------------------------------------------------------------*/
/*    ServiceImpl ...                                                  */
/*---------------------------------------------------------------------*/
/* @sealed */
class ServiceImpl {
   #hop;
   #fun;
   #path;
   #key = Math.round(Math.random() * 100000);

   static #cnt = Date.now();
   
   constructor(hop, fun, optOrUrl) {
      this.#hop = hop;
      this.#fun = fun;
      if (typeof optOrUrl === "string") {
	 this.#path = serviceUrl(optOrUrl);
	 hop.backend.get(this.#path, ServiceImpl.getResponse.bind(this));
	 hop.backend.post(this.#path, ServiceImpl.postResponse.bind(this));
	 hop.backend.put(this.#path, ServiceImpl.putResponse.bind(this));
      } else if (typeof optOrUrl === "object") {
	 if ("url" in optOrUrl) {
	    hop.backend.post(this.#path, ServiceImpl.postResponse.bind(this));
	 }
      } else {
	 this.#path = serviceUrl("svc" + ServiceImpl.#cnt++);
	 hop.backend.get(this.#path, ServiceImpl.getResponse.bind(this));
	 hop.backend.post(this.#path, ServiceImpl.postResponse.bind(this));
	 hop.backend.put(this.#path, ServiceImpl.putResponse.bind(this));
      }
   }

   dollar() {
      return `hop.server.import('${this.#path}')`;
   }

   path(args) {
      if (args.length === 0) {
	 return this.#path;
      } else {
	 let json = JSON.stringify(args);
	 return this.#path + "?Hop-Serialize=json-url&Hop-Arguments="
	    + encodeURIComponent(json);
      }
   }

   schema() {
      if (this.#hop.ports.https > 0) {
	 return `https://${this.#hop.config.hostname}:${this.#hop.ports.https}`;
      } else {
	 return `http://${this.#hop.config.hostname}:${this.#hop.ports.http}`;
      }
   }
   
   static postResponse(req, res) {
      req.hop = this.#hop;
      if (this.#hop.auth.authorizedService(req, this.#path)) {
	 let rep = undefined;
	 switch (req.get("Hop-Serialize")) {
	    case "json": {
	       const args = req.get("Hop-Arguments");
	       rep = this.#fun.apply(req, JSON.parse(args));
	       break;
	    }
	    default:
	       rep = this.#fun.call(req, req.query);
	 }
	 return hopResponse(req, res, rep);
      } else {
	 return hopResponse(req, res, HTTPResponseAuthentication());
      }
   }
   
   static putResponse(req, res) {
      req.hop = this.#hop;
      if (this.#hop.auth.authorizedService(req, this.#path)) {
	 let rep = this.#fun.call(req, req.query);
	 return hopResponse(req, res, rep);
      } else {
	 return hopResponse(req, res, HTTPResponseAuthentication());
      }
   }
   
   static getResponse(req, res) {
      req.hop = this.#hop;
      if (this.#hop.auth.authorizedService(req, this.#path)) {
	 let rep;
	 switch (req.query["Hop-Serialize"]) {
	    case "json-url": {
	       const args = decodeURIComponent(req.query["Hop-Arguments"]);
	       rep = this.#fun.apply(req, JSON.parse(args));
	       break;
	    }
	    default: {
	       rep = this.#fun.call(req, req.query);
	    }
	 }
	 return hopResponse(req, res, rep);
      } else {
	 return hopResponse(req, res, HTTPResponseAuthentication());
      }
   }
}

/*---------------------------------------------------------------------*/
/*    Frame ...                                                        */
/*---------------------------------------------------------------------*/
/* @sealed */
class Frame {
   #svc;
   #args;
   
   constructor(svc,args) {
      this.#svc = svc;
      this.#args = args;
   }

   dollar() {
      return "'" + this.toString() + "'";
   }
   
   toString() {
      return `${this.#svc.schema()}${this.#svc.path(this.#args)}`;
   }
}

/*---------------------------------------------------------------------*/
/*    hopResponse ...                                                  */
/*    -------------------------------------------------------------    */
/*    This function is used to encode value returned by services       */
/*    and by event broadcast (see event.mjs).                          */
/*---------------------------------------------------------------------*/
function hopResponse(req, res, val) {
   if (val instanceof Response) {
      return val.hopResponse(req, res);
   } else if (val instanceof Promise) {
      return val.then(val => hopResponse(req, res, val));
   } else {
      // keep-alive
      const conn = req.get("connection");
      if (conn) {
	 res.set("Connection", conn);
      }

      if (typeof(val) === "number") {
	 const str = val.toString();
	 res.append("Content-Length", str.length);
	 res.append("Hop-Serialize", "number");
	 res.send(str);
      } else if (val === undefined) {
	 res.append("Content-Length", "0");
	 res.append("Hop-Serialize", "undefined");
	 res.send("");
      } else if (val === null) {
	 res.append("Content-Length", "0")
	 res.append("Hop-Serialize", "null");
	 res.send("");
      } else if (val === true) {
	 res.append("Content-Length", "0")
	 res.append("Hop-Serialize", "true");
	 res.send("");
      } else if (val === false) {
	 res.append("Content-Length", "0");
	 res.append("Hop-Serialize", "false");
	 res.send("");
      } else if (typeof(val) === "string") {
	 res.append("Content-Length", val.length);
	 res.append("Hop-Serialize", "string");
	 res.send(val);
      } else if (val instanceof Buffer) {
	 res.append("Hop-Serialize", "buffer");
	 res.send(val);
      } else if (val instanceof Date) {
	 res.append("Hop-Serialize", "date");
	 res.send(val.getTime().toString());
      } else if (!(val instanceof Object)) {
	 // native objects will follow that path
	 return val;
      } else if ("toResponse" in val) {
	 const { string, serialize } = val.toResponse();
	 res.append("Content-Length", string.length);
	 res.append("Hop-Serialize", serialize);
	 res.send(string);
      } else if (!req.get("Hop-Serialize")) {
	 const str = val.toString();
	 res.append("Content-Length", str.length);
	 res.append("Content-Type", val?.mimetype ?? "application/text");
	 res.append("Hop-Serialize", "string");
	 res.send(str);
      } else {
	 const str = JSON.stringify(val);
	 res.append("Content-Length", str.length);
	 res.append("Hop-Serialize", "json");
	 res.send(str);
      }
      return res;
   }
}
   
/*---------------------------------------------------------------------*/
/*    Response                                                         */
/*---------------------------------------------------------------------*/
/* @sealed */
class Response {
   val;
   status;
   headers;
   
   constructor(val, status = 200, headers = undefined) {
      this.val = val;
      this.status = status;
      this.headers = headers;
   }
   
   hopResponse(req, res) {
      throw `Response not implemented (${this.constructor.name})`;
   }
}

/*---------------------------------------------------------------------*/
/*    ResponseString ...                                               */
/*---------------------------------------------------------------------*/
// @sealed
class ResponseString extends Response {
   hopResponse(req, res) {
      // status
      res.status(this.status);

      // header
      if (this.headers) {
	 for (let k in this.headers) {
	    res.append(k, this.headers[k]);
	 }
      }

      // content
      res.send(this.val);
      return res;
   }
}

/*---------------------------------------------------------------------*/
/*    ResponseFile ...                                                 */
/*---------------------------------------------------------------------*/
// @sealed
class ResponseFile extends Response {
   hopResponse(req, res) {
      // header
      if (this.headers) {
	 for (let k in this.headers) {
	    res.append(k, this.headers[k]);
	 }
      }

      res.sendFile(this.val);
      return res;
   }
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseFile ...                                             */
/*---------------------------------------------------------------------*/
function HTTPResponseFile(path, opt = undefined) {
   const headers = opt || {
      "Content-Disposition": `inline; filename="${basename(path)}"`,
      "connection": "keep-alive"
   };
   return new ResponseFile(path, 200, headers);
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseString ...                                           */
/*---------------------------------------------------------------------*/
function HTTPResponseString(str, opt) {
   const headers = opt || { "connection": "keep-alive" };
   return new ResponseString(str, 200, headers);
}

/*---------------------------------------------------------------------*/
/*    ResponseAuthentication ...                                       */
/*---------------------------------------------------------------------*/
// @sealed
class ResponseAuthentication extends ResponseString {
   hopResponse(req, res) {
      // authentication
      const headers = WWWAuthenticate(
	 req.hop.config.real, req.hop.config.hostname, req.port);
      for (let k in headers) {
	 res.append(k, headers[k]);
      }
      return super.hopResponse(req, res);
   }
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseAuthentication ...                                   */
/*---------------------------------------------------------------------*/
function HTTPResponseAuthentication(opt = undefined) {
   return new ResponseAuthentication("Unauthorized", 401);
}

/*---------------------------------------------------------------------*/
/*    ResponseHTML ...                                                 */
/*---------------------------------------------------------------------*/
// @sealed
class ResponseHTML extends Response {
   hopResponse(req, res) {
      // header
      if (this.headers) {
	 for (let k in this.headers) {
	    res.append(k, this.headers[k]);
	 }
      }

      hopResponse(req, res, this.val);
      return res;
   }
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseHTML ...                                             */
/*---------------------------------------------------------------------*/
function HTTPResponseHTML(html, opt = undefined) {
   return new ResponseHTML(html, 200);
}
