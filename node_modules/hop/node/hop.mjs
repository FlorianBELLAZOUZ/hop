/*=====================================================================*/
/*    serrano/prgm/project/hop/3.7.x/node_modules/hop/node/hop.mjs     */
/*    -------------------------------------------------------------    */
/*    Author      :  manuel serrano                                    */
/*    Creation    :  Tue Oct 24 09:50:25 2023                          */
/*    Last change :  Sat Feb  3 15:11:30 2024 (serrano)                */
/*    Copyright   :  2023-24 manuel serrano                            */
/*    -------------------------------------------------------------    */
/*    ESM module                                                       */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    Import/Export                                                    */
/*---------------------------------------------------------------------*/
import { createRequire } from 'node:module';
import * as path from "node:path";
import { existsSync, statSync } from "node:fs";
import { pathToFileURL, fileURLToPath } from 'node:url';
import { cwd } from "node:process";
import * as loader from "./hop-loader.mjs";
export * from "./html.mjs";
export * from "./config.mjs";

/*---------------------------------------------------------------------*/
/*    Dynamique require                                                */
/*---------------------------------------------------------------------*/
const require = createRequire(import.meta.url);

/*---------------------------------------------------------------------*/
/*    Default parameters                                               */
/*---------------------------------------------------------------------*/
export const isServer = true;
export const engine = "node";

const hopBase = "/hop";
const hopResolveSeed = Math.round(Math.random() * 100000);
const port = 8888;

let express = false;
let app = false;

const resolveRootTable = new Map();

/*---------------------------------------------------------------------*/
/*    expressInit ...                                                  */
/*---------------------------------------------------------------------*/
function expressInit() {
   if (!express) {
      // this must be changed for ../../express
      express = require("../../../express");
      app = express();
      app.listen(port);
   }
}

/*---------------------------------------------------------------------*/
/*    getRootDir ...                                                   */
/*---------------------------------------------------------------------*/
function getRootDir(url) {
   if (!url) {
      return process.cwd();
   } else {
      const urlpath = (url instanceof URL ? fileURLToPath(url) : url.replace(/^file:\/\//, ""));
      const normpath = path.normalize(urlpath);
      if (!existsSync(urlpath)) {
	 throw `Service.resolve: path does not exists ${url}`;
      } else {
	 if (statSync(urlpath).isDirectory()) {
	    return normpath;
	 } else {
	    return path.dirname(normpath);
	 }
      }
   }
}

/*---------------------------------------------------------------------*/
/*    Resolver ...                                                     */
/*---------------------------------------------------------------------*/
export class Resolver {
   #root;
   #hooks = []
   #resolveTable = new Map();
   #num;
   #uses = new Set();

   static num = 0;

   constructor(root, ...modules) {
      this.#root = getRootDir(root);
      this.#num = Resolver.num++;

      modules.forEach(m => this.register(m, root));
      expressInit();
      app.use(`${hopBase}/${this.#num}`, express.static(this.#root, { dotfiles: "allow" }));
   }

   register(specifier, parentURL) {
      const dir = parentURL || this.#root;
      const file = require.resolve(specifier, { paths: [ dir ] });
      const m = import(file);

      m.then(ns => this.#hooks.push(ns.resolve));
   }

   resolve(mod) {
      const old = this.#resolveTable.get(mod);

      if (old) {
	 return old.url;
      } else {
	 const hooks = this.#hooks;
	 const root = this.#root;
	 const ctx = { parentURL: pathToFileURL(root) };
	 let index = 0;
	 const nextr = async (s, c) => {
	    if (index === hooks.length) {
	       const p = require.resolve(s, { paths: [ root ] });
	       return { url: pathToFileURL(p) };
	    } else {
	       return hooks[index++](s, ctx, nextr);
	    }
	 }
	 return loader.resolve(mod, ctx, nextr)
	    .then(u => {
	       const file = fileURLToPath(u.url);
	       const relfile = path.relative(this.#root, file);
	       const url = `${hopBase}/${this.#num}/${relfile}`;

	       this.#resolveTable.set(mod, { url });
	       return url;
	    });
      }
   }
}

/*---------------------------------------------------------------------*/
/*    serviceUrl ...                                                   */
/*---------------------------------------------------------------------*/
function serviceUrl(file) {
   if (file[0] === "/") {
      return file;
   } else {
      return hopBase + "/" + file;
   }
}

/*---------------------------------------------------------------------*/
/*    Service ...                                                      */
/*---------------------------------------------------------------------*/
/* @sealed */
export class Service {
   #fun;
   #url;
   #key = Math.round(Math.random() * 100000);

   constructor(fun, optOrUrl) {
      expressInit();
      
      this.#fun = fun;
      if (typeof optOrUrl === "string") {
	 this.#url = serviceUrl(optOrUrl);
	 const hdl = (req, res) =>
	    hopResponse(req, res, this.invoke(req));
	 app.get(this.#url, hdl);
	 app.post(this.#url, hdl);
      } else if (typeof optOrUrl === "object") {
	 if ("url" in optOrUrl) {
	    app.post(this.#url, (req, res) => {
	       hopResponse(req, res, this.invoke(req));
	    });
	 }
      } else {
	 throw "Service: not implemented yet";
      }
   }

   dollar() {
      return `new hop.Service('${this.#url}')`;
   }

   invoke(req) {
      switch (req.get("Hop-Serialize")) {
	 case "x-hop":
	    return this.#fun.apply(req, []);
	 case "json":
	    return this.#fun.apply(req, JSON.parse(req.get("Hop-Arguments")));
	 default:
	    return this.#fun.call(req, req.query);
      }
   }
}

/*---------------------------------------------------------------------*/
/*    hopResponse ...                                                  */
/*---------------------------------------------------------------------*/
function hopResponse(req, res, val) {

   // keep-alive
   if (req.get("connection")) {
      res.set("Connection", req.Connection);
   }

   if (val instanceof Promise) {
      val.then(val => hopResponse(req, res, val));
   } else if (typeof(val) === "number") {
      const str = val.toString();
      res.append("Content-Length", str.length);
      res.append("Hop-Serialize", "number");
      res.send(str);
   } else if (val === undefined) {
      res.append("Content-Length", "0");
      res.append("Hop-Serialize", "undefined");
      res.send("");
   } else if (val === null) {
      res.append("Content-Length", "0")
      res.append("Hop-Serialize", "null");
      res.send("");
   } else if (val === true) {
      res.append("Content-Length", "0")
      res.append("Hop-Serialize", "true");
      res.send("");
   } else if (val === false) {
      res.append("Content-Length", "0");
      res.append("Hop-Serialize", "false");
      res.send("");
   } else if (!req.get("Hop-Serialize")) {
      const str = val.toString();
      res.append("Content-Length", str.length);
      res.append("Content-Type", val?.mimetype ?? "application/text");
      res.send(str);
   } else if (val instanceof response) {
      val.hopResponse(req, res);
   } else if (typeof(val) === "string") {
      res.append("Content-Length", val.length);
      res.send(val);
   } else if ("toResponse" in val) {
      const str = val.toResponse();
      res.append("Content-Length", str.length);
      res.append("Hop-Serialize", "string");
      res.send(str);
   } else {
      const str = JSON.stringify(val);
      res.append("Content-Length", str.length);
      res.append("Hop-Serialize", "json");
      res.send(str);
   }
}

/*---------------------------------------------------------------------*/
/*    jsonArgp ...                                                     */
/*    -------------------------------------------------------------    */
/*    Can the argument being serialized using the JSON format?         */
/*---------------------------------------------------------------------*/
function jsonArgp(n) {
   const t = typeof(n);
   return t === "number" || t === "string" || t === "boolean";
}

/*---------------------------------------------------------------------*/
/*    response                                                         */
/*---------------------------------------------------------------------*/
export class response {
   val;
   constructor(val) {
      this.val = val;
   }
   hopResponse(req, res) {
      throw "not implemented";
   }
}

/*---------------------------------------------------------------------*/
/*    responseString ...                                               */
/*---------------------------------------------------------------------*/
export class responseString extends response {
   hopResponse(req, res) {
      res.send(this.val);
   }
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseString ...                                           */
/*---------------------------------------------------------------------*/
export function HTTPResponseString(str) {
   return new responseString(str);
}
/*---------------------------------------------------------------------*/
/*    responseFile ...                                                 */
/*---------------------------------------------------------------------*/
export class responseFile extends response {
   hopResponse(res) {
      res.sendFile(this.val);
   }
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseFile ...                                             */
/*---------------------------------------------------------------------*/
export function HTTPResponseFile(path) {
   return new responseFile(path);
}
   
