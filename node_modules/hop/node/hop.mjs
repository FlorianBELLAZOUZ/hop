/*=====================================================================*/
/*    serrano/prgm/project/hop/hop/node_modules/hop/node/hop.mjs       */
/*    -------------------------------------------------------------    */
/*    Author      :  manuel serrano                                    */
/*    Creation    :  Tue Oct 24 09:50:25 2023                          */
/*    Last change :  Wed Mar 27 13:54:14 2024 (serrano)                */
/*    Copyright   :  2023-24 manuel serrano                            */
/*    -------------------------------------------------------------    */
/*    ESM module                                                       */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    Import/Export                                                    */
/*---------------------------------------------------------------------*/
import { createRequire } from 'node:module';
import { basename, dirname, normalize, relative, join } from "node:path";
import { existsSync, statSync, readFileSync, realpathSync } from "node:fs";
import * as http from "node:http";
import * as https from "node:https";
import { URL, pathToFileURL, fileURLToPath } from 'node:url';
import { cwd } from "node:process";
import * as loader from "@hop/hopc/hop-loader.mjs";
import { init as authInit, WWWAuthenticate, authorizedService } from "./auth.mjs";
import { init as configInit, parseCommandLine } from "./config.mjs";
import { format } from "node:util";

export * from "./html.mjs";
export { parseCommandLine } from "./config.mjs";
export { hopInit as init,
	 Resolver, Service, ServiceImpl, Frame, Response, 
	 HTTPResponseFile, HTTPResponseString, HTTPResponseAuthentication };

/*---------------------------------------------------------------------*/
/*    Dynamique require                                                */
/*---------------------------------------------------------------------*/
const require = createRequire(import.meta.url);

/*---------------------------------------------------------------------*/
/*    Default parameters                                               */
/*---------------------------------------------------------------------*/
export const isServer = true;

const hopBase = "/hop";

let backend = undefined;

/*---------------------------------------------------------------------*/
/*    getRootDir ...                                                   */
/*---------------------------------------------------------------------*/
function getRootDir(url) {
   if (!url) {
      return process.cwd();
   } else {
      const urlpath = (url instanceof URL ? fileURLToPath(url) : url.replace(/^file:\/\//, ""));
      const normpath = normalize(urlpath);
      if (!existsSync(urlpath)) {
	 throw `Service.resolve: path does not exists ${url}`;
      } else {
	 if (statSync(urlpath).isDirectory()) {
	    return normpath;
	 } else {
	    return dirname(normpath);
	 }
      }
   }
}

/*---------------------------------------------------------------------*/
/*    backendInit ...                                                  */
/*---------------------------------------------------------------------*/
function backendInit(config) {
   const mod = (config.engine === "hop" ? "./hop-backend.hop" : "./node-backend.js");
   return require(mod).init(config);
}

/*---------------------------------------------------------------------*/
/*    config ...                                                       */
/*---------------------------------------------------------------------*/
let config = false;

/*---------------------------------------------------------------------*/
/*    hopInit ...                                                      */
/*---------------------------------------------------------------------*/
function hopInit(args = undefined) {
   if (!config) {
      config = configInit(args);
      backend = backendInit(config);
      authInit();
      
      // motd
      if (config.motd && config.verbose >= 1) {
         console.log(format(config.motd, config.ports.http, config.ports.https));
      }
   }
   return config;
}

/*---------------------------------------------------------------------*/
/*    Resolver ...                                                     */
/*---------------------------------------------------------------------*/
/* @sealed */
class Resolver {
   #root;
   #hooks = []
   #resolveTable = new Map();
   #pathTable = new Map();
   #num;

   static num = 1;

   constructor(root, ...modules) {
      this.#root = realpathSync(getRootDir(root));
      this.#num = Resolver.num++;

      modules.forEach(m => this.register(m, root));
      hopInit();
      backend.static(this.#num, this.#root);
   }

   registerTBR(specifier, parentURL) {
      const dir = parentURL || this.#root;
      const file = require.resolve(specifier, { paths: [ dir ] });
      const m = import(file);

      m.then(ns => this.#hooks.push(ns.resolve));
   }

   register(relfile) {
      const filename = normalize(join(this.#root, relfile));
      const old = this.#resolveTable.get(filename);

      if (filename.substring(0, this.#root.length) !== this.#root) {
	 throw new Error(`Resolver.register: file not in root directory ${relfile}`);
      } else if (!existsSync(filename)) {
	 throw new Error(`Resolver.register: file doest not exists in directory ${this.#root}/${relfile}`);
      }
      
      if (old) {
	 return old.url;
      } else {
	 const url = `${hopBase}/${this.#num}/${relfile}`;

	 this.#resolveTable.set(filename, { url });
	 this.#pathTable.set(url, filename);
	 return url;
      }
   }
   
   resolve(mod) {
      const old = this.#resolveTable.get(mod);

      if (old) {
	 return old.url;
      } else {
	 const hooks = this.#hooks;
	 const root = this.#root;
	 const ctx = { parentURL: pathToFileURL(root) };
	 let index = 0;

	 const nextr = async (s, c) => {
	    if (index === hooks.length) {
	       const p = require.resolve(s, { paths: [ root ] });
	       return { url: pathToFileURL(p) };
	    } else {
	       return hooks[index++](s, ctx, nextr);
	    }
	 }
	 
	 return loader.resolve(mod, ctx, nextr)
	    .then(u => {
	       const file = fileURLToPath(u.url);
	       const relfile = relative(this.#root, file);
	       const url = `${hopBase}/${this.#num}/${relfile}`;

	       this.#resolveTable.set(mod, { url });
	       this.#pathTable.set(url, mod);
	       return url;
	    });
      }
   }

   path(url) {
      return this.#pathTable.get(url);
   }
}

/*---------------------------------------------------------------------*/
/*    serviceUrl ...                                                   */
/*---------------------------------------------------------------------*/
function serviceUrl(file) {
   if (file[0] === "/") {
      return file;
   } else {
      return hopBase + "/" + file;
   }
}

/*---------------------------------------------------------------------*/
/*    Service ...                                                      */
/*---------------------------------------------------------------------*/
function Service(fun, optOrUrl) {
   const impl = new ServiceImpl(fun, optOrUrl);
   const f = (...args) => new Frame(impl, args);
   f.dollar = () => impl.dollar();
   return f;
}

/*---------------------------------------------------------------------*/
/*    ServiceImpl ...                                                  */
/*---------------------------------------------------------------------*/
/* @sealed */
class ServiceImpl {
   #fun;
   #path;
   #key = Math.round(Math.random() * 100000);

   constructor(fun, optOrUrl) {
      hopInit();
      
      this.#fun = fun;
      if (typeof optOrUrl === "string") {
	 this.#path = serviceUrl(optOrUrl);
	 backend.get(this.#path, ServiceImpl.getResponse.bind(this));
	 backend.post(this.#path, ServiceImpl.postResponse.bind(this));
	 backend.put(this.#path, ServiceImpl.putResponse.bind(this));
      } else if (typeof optOrUrl === "object") {
	 if ("url" in optOrUrl) {
	    backend.post(this.#path, ServiceImpl.postResponse.bind(this));
	 }
      } else {
	 throw "Service: not implemented yet";
      }
   }

   dollar() {
      return `hop.server.import('${this.#path}')`;
   }

   path(args) {
      if (args.length === 0) {
	 return this.#path;
      } else {
	 let json = JSON.stringify(args);
	 return this.#path + "?Hop-Serialize=json-url&Hop-Arguments="
	    + encodeURIComponent(json);
      }
   }
   
   static postResponse(req, res) {
      if (authorizedService(req, this.#path)) {
	 let rep = undefined;
	 switch (req.get("Hop-Serialize")) {
	    case "json": {
	       const args = req.get("Hop-Arguments");
	       rep = this.#fun.apply(req, JSON.parse(args));
	       break;
	    }
	    default:
	       rep = this.#fun.call(req, req.query);
	 }
	 return hopResponse(req, res, rep);
      } else {
	 return hopResponse(req, res, HTTPResponseAuthentication());
      }
   }
   
   static putResponse(req, res) {
      if (authorizedService(req, this.#path)) {
	 let rep = undefined;
	 rep = this.#fun.call(req, req.query);
	 return hopResponse(req, res, rep);
      } else {
	 return hopResponse(req, res, HTTPResponseAuthentication());
      }
   }
   
   static getResponse(req, res) {
      if (authorizedService(req, this.#path)) {
	 let rep;
	 switch (req.query["Hop-Serialize"]) {
	    case "json-url": {
	       const args = decodeURIComponent(req.query["Hop-Arguments"]);
	       rep = this.#fun.apply(req, JSON.parse(args));
	       break;
	    }
	    default: {
	       rep = this.#fun.call(req, req.query);
	    }
	 }
	 return hopResponse(req, res, rep);
      } else {
	 return hopResponse(req, res, HTTPResponseAuthentication());
      }
   }
}

/*---------------------------------------------------------------------*/
/*    Frame ...                                                        */
/*---------------------------------------------------------------------*/
/* @sealed */
class Frame {
   #svc;
   #args;
   
   constructor(svc,args) {
      this.#svc = svc;
      this.#args = args;
   }

   dollar() {
      return "'" + this.toString() + "'";
   }
   
   toString() {
      const H = hopInit();
      return `http://${H.hostname}:${H.ports.http}${this.#svc.path(this.#args)}`;
   }
}

/*---------------------------------------------------------------------*/
/*    hopResponse ...                                                  */
/*---------------------------------------------------------------------*/
function hopResponse(req, res, val) {
   if (val instanceof Response) {
      return val.hopResponse(req, res);
   } else if (val instanceof Promise) {
      return val.then(val => hopResponse(req, res, val));
   } else {
      // keep-alive
      if (req.get("connection")) {
	 res.set("Connection", req.Connection);
      }

      if (typeof(val) === "number") {
	 const str = val.toString();
	 res.append("Content-Length", str.length);
	 res.append("Hop-Serialize", "number");
	 res.send(str);
      } else if (val === undefined) {
	 res.append("Content-Length", "0");
	 res.append("Hop-Serialize", "undefined");
	 res.send("");
      } else if (val === null) {
	 res.append("Content-Length", "0")
	 res.append("Hop-Serialize", "null");
	 res.send("");
      } else if (val === true) {
	 res.append("Content-Length", "0")
	 res.append("Hop-Serialize", "true");
	 res.send("");
      } else if (val === false) {
	 res.append("Content-Length", "0");
	 res.append("Hop-Serialize", "false");
	 res.send("");
      } else if (typeof(val) === "string") {
	 res.append("Content-Length", val.length);
	 res.send(val);
      } else if (!(val instanceof Object)) {
	 // native objects will follow that path
	 return val;
      } else if (!req.get("Hop-Serialize")) {
	 const str = val.toString();
	 res.append("Content-Length", str.length);
	 res.append("Content-Type", val?.mimetype ?? "application/text");
	 res.send(str);
      } else if ("toResponse" in val) {
	 const str = val.toResponse();
	 res.append("Content-Length", str.length);
	 res.append("Hop-Serialize", "string");
	 res.send(str);
      } else {
	 const str = JSON.stringify(val);
	 res.append("Content-Length", str.length);
	 res.append("Hop-Serialize", "json");
	 res.send(str);
      }
      return res;
   }
}
   
/*---------------------------------------------------------------------*/
/*    Response                                                         */
/*---------------------------------------------------------------------*/
/* @sealed */
class Response {
   val;
   status;
   headers;
   
   constructor(val, status = 200, headers = undefined) {
      this.val = val;
      this.status = status;
      this.headers = headers;
   }
   
   hopResponse(req, res) {
      throw `Response not implemented (${this.constructor.name})`;
   }
}

/*---------------------------------------------------------------------*/
/*    ResponseString ...                                               */
/*---------------------------------------------------------------------*/
/* @sealed */
class ResponseString extends Response {
   hopResponse(req, res) {
      // status
      res.status(this.status);

      // header
      if (this.headers) {
	 for (let k in this.headers) {
	    res.append(k, this.headers[k]);
	 }
      }

      // content
      res.send(this.val);
      return res;
   }
}

/*---------------------------------------------------------------------*/
/*    ResponseFile ...                                                 */
/*---------------------------------------------------------------------*/
/* @sealed */
class ResponseFile extends Response {
   hopResponse(req, res) {
      // header
      if (this.headers) {
	 for (let k in this.headers) {
	    res.append(k, this.headers[k]);
	 }
      }

      res.sendFile(this.val);
      return res;
   }
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseFile ...                                             */
/*---------------------------------------------------------------------*/
function HTTPResponseFile(path, opt = undefined) {
   return new ResponseFile(path, 200, {
      "Content-Disposition": `inline; filename="${basename(path)}"`,
      "connection": opt?.connection || "keep-alive"
   });
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseString ...                                           */
/*---------------------------------------------------------------------*/
function HTTPResponseString(str, opt = undefined) {
   return new ResponseString(str, {
      "connection": opt?.connection || "keep-alive"
   });
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseAuthentication ...                                   */
/*---------------------------------------------------------------------*/
function HTTPResponseAuthentication(opt = undefined) {
   return new ResponseString("Unauthorized", 401, WWWAuthenticate());
}

