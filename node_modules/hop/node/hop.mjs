/*=====================================================================*/
/*    serrano/prgm/project/hop/3.7.x/node_modules/hop/node/hop.mjs     */
/*    -------------------------------------------------------------    */
/*    Author      :  manuel serrano                                    */
/*    Creation    :  Tue Oct 24 09:50:25 2023                          */
/*    Last change :  Tue Feb 13 14:49:01 2024 (serrano)                */
/*    Copyright   :  2023-24 manuel serrano                            */
/*    -------------------------------------------------------------    */
/*    ESM module                                                       */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    Import/Export                                                    */
/*---------------------------------------------------------------------*/
import { createRequire } from 'node:module';
import { basename, dirname, normalize, relative } from "node:path";
import { existsSync, statSync } from "node:fs";
import { pathToFileURL, fileURLToPath } from 'node:url';
import { cwd } from "node:process";
import * as loader from "@hop/hopc/hop-loader.mjs";
import { WWWAuthenticate, authorizedService } from "./auth.mjs";
import { config } from "./config.mjs";
import { format } from "node:util";

export * from "./html.mjs";
export { config } from "./config.mjs";


/*---------------------------------------------------------------------*/
/*    Dynamique require                                                */
/*---------------------------------------------------------------------*/
const require = createRequire(import.meta.url);

/*---------------------------------------------------------------------*/
/*    Default parameters                                               */
/*---------------------------------------------------------------------*/
export const isServer = true;
export const engine = "node";

const hopBase = "/hop";
const hopResolveSeed = Math.round(Math.random() * 100000);

let express = false;
let app = false;

const resolveRootTable = new Map();

/*---------------------------------------------------------------------*/
/*    getRootDir ...                                                   */
/*---------------------------------------------------------------------*/
function getRootDir(url) {
   if (!url) {
      return process.cwd();
   } else {
      const urlpath = (url instanceof URL ? fileURLToPath(url) : url.replace(/^file:\/\//, ""));
      const normpath = normalize(urlpath);
      if (!existsSync(urlpath)) {
	 throw `Service.resolve: path does not exists ${url}`;
      } else {
	 if (statSync(urlpath).isDirectory()) {
	    return normpath;
	 } else {
	    return dirname(normpath);
	 }
      }
   }
}

/*---------------------------------------------------------------------*/
/*    expressInit ...                                                  */
/*---------------------------------------------------------------------*/
function expressInit() {
   if (!express) {
      express = require("../../../express");
      app = express();
      app.listen(config.ports.http);
      app.use(`${hopBase}/0`, express.static(dirname(getRootDir(import.meta.url))));

      // motd
      if (config.motd && config.verbose >= 1) {
	 console.log(format(config.motd, config.ports.http, config.ports.https));
      }
   }
}

/*---------------------------------------------------------------------*/
/*    Resolver ...                                                     */
/*---------------------------------------------------------------------*/
export class Resolver {
   #root;
   #hooks = []
   #resolveTable = new Map();
   #num;
   #uses = new Set();

   static num = 1;

   constructor(root, ...modules) {
      this.#root = getRootDir(root);
      this.#num = Resolver.num++;

      modules.forEach(m => this.register(m, root));
      expressInit();
      app.use(`${hopBase}/${this.#num}`, express.static(this.#root, { dotfiles: "allow" }));
   }

   register(specifier, parentURL) {
      const dir = parentURL || this.#root;
      const file = require.resolve(specifier, { paths: [ dir ] });
      const m = import(file);

      m.then(ns => this.#hooks.push(ns.resolve));
   }

   resolve(mod) {
      const old = this.#resolveTable.get(mod);

      if (old) {
	 return old.url;
      } else {
	 const hooks = this.#hooks;
	 const root = this.#root;
	 const ctx = { parentURL: pathToFileURL(root) };
	 let index = 0;
	 const nextr = async (s, c) => {
	    if (index === hooks.length) {
	       const p = require.resolve(s, { paths: [ root ] });
	       return { url: pathToFileURL(p) };
	    } else {
	       return hooks[index++](s, ctx, nextr);
	    }
	 }
	 return loader.resolve(mod, ctx, nextr)
	    .then(u => {
	       const file = fileURLToPath(u.url);
	       const relfile = relative(this.#root, file);
	       const url = `${hopBase}/${this.#num}/${relfile}`;

	       this.#resolveTable.set(mod, { url });
	       return url;
	    });
      }
   }
}

/*---------------------------------------------------------------------*/
/*    serviceUrl ...                                                   */
/*---------------------------------------------------------------------*/
function serviceUrl(file) {
   if (file[0] === "/") {
      return file;
   } else {
      return hopBase + "/" + file;
   }
}

/*---------------------------------------------------------------------*/
/*    Service ...                                                      */
/*---------------------------------------------------------------------*/
/* @sealed */
export class Service {
   #fun;
   #url;
   #key = Math.round(Math.random() * 100000);

   constructor(fun, optOrUrl) {
      expressInit();
      
      this.#fun = fun;
      if (typeof optOrUrl === "string") {
	 this.#url = serviceUrl(optOrUrl);
	 app.get(this.#url, Service.getResponse.bind(this));
	 app.post(this.#url, Service.postResponse.bind(this));
	 app.put(this.#url, Service.putResponse.bind(this));
      } else if (typeof optOrUrl === "object") {
	 if ("url" in optOrUrl) {
	    app.post(this.#url, Service.postResponse.bind(this));
	 }
      } else {
	 throw "Service: not implemented yet";
      }
   }

   dollar() {
      return `hop.server.import('${this.#url}')`;
   }

   static postResponse(req, res) {
      if (authorizedService(req, this.#url)) {
	 let rep = undefined;
	 switch (req.get("Hop-Serialize")) {
	    case "json": {
	       const args = req.get("Hop-Arguments");
	       rep = this.#fun.apply(req, JSON.parse(args));
	       break;
	    }
	    default:
	       rep = this.#fun.call(req, req.query);
	 }
	 return hopResponse(req, res, rep);
      } else {
	 return hopResponse(req, res, HTTPResponseAuthentication());
      }
   }
   
   static putResponse(req, res) {
      if (authorizedService(req, this.#url)) {
	 let rep = undefined;
	 rep = this.#fun.call(req, req.query);
	 return hopResponse(req, res, rep);
      } else {
	 return hopResponse(req, res, HTTPResponseAuthentication());
      }
   }
   
   static getResponse(req, res) {
      if (authorizedService(req, this.#url)) {
	 let rep;
	 switch (req.query["Hop-Serialize"]) {
	    case "json-url": {
	       const args = decodeURIComponent(req.query["Hop-Arguments"]);
	       rep = this.#fun.apply(req, JSON.parse(args));
	       break;
	    }
	    default:
	       rep = this.#fun.call(req, req.query);
	 }
	 return hopResponse(req, res, rep);
      } else {
	 return hopResponse(req, res, HTTPResponseAuthentication());
      }
   }
}

/*---------------------------------------------------------------------*/
/*    hopResponse ...                                                  */
/*---------------------------------------------------------------------*/
function hopResponse(req, res, val) {
   // keep-alive
   if (req.get("connection")) {
      res.set("Connection", req.Connection);
   }

   if (val instanceof Promise) {
      val.then(val => hopResponse(req, res, val));
   } else if (typeof(val) === "number") {
      const str = val.toString();
      res.append("Content-Length", str.length);
      res.append("Hop-Serialize", "number");
      res.send(str);
   } else if (val === undefined) {
      res.append("Content-Length", "0");
      res.append("Hop-Serialize", "undefined");
      res.send("");
   } else if (val === null) {
      res.append("Content-Length", "0")
      res.append("Hop-Serialize", "null");
      res.send("");
   } else if (val === true) {
      res.append("Content-Length", "0")
      res.append("Hop-Serialize", "true");
      res.send("");
   } else if (val === false) {
      res.append("Content-Length", "0");
      res.append("Hop-Serialize", "false");
      res.send("");
   } else if (val instanceof response) {
      val.hopResponse(req, res);
   } else if (!req.get("Hop-Serialize")) {
      const str = val.toString();
      res.append("Content-Length", str.length);
      res.append("Content-Type", val?.mimetype ?? "application/text");
      res.send(str);
   } else if (typeof(val) === "string") {
      res.append("Content-Length", val.length);
      res.send(val);
   } else if ("toResponse" in val) {
      const str = val.toResponse();
      res.append("Content-Length", str.length);
      res.append("Hop-Serialize", "string");
      res.send(str);
   } else {
      const str = JSON.stringify(val);
      res.append("Content-Length", str.length);
      res.append("Hop-Serialize", "json");
      res.send(str);
   }
}

/*---------------------------------------------------------------------*/
/*    jsonArgp ...                                                     */
/*    -------------------------------------------------------------    */
/*    Can the argument being serialized using the JSON format?         */
/*---------------------------------------------------------------------*/
function jsonArgp(n) {
   const t = typeof(n);
   return t === "number" || t === "string" || t === "boolean";
}

/*---------------------------------------------------------------------*/
/*    response                                                         */
/*---------------------------------------------------------------------*/
export class response {
   val;
   status;
   headers;
   
   constructor(val, status = 200, headers = undefined) {
      this.val = val;
      this.status = status;
      this.headers = headers;
   }
   
   hopResponse(req, res) {
      throw "not implemented";
   }
}

/*---------------------------------------------------------------------*/
/*    responseString ...                                               */
/*---------------------------------------------------------------------*/
export class responseString extends response {
   hopResponse(req, res) {
      // status 
      res.status(this.status);

      // header
      if (this.headers) {
	 for (let k in this.headers) {
	    res.append(k, this.headers[k]);
	 }
      }

      // content
      res.send(this.val);
   }
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseString ...                                           */
/*---------------------------------------------------------------------*/
export function HTTPResponseString(str) {
   return new responseString(str);
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseAuthentication ...                                   */
/*---------------------------------------------------------------------*/
export function HTTPResponseAuthentication() {
   return new responseString("Unauthorized", 401, WWWAuthenticate());
}

/*---------------------------------------------------------------------*/
/*    responseFile ...                                                 */
/*---------------------------------------------------------------------*/
export class responseFile extends response {
   hopResponse(req, res) {
      // header
      if (this.headers) {
	 for (let k in this.headers) {
	    res.append(k, this.headers[k]);
	 }
      }

      res.sendFile(this.val);
   }
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseFile ...                                             */
/*---------------------------------------------------------------------*/
export function HTTPResponseFile(path) {
   return new responseFile(path, 200, { "Content-Disposition": `inline; filename="${basename(path)}"`});
}
