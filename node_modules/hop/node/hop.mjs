/*=====================================================================*/
/*    serrano/prgm/project/hop/hop/node_modules/hop/node/hop.mjs       */
/*    -------------------------------------------------------------    */
/*    Author      :  manuel serrano                                    */
/*    Creation    :  Tue Oct 24 09:50:25 2023                          */
/*    Last change :  Tue Apr  2 13:40:09 2024 (serrano)                */
/*    Copyright   :  2023-24 manuel serrano                            */
/*    -------------------------------------------------------------    */
/*    ESM module                                                       */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    Import/Export                                                    */
/*---------------------------------------------------------------------*/
import { createRequire } from 'node:module';
import { basename, dirname, normalize, relative, join, isAbsolute } from "node:path";
import { existsSync, statSync, readFileSync } from "node:fs";
import * as http from "node:http";
import * as https from "node:https";
import { URL, pathToFileURL, fileURLToPath } from 'node:url';
import { cwd } from "node:process";
import * as loader from "@hop/hopc/hop-loader.mjs";
import { init as authInit, WWWAuthenticate, authorizedService } from "./auth.mjs";
import { init as configInit, parseCommandLine } from "./config.mjs";
import { format } from "node:util";
import { init as eventInit, serverEventInit, registerWebsocket } from "./event.mjs";

export * from "./html.mjs";
export { parseCommandLine } from "./config.mjs";
export { config, init, listen,
	 Resolver, register, resolve, Service, ServiceImpl, Frame, Response, 
	 HTTPResponseFile, HTTPResponseString, HTTPResponseAuthentication,
	 HTTPResponseHTML };
export { broadcast } from "./event.mjs";

/*---------------------------------------------------------------------*/
/*    Dynamique require                                                */
/*---------------------------------------------------------------------*/
const require = createRequire(import.meta.url);

/*---------------------------------------------------------------------*/
/*    Default parameters                                               */
/*---------------------------------------------------------------------*/
export const isServer = true;
const hopBase = "/hop";
let backend = false;
let config = false;

/*---------------------------------------------------------------------*/
/*    getRootDir ...                                                   */
/*---------------------------------------------------------------------*/
function getRootDir(url) {
   if (!url) {
      return process.cwd();
   } else {
      const urlpath = (url instanceof URL ? fileURLToPath(url) : url.replace(/^file:\/\//, ""));
      const normpath = normalize(urlpath);
      if (!existsSync(urlpath)) {
	 throw `Service.resolve: path does not exists ${url}`;
      } else {
	 if (statSync(urlpath).isDirectory()) {
	    return normpath;
	 } else {
	    return dirname(normpath);
	 }
      }
   }
}

/*---------------------------------------------------------------------*/
/*    backendInit ...                                                  */
/*---------------------------------------------------------------------*/
function backendInit(config) {
   if (!backend) {
      const mod = (config.engine === "hop" ? "./hop-backend.hop" : "./node-backend.js");
      backend = require(mod).init(config, registerWebsocket);
   }
}

/*---------------------------------------------------------------------*/
/*    init ...                                                         */
/*---------------------------------------------------------------------*/
function init(cfg = {}) {
   if (!config) {
      config = configInit(cfg);
      authInit(config);
      
      // configure the backend
      backendInit(config);

      // initialize server events (for broadcast)
      eventInit(config, hopResponse);
      new ServiceImpl(serverEventInit, "server/event/init");
   }
   return config;
}

/*---------------------------------------------------------------------*/
/*    checkInit ...                                                    */
/*---------------------------------------------------------------------*/
function checkInit(msg) {
   if (!config) {
      throw `hop: hop not initialized -- call "hop.init()" before "${msg}"`;
   }
}

/*---------------------------------------------------------------------*/
/*    listen ...                                                       */
/*---------------------------------------------------------------------*/
function listen(motd = undefined) {
   // check server init
   checkInit("hop.listen(...)");

   // start the server
   backend.listen();

   // motd
   if (motd && config.verbose >= 1) {
      console.log(format(motd, config.ports.http, config.ports.https));
   }
}

/*---------------------------------------------------------------------*/
/*    Resolver ...                                                     */
/*---------------------------------------------------------------------*/
/* @sealed */
class Resolver {
   #root;
   #hooks = []
   #resolveTable = new Map();
   #pathTable = new Map();
   #num;

   static num = 1;

   constructor(root, ...modules) {
      this.#root = getRootDir(root);
      this.#num = Resolver.num++;

      checkInit("new Resolver(...)");
      modules.forEach(m => this.register(m, root));
      backend.static(this.#num, this.#root);
   }

   registerTBR(specifier, parentURL) {
      const dir = parentURL || this.#root;
      const file = require.resolve(specifier, { paths: [ dir ] });
      const m = import(file);

      m.then(ns => this.#hooks.push(ns.resolve));
   }

   register(file) {
      const relfile = isAbsolute(file) ? relative(this.#root, file) : file;
      const filename = normalize(join(this.#root, relfile));
      const old = this.#resolveTable.get(filename);

      if (filename.substring(0, this.#root.length) !== this.#root) {
	 throw new Error(`Resolver.register: file not in root directory ${relfile}`);
      } else if (!existsSync(filename)) {
	 throw new Error(`Resolver.register: file does not exists in directory ${this.#root}/${relfile}`);
      }
      
      if (old) {
	 return old.url;
      } else {
	 const url = `${hopBase}/${this.#num}/${relfile}`;

	 this.#resolveTable.set(filename, { url });
	 this.#pathTable.set(url, filename);
	 return url;
      }
   }
   
   resolve(mod) {
      const old = this.#resolveTable.get(mod);

      if (old) {
	 return old.url;
      } else {
	 const hooks = this.#hooks;
	 const root = this.#root;
	 const ctx = { parentURL: pathToFileURL(root) };
	 let index = 0;

	 const nextr = async (s, c) => {
	    if (index === hooks.length) {
	       const p = require.resolve(s, { paths: [ root ] });
	       return { url: pathToFileURL(p) };
	    } else {
	       return hooks[index++](s, ctx, nextr);
	    }
	 }
	 
	 return loader.resolve(mod, ctx, nextr)
	    .then(u => {
	       const file = fileURLToPath(u.url);
	       const relfile = relative(this.#root, file);
	       const url = `${hopBase}/${this.#num}/${relfile}`;

	       this.#resolveTable.set(mod, { url });
	       this.#pathTable.set(url, mod);
	       return url;
	    });
      }
   }

   path(url) {
      return this.#pathTable.get(url);
   }
}

/*---------------------------------------------------------------------*/
/*    hopResolver ...                                                  */
/*---------------------------------------------------------------------*/
let hopResolver = false;

/*---------------------------------------------------------------------*/
/*    register ...                                                     */
/*---------------------------------------------------------------------*/
function register(path) {
   if (!hopResolver) {
      const self = createRequire(import.meta.url)
	 .resolve("@hop/hop/hop-client.mjs");
      hopResolver = new Resolver(dirname(dirname(dirname(self))));
   }
   return hopResolver.register(path);
}
						  
/*---------------------------------------------------------------------*/
/*    resolve ...                                                      */
/*---------------------------------------------------------------------*/
function resolve(path) {
   return new Promise((res, rej) => {
      try {
	 res(register(path));
      } catch(e) {
	 rej(path);
      }
   });
}
						  
/*---------------------------------------------------------------------*/
/*    serviceUrl ...                                                   */
/*---------------------------------------------------------------------*/
function serviceUrl(file) {
   if (file[0] === "/") {
      return file;
   } else {
      return hopBase + "/" + file;
   }
}

/*---------------------------------------------------------------------*/
/*    Service ...                                                      */
/*---------------------------------------------------------------------*/
function Service(fun, optOrUrl) {
   const impl = new ServiceImpl(fun, optOrUrl);
   const f = (...args) => new Frame(impl, args);
   f.dollar = () => impl.dollar();
   return f;
}

/*---------------------------------------------------------------------*/
/*    ServiceImpl ...                                                  */
/*---------------------------------------------------------------------*/
/* @sealed */
class ServiceImpl {
   #fun;
   #path;
   #key = Math.round(Math.random() * 100000);

   constructor(fun, optOrUrl) {
      this.#fun = fun;
      if (typeof optOrUrl === "string") {
	 this.#path = serviceUrl(optOrUrl);
	 backend.get(this.#path, ServiceImpl.getResponse.bind(this));
	 backend.post(this.#path, ServiceImpl.postResponse.bind(this));
	 backend.put(this.#path, ServiceImpl.putResponse.bind(this));
      } else if (typeof optOrUrl === "object") {
	 if ("url" in optOrUrl) {
	    backend.post(this.#path, ServiceImpl.postResponse.bind(this));
	 }
      } else {
	 throw "Service: not implemented yet";
      }
   }

   dollar() {
      return `hop.server.import('${this.#path}')`;
   }

   path(args) {
      if (args.length === 0) {
	 return this.#path;
      } else {
	 let json = JSON.stringify(args);
	 return this.#path + "?Hop-Serialize=json-url&Hop-Arguments="
	    + encodeURIComponent(json);
      }
   }
   
   static postResponse(req, res) {
      if (authorizedService(req, this.#path)) {
	 let rep = undefined;
	 switch (req.get("Hop-Serialize")) {
	    case "json": {
	       const args = req.get("Hop-Arguments");
	       rep = this.#fun.apply(req, JSON.parse(args));
	       break;
	    }
	    default:
	       rep = this.#fun.call(req, req.query);
	 }
	 return hopResponse(req, res, rep);
      } else {
	 return hopResponse(req, res, HTTPResponseAuthentication());
      }
   }
   
   static putResponse(req, res) {
      if (authorizedService(req, this.#path)) {
	 let rep = undefined;
	 rep = this.#fun.call(req, req.query);
	 return hopResponse(req, res, rep);
      } else {
	 return hopResponse(req, res, HTTPResponseAuthentication());
      }
   }
   
   static getResponse(req, res) {
      if (authorizedService(req, this.#path)) {
	 let rep;
	 switch (req.query["Hop-Serialize"]) {
	    case "json-url": {
	       const args = decodeURIComponent(req.query["Hop-Arguments"]);
	       rep = this.#fun.apply(req, JSON.parse(args));
	       break;
	    }
	    default: {
	       rep = this.#fun.call(req, req.query);
	    }
	 }
	 return hopResponse(req, res, rep);
      } else {
	 return hopResponse(req, res, HTTPResponseAuthentication());
      }
   }
}

/*---------------------------------------------------------------------*/
/*    Frame ...                                                        */
/*---------------------------------------------------------------------*/
/* @sealed */
class Frame {
   #svc;
   #args;
   
   constructor(svc,args) {
      this.#svc = svc;
      this.#args = args;
   }

   dollar() {
      return "'" + this.toString() + "'";
   }
   
   toString() {
      const H = init("new Frame");
      return `http://${H.hostname}:${H.ports.http}${this.#svc.path(this.#args)}`;
   }
}

/*---------------------------------------------------------------------*/
/*    hopResponse ...                                                  */
/*    -------------------------------------------------------------    */
/*    This function is used to encode value returned by services       */
/*    and by event broadcast (see event.mjs).                          */
/*---------------------------------------------------------------------*/
function hopResponse(req, res, val) {
   if (val instanceof Response) {
      return val.hopResponse(req, res);
   } else if (val instanceof Promise) {
      return val.then(val => hopResponse(req, res, val));
   } else {
      // keep-alive
      if (req.get("connection")) {
	 res.set("Connection", req.Connection);
      }

      if (typeof(val) === "number") {
	 const str = val.toString();
	 res.append("Content-Length", str.length);
	 res.append("Hop-Serialize", "number");
	 res.send(str);
      } else if (val === undefined) {
	 res.append("Content-Length", "0");
	 res.append("Hop-Serialize", "undefined");
	 res.send("");
      } else if (val === null) {
	 res.append("Content-Length", "0")
	 res.append("Hop-Serialize", "null");
	 res.send("");
      } else if (val === true) {
	 res.append("Content-Length", "0")
	 res.append("Hop-Serialize", "true");
	 res.send("");
      } else if (val === false) {
	 res.append("Content-Length", "0");
	 res.append("Hop-Serialize", "false");
	 res.send("");
      } else if (typeof(val) === "string") {
	 res.append("Content-Length", val.length);
	 res.append("Hop-Serialize", "string");
	 res.send(val);
      } else if (val instanceof Buffer) {
	 res.append("Hop-Serialize", "buffer");
	 res.send(val);
      } else if (val instanceof Date) {
	 res.append("Hop-Serialize", "date");
	 res.send(val.getTime().toString());
      } else if (!(val instanceof Object)) {
	 // native objects will follow that path
	 return val;
      } else if ("toResponse" in val) {
	 const { string, serialize } = val.toResponse();
	 res.append("Content-Length", string.length);
	 res.append("Hop-Serialize", serialize);
	 res.send(string);
      } else if (!req.get("Hop-Serialize")) {
	 const str = val.toString();
	 res.append("Content-Length", str.length);
	 res.append("Content-Type", val?.mimetype ?? "application/text");
	 res.append("Hop-Serialize", "string");
	 res.send(str);
      } else {
	 const str = JSON.stringify(val);
	 res.append("Content-Length", str.length);
	 res.append("Hop-Serialize", "json");
	 res.send(str);
      }
      return res;
   }
}
   
/*---------------------------------------------------------------------*/
/*    Response                                                         */
/*---------------------------------------------------------------------*/
/* @sealed */
class Response {
   val;
   status;
   headers;
   
   constructor(val, status = 200, headers = undefined) {
      this.val = val;
      this.status = status;
      this.headers = headers;
   }
   
   hopResponse(req, res) {
      throw `Response not implemented (${this.constructor.name})`;
   }
}

/*---------------------------------------------------------------------*/
/*    ResponseString ...                                               */
/*---------------------------------------------------------------------*/
// @sealed
class ResponseString extends Response {
   hopResponse(req, res) {
      // status
      res.status(this.status);

      // header
      if (this.headers) {
	 for (let k in this.headers) {
	    res.append(k, this.headers[k]);
	 }
      }

      // content
      res.send(this.val);
      return res;
   }
}

/*---------------------------------------------------------------------*/
/*    ResponseFile ...                                                 */
/*---------------------------------------------------------------------*/
// @sealed
class ResponseFile extends Response {
   hopResponse(req, res) {
      // header
      if (this.headers) {
	 for (let k in this.headers) {
	    res.append(k, this.headers[k]);
	 }
      }

      res.sendFile(this.val);
      return res;
   }
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseFile ...                                             */
/*---------------------------------------------------------------------*/
function HTTPResponseFile(path, opt = undefined) {
   return new ResponseFile(path, 200, {
      "Content-Disposition": `inline; filename="${basename(path)}"`,
      "connection": opt?.connection || "keep-alive"
   });
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseString ...                                           */
/*---------------------------------------------------------------------*/
function HTTPResponseString(str, opt = undefined) {
   return new ResponseString(str, {
      "connection": opt?.connection || "keep-alive"
   });
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseAuthentication ...                                   */
/*---------------------------------------------------------------------*/
function HTTPResponseAuthentication(opt = undefined) {
   return new ResponseString("Unauthorized", 401, WWWAuthenticate());
}

/*---------------------------------------------------------------------*/
/*    ResponseHTML ...                                                 */
/*---------------------------------------------------------------------*/
// @sealed
class ResponseHTML extends Response {
   hopResponse(req, res) {
      // header
      if (this.headers) {
	 for (let k in this.headers) {
	    res.append(k, this.headers[k]);
	 }
      }

      hopResponse(req, res, this.val);
      return res;
   }
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseHTML ...                                             */
/*---------------------------------------------------------------------*/
function HTTPResponseHTML(html, opt = undefined) {
   return new ResponseHTML(html, 200);
}
