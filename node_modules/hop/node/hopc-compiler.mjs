/*=====================================================================*/
/*    .../hop/3.7.x/node_modules/hop/node/hopc-compiler.mjs            */
/*    -------------------------------------------------------------    */
/*    Author      :  manuel serrano                                    */
/*    Creation    :  Wed Oct 25 08:13:33 2023                          */
/*    Last change :  Thu Feb  1 13:36:15 2024 (serrano)                */
/*    Copyright   :  2023-24 manuel serrano                            */
/*    -------------------------------------------------------------    */
/*    Plain Hopc compiler                                              */
/*=====================================================================*/
"use strict"
"use hopscript"

/*---------------------------------------------------------------------*/
/*    es6 module                                                       */
/*---------------------------------------------------------------------*/
import { Parser, generate, $ioParseError, J2SNode } from "@hop/hopc";
import { writeFile } from 'node:fs/promises';
import { dirname } from "path";

/*---------------------------------------------------------------------*/
/*    language compiler (pre-processor)                                */
/*---------------------------------------------------------------------*/
const parser = new Parser();

export const parse = parser.parse.bind(parser);
export const parseString = parser.parseString.bind(parser);

/*---------------------------------------------------------------------*/
/*    isString ...                                                     */
/*---------------------------------------------------------------------*/
function isString(node) {
   if (node.clazz === "J2SStmtExpr") {
      const expr = node.expr;
      return expr.clazz === "J2SString";
   } else {
      return false;
   }
}

/*---------------------------------------------------------------------*/
/*    addHopImport ...                                                 */
/*---------------------------------------------------------------------*/
function addHopImport(prog) {
   let nodes = prog.nodes;
   let prev = null;
   const imp = parseString("import { A, ABBR, ACRONYM, ADDRESS, APPLET, AREA, ARTICLE, B, BASE, BDI, BDO, BIG, BLOCKQUOTE, BODY, BR, BUTTON, CANVAS, CAPTION, CENTER, CITE, CODE, COL, COLGROUP, DATALIST, DD, DEL, DETAILS, DFN, DIR, DIV, DL, DT, EM, EMBED, FIELDSET, FIGURE, FIGCAPTION, FONT, FOOTER, FORM, FRAME, FRAMESET, H1, H2, H3, H4, H5, H6, HEAD, HEADER, HGROUP, HR, I, IFRAME, INPUT, INS, ISINDEX, KBD, LABEL, LEGEND, LI, LINK, MAIN, MAP, MARQUEE, MENU, MENUITEM, META, METER, NAV, NOFRAMES, NOSCRIPT, OBJECT, OL, OPTGROUP, OPTION, P, PARAM, PRE, PROGRESS, Q, S, SAMP, SCRIPT, SECTION, SELECT, SMALL, SOURCE, SPAN, STRIKE, STRONG, STYLE, SUB, SUMMARY, SUP, TABLE, TBODY, TD, TEXTAREA, TFOOT, TH, THEAD, TIME, TITLE, TR, TRACK, TT, U, UL, VAR, HTML, TILDE, DOLLAR } from \"@hop/hop\"");


   // patch the location of the manually inserted ast
   imp.hopcWalk(n => n.loc = prog.loc);
   
   while (isString(nodes.car)) {
      prev = nodes;
      nodes = nodes.cdr;
   }

   if (prev) {
      prev.cdr = { car: imp, cdr: prev.cdr }
   } else {
      prog.nodes = { car: imp, cdr: prog.nodes }
   }
   
   return prog;
}

/*---------------------------------------------------------------------*/
/*    HopProgram ...                                                   */
/*---------------------------------------------------------------------*/
class HopProgram {
   #source = false;
   #fragment = undefined;
   
   constructor(source, fragment) {
      this.#source = source;
      this.#fragment = fragment;
   }

   output(target) {
      const prgm = this.#fragment.toString();

      if (!target) {
	 return new Promise((res, rej) => { console.log(prgm); res(true) });
      } else {
	 const tag = `\n//# sourceMappingURL=${target}.map\n`;

	 return writeFile(target, prgm + tag);
      }
   }

   sourcemap(target) {
      const sm = {
	 version: 3,
	 file: target,
	 sources: [ this.#source ],
	 names: [],
	 mappings: this.#fragment.mappings(this.#source, target)
      }
      return writeFile(target + ".map", JSON.stringify(sm));
   }
}

/*---------------------------------------------------------------------*/
/*    compileHandler ...                                               */
/*---------------------------------------------------------------------*/
function compileHandler(err) {
   if (err && err.obj && err.obj.loc?.filename) {
      $ioParseError({
	 "fname": err.obj.loc.filename,
	 "location": err.obj.loc?.offset ?? -1,
	 "msg": "Parse error",
	 "message": err.msg || err.message,
	 "obj": err.obj,
	 forceexit: true
      });
      throw "syntax error.";
   } else if (err && err?.fname && err?.location) {
      $ioParseError({
	 "fname": err.fname,
	 "location": err.location,
	 "message": err.msg || err.message,
	 "message": err.msg,
	 "obj": err.obj,
	 forceexit: true
      });
      throw "syntax error.";
   } else if (err && err?.location) {
      $ioParseError({
	 "fname": err.location.filename,
	 "location": err.location.pos || err.location.offset,
	 "msg": "Parse error",
	 "message": err.msg || err.message,
	 "obj": err.obj,
	 forceexit: true
      });
      throw "syntax error.";
   } else {
      throw err;
   }
}
    
/*---------------------------------------------------------------------*/
/*    compile ...                                                      */
/*---------------------------------------------------------------------*/
export function compile(source) {
   try {
      const prog = parse(source, {}, {});
      return new HopProgram(source, generate(addHopImport(prog)));
   } catch(err) {
      compileHandler(err);
   }
}
