/*=====================================================================*/
/*    serrano/prgm/project/hop/hop/node_modules/hop/node/auth.mjs      */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Mon Feb  5 18:06:12 2024                          */
/*    Last change :  Thu Mar 28 08:27:07 2024 (serrano)                */
/*    Copyright   :  2024 Manuel Serrano                               */
/*    -------------------------------------------------------------    */
/*    authentication and users                                         */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    Import/Export                                                    */
/*---------------------------------------------------------------------*/
import { config } from "./config.mjs";
import { existsSync, readFileSync } from "node:fs";
import * as path from  "node:path";
import { createHash } from "node:crypto";

export { init, digestPassword, WWWAuthenticate, authorizedService };

/*---------------------------------------------------------------------*/
/*    digestPassword ...                                               */
/*---------------------------------------------------------------------*/
function digestPassword(name, pass) {
   const str = `${name}:${config.security.realm}:${pass}`;
   return createHash("md5").update(str).digest("hex").toString();
}

/*---------------------------------------------------------------------*/
/*    usersMap ...                                                     */
/*---------------------------------------------------------------------*/
const usersMap = new Map();
const userAnonymous = { name: "anonymous", services: [], directories: [] };

/*---------------------------------------------------------------------*/
/*    digestPrivateKey ...                                             */
/*---------------------------------------------------------------------*/
const digestSession = Date.now() >> 2;
const digestPrivateKey = (Math.random() * 10000000 | Date.now()) + "";
let digestOpaque = false;

/*---------------------------------------------------------------------*/
/*    getDigestOpaque ...                                              */
/*---------------------------------------------------------------------*/
function getDigestOpaque() {
   if (!digestOpaque) {
      digestOpaque = `${config.hostname}:${config.ports.http}:${digestSession}`;
   }
   return digestOpaque;
}

/*---------------------------------------------------------------------*/
/*    WWWAuthenticate ...                                              */
/*---------------------------------------------------------------------*/
function WWWAuthenticate() {
   const nonce = Buffer.from(Date.now() + digestPrivateKey).toString('base64');
   const auth = `Digest realm="${config.security.realm}", qop="auth", nonce="${nonce}", opaque="${getDigestOpaque()}"`;
   return { "WWW-Authenticate": auth, "hop-session": digestSession }
}

/*---------------------------------------------------------------------*/
/*    parseDigest ...                                                  */
/*    -------------------------------------------------------------    */
/*    This function parses strings such as:                            */
/*      'Digest username="foo", realm="hop", nonce="MTc" ...'          */
/*---------------------------------------------------------------------*/
function parseDigest(s) {
   const rxName = /([a-zA-Z]+)=/y;
   const rxString = /"([^"]*)"/y;
   const rxValue = /[^", ][^, ]*/y;
   const rxSep = /,?[ ]+/y;
   const obj = {};
   let n;
   let v;
   
   rxName.lastIndex = 7;   
   while (n = s.match(rxName)) {
      rxString.lastIndex = rxName.lastIndex;
      if (v = s.match(rxString)) {
	 obj[n[1]] = v[1];
	 rxSep.lastIndex = rxString.lastIndex;
      } else {
	 rxValue.lastIndex = rxName.lastIndex;
	 if (v = s.match(rxValue)) {
	    obj[n[1]] = v[0];
	    rxSep.lastIndex = rxValue.lastIndex;
	 } else {
	    return false;
	 }
      }
      if (!s.match(rxSep)) {
	 return obj;
      } else {
	 rxName.lastIndex = rxSep.lastIndex;
      }
   }

   return obj;
}

/*---------------------------------------------------------------------*/
/*    authenticationFailure ...                                        */
/*---------------------------------------------------------------------*/
function authenticationFailure(msg, name) {
   if (config.verbose >= 2) {
      console.log('Cannot authentify user "' + name + '" (' + msg + ')');
   } else {
      return userAnonymous;
   }
}

/*---------------------------------------------------------------------*/
/*    authenticationDigest ...                                         */
/*---------------------------------------------------------------------*/
function authenticationDigest(req, digest) {

   function H(str) {
      return createHash("md5").update(str).digest("hex").toString();
   }

   function KD(secret, data) {
      return H(secret + ":" + data);
   }
   
   function responseDigest(A1, digest) {
      const { nc, nonce, qop, uri } = digest;

      if (typeof nonce === "string"
	 && typeof nc === "string"
	 && typeof uri === "string") {
	 // Hop does not support auth-int so A2 is only defined as follows
	 const A2 = req.method + ":" + uri;

	 if (qop === "auth") {
	    const cnonce = digest.cnonce;
	    
	    if (typeof cnonce === "string") {
	       return KD(A1, `${nonce}:${nc}:${cnonce}:${qop}:${H(A2)}`);
	    } else {
	       return authenticationFailure("digest(4)", digest.username);
	    }
	 } else {
	    return KD(H(A1, `${nonce}:${H(A2)}`));
	 }
      } else {
	 return authenticationFailure("digest(5)", digest.username);
      }
   }
      
   const u = usersMap.get(digest.username);
   if (u
      && digest.opaque === getDigestOpaque()
      && digest.realm === config.security.realm) {
      const rep = responseDigest(u.password, digest);

      if (rep === digest.response) {
	 // adCachedUser();
	 return u;
      } else {
	 return authenticationFailure("digest(3)", digest.username);
      }
   }
   return userAnonymous;
}

/*---------------------------------------------------------------------*/
/*    authentication ...                                               */
/*---------------------------------------------------------------------*/
function authentication(req) {
   let auth;
   let match;

   if (auth = req.get("authorization")) {
      if (match = auth.match(/^Digest /)) {
	 return authenticationDigest(req, parseDigest(auth));
      } else if (match = auth.match(/^Basic ([^ :\t\r\n]*)/)) {
	 return authenticationFailure("basic", match[1]);
      } else {
	 return authenticationFailure("unknonw method", match[1]);
      }
   }
   return userAnonymous;
}

/*---------------------------------------------------------------------*/
/*    authorizedService ...                                            */
/*    -------------------------------------------------------------    */
/*    Is service at URL authorized for this request?                   */
/*---------------------------------------------------------------------*/
function authorizedService(req, url) {
   if (!config.security.serviceAuthentication) {
      return true;
   } else {
      const user = authentication(req);

      return user?.services === "*"
	 || user?.services.indexOf(url) >= 0
	 || user?.services.find(s => {
	    if (url[s.length] === "/") {
	       return s === url.substring(0, s.length);
	    }
	 });
   }
}

/*---------------------------------------------------------------------*/
/*    init ...                                                         */
/*    -------------------------------------------------------------    */
/*    Executed _after_ config.mjs has been loaded.                     */
/*    -------------------------------------------------------------    */
/*    Performance does not matter.                                     */
/*---------------------------------------------------------------------*/
function init() {

   function starOrStringArray(v) {
      return (v === "*" || (Array.isArray(v) && v.every(s => typeof s === "string")));
   }
   
   function checkUser(u) {
      for (let k in u) {
	 switch (k) {
	    case "name":
	       if (typeof u[k] !== "string") {
		  console.error(`warning: wrong user ${k} "${u.name}"`);
		  return false;
	       } else if (usersMap.has(u.name)) {
		  console.error(`warning: user redefinition "${u.name}"`);
		  return false;
	       }
	       break;
	       
	    case "password":
	       if (typeof u[k] !== "string") {
		  console.error(`warning: wrong user ${k} "${u.name}"`);
		  return false;
	       }
	       break;
	       
	    case "services":
	    case "directories":
	       if (!starOrStringArray(u[k])) {
		  console.error(`warning: user "${u.name}", wrong ${k} "${u[k]}"`);
		  return false;
	       }
	       break;

	    default:
	       console.error(`warning: user "${u.name}", unknown user propperty "${k}"`);
	       return false;
	 }
      }
      return true;
   }
	       
   config.users.forEach(u => {
      if (checkUser(u)) {
	 usersMap.set(u.name, u);
	 if (u.name === "anonymous") {
	    Object.assign(userAnonymous, u);
	 }	       
      }
   });
}
