/*=====================================================================*/
/*    serrano/prgm/project/hop/hop/node_modules/hop/lib/hop.mjs        */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Thu Jun 26 08:21:30 2014                          */
/*    Last change :  Thu May 16 15:10:52 2024 (serrano)                */
/*    Copyright   :  2014-24 Manuel Serrano                            */
/*    -------------------------------------------------------------    */
/*    HOP module                                                       */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    Import/Export                                                    */
/*---------------------------------------------------------------------*/
import { dirname, normalize, relative, join, isAbsolute } from "node:path";
import { existsSync, statSync, readFileSync } from "node:fs";
import * as _hop from "./_hop.hop";
import { init as configInit } from "./config.mjs";
import { URL, pathToFileURL, fileURLToPath } from 'node:url';

export { Hop }

/*---------------------------------------------------------------------*/
/*    Hop ...                                                          */
/*---------------------------------------------------------------------*/
// @sealed
class Hop {
   ports = { http: 0, https: 0 };
   config;
   #httpServer;
   #httpsServer;
   
   constructor(config) {
      this.config = configInit(config);
      this.config.users.forEach(_hop.addUser);
   }

   listen() {
      const { ports, listenAddress, soMaxConn, maxThread } = this.config;

      return new Promise((res, rej) => {
	 if (ports.http && ports.http >= 0) {
	    const srv = _hop.createServer(ports.http, listenAddress, soMaxConn);
	    if (_hop.isSocketServer(srv)) {
	       const sched = _hop.createScheduler(maxThread);
	       this.#httpServer= srv;
	       this.ports.http = _hop.socketPortNumber(srv);
	       sched.accept(srv);
	       
	    } else {
	       rej(new Error(`Cannot open server ${ports.http}`));
	    }
	 }
	 
	 if (ports.https && ports.https >= 0) {
	    const sched = _hop.createScheduler(maxThread);
	    const cert = readFileSync(this.config.credentials.cert);
	    const key = readFileSync(this.config.credentials.key);
	    const srv = _hop.createServerSSL(ports.https, listenAddress, soMaxConn, cert, key);

	    if (_hop.isSocketServer(srv)) {
	       this.backend.httpsServer= srv;
	       this.ports.https = _hop.socketPortNumber(srv);
	       sched.accept(srv);
	    } else {
	       rej(new Error(`Cannot open server ${ports.https}`));
	    }
	 }

	 if (this.config.verbose >= 1 && this.config.motd) {
	    console.log(this.config.motd, this.ports.http, this.ports.https);
	 }
	 
	 res(this);
      });
   }

   schema() {
      if (this.ports.https > 0) {
	 return `https://${this.config.hostname}:${thisports.https}`;
      } else {
	 return `http://${this.config.hostname}:${this.ports.http}`;
      }
   }
   
   Resolver(root = undefined) {
      if (!root) {
	 root = dirname(__dirname);
      }
      return new Resolver(this, root);
   }
   
   Service(fun, optOrUrl) {
      if (!(this instanceof Hop)) {
	 throw new TypeError(`${impl.path()}, illegal "this" -- ${this}`);
      } else {
	 return _hop.Service.call(this, fun, optOrUrl);
      }
   }
}

/*---------------------------------------------------------------------*/
/*    Resolver ...                                                     */
/*---------------------------------------------------------------------*/
// @sealed
class Resolver {
   #hop;
   #root;
   #hooks = []
   #resolveTable = new Map();
   #pathTable = new Map();
   #num;

   static num = 1;

   static getRootDir(url) {
      if (!url) {
	 return process.cwd();
      } else {
	 const urlpath = url instanceof URL
	    ? fileURLToPath(url)
	    : url.replace(/^file:\/\//, "");
	 const normpath = normalize(urlpath);
	 
	 if (!existsSync(urlpath)) {
	    throw new Error(`resolver path does not exists ${url}`);
	 } else {
	    if (statSync(urlpath).isDirectory()) {
	       return normpath;
	    } else {
	       return dirname(normpath);
	    }
	 }
      }
   }

   constructor(hop, root) {
      this.#hop = hop;
      this.#root = Resolver.getRootDir(root);
      this.#num = Resolver.num++;

      _hop.static.call(this.#hop, this.#num, this.#root);
   }

   url(file) {
      const relfile = isAbsolute(file) ? relative(this.#root, file) : file;
      const filename = normalize(join(this.#root, relfile));
      const old = this.#resolveTable.get(filename);

      if (old) {
	 return old.url;
      } else if (filename.substring(0, this.#root.length) !== this.#root) {
	 throw new Error(`file not in resolver root directory ${relfile}`);
      } else if (!existsSync(filename)) {
	 throw new Error(`file does not exists in resolver directory ${this.#root}/${relfile}`);
      } else {
	 const url = `/hop/${this.#num}/${relfile}`;

	 this.#resolveTable.set(filename, { url });
	 this.#pathTable.set(url, filename);
	 return url;
      }
   }
   
   path(url) {
      return this.#pathTable.get(url);
   }
}

