/*=====================================================================*/
/*    serrano/prgm/project/hop/hop/node_modules/hop/lib/hop.mjs        */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Thu Jun 26 08:21:30 2014                          */
/*    Last change :  Wed May 15 15:37:39 2024 (serrano)                */
/*    Copyright   :  2014-24 Manuel Serrano                            */
/*    -------------------------------------------------------------    */
/*    HOP module                                                       */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    Import/Export                                                    */
/*---------------------------------------------------------------------*/
import * as _hop from "./_hop.hop";
import { init as configInit } from "./config.mjs";

export { Hop }

/*---------------------------------------------------------------------*/
/*    Hop ...                                                          */
/*---------------------------------------------------------------------*/
/* @sealed */
class Hop {
   ports = { http: 0, https: 0 };
   config;
   #httpServer;
   #httpsServer;
   
   constructor(config) {
      this.config = configInit(config);
      this.config.users.forEach(_hop.addUser);
   }

   listen() {
      const { ports, listenAddress, soMaxConn, maxThread } = this.config;

      return new Promise((res, rej) => {
	 if (ports.http && ports.http >= 0) {
	    const srv = _hop.createServer(ports.http, listenAddress, soMaxConn);
	    if (_hop.isSocketServer(srv)) {
	       const sched = _hop.createScheduler(maxThread);
	       this.#httpServer= srv;
	       this.ports.http = _hop.socketPortNumber(srv);
	       sched.accept(srv);
	       
	    } else {
	       rej(new Error(`Cannot open server ${ports.http}`));
	    }
	 }
	 
	 if (ports.https && ports.https >= 0) {
	    const sched = _hop.createScheduler(maxThread);
	    const cert = readFileSync(this.config.credentials.cert);
	    const key = readFileSync(this.config.credentials.key);
	    const srv = _hop.createServerSSL(ports.https, listenAddress, soMaxConn, cert, key);

	    if (_hop.isSocketServer(srv)) {
	       this.backend.httpsServer= srv;
	       this.ports.https = _hop.socketPortNumber(srv);
	       sched.accept(srv);
	    } else {
	       rej(new Error(`Cannot open server ${ports.https}`));
	    }
	 }

	 if (this.config.verbose >= 1 && this.config.motd) {
	    console.log(this.config.motd, this.ports.http, this.ports.https);
	 }
	 
	 res(this);
      });
   }

   Service(fun, optOrUrl) {
      if (!(this instanceof Hop)) {
	 throw new TypeError(`${impl.path()}, illegal "this" -- ${this}`);
      } else {
	 const impl = _hop.Service(fun, optOrUrl);
	 const f = (...args) => new Frame(impl, args);
	 f.dollar = () => impl.dollar();
	 return f;
      }
   }
}

