;*=====================================================================*/
;*    serrano/prgm/project/hop/hop/node_modules/mkjsast.scm            */
;*    -------------------------------------------------------------    */
;*    Author      :  Manuel Serrano                                    */
;*    Creation    :  Tue Jul  1 16:05:56 2014                          */
;*    Last change :  Wed Sep 11 09:58:54 2019 (serrano)                */
;*    Copyright   :  2014-19 Manuel Serrano                            */
;*    -------------------------------------------------------------    */
;*    Build the JS Ast from the Bigloo type class hierarchy            */
;*=====================================================================*/

;*---------------------------------------------------------------------*/
;*    The module                                                       */
;*---------------------------------------------------------------------*/
(module mkjsast
   (main main))

;*---------------------------------------------------------------------*/
;*    main ...                                                         */
;*---------------------------------------------------------------------*/
(define (main argv)
   (call-with-input-file (string-append (cadr argv) ".scm")
      (lambda (ip)
	 (match-case (read ip)
	    ((module ?- ??- (export . ?clauses) . ?-)
	     (print tojson)
	     (let ((env (filter-map parse-class clauses)))
		(for-each (lambda (c) (print-class c env)) env)))))))

;*---------------------------------------------------------------------*/
;*    tojson ...                                                       */
;*---------------------------------------------------------------------*/
(define tojson
   "function tojson( obj ) {
  if( !(obj instanceof Object) ) {
     if( obj === undefined ) {
	return '{ \"__undefined__\": \"undefined\" }';
     } else {
        return JSON.stringify( obj );
     }
  } else if( 'tojson' in obj ) {
     return obj.tojson();
  } else if( obj instanceof Array ) {
     return '[' + obj.map( tojson ).join( \",\" ) + ']';
  } else if( '__ast__' in obj ) {
     return '{ \"__ast__\": ' + obj.__ast__.tojson() + '}';
  } else if( obj instanceof Object ) {
     return '{' + Object.keys( obj ).map( function( k ) {
          return '\"' + k + '\": ' + tojson( obj[ k ] );
       } ).join( \",\" ) + '}';
  } else {
     return obj.toString();
  }
};
exports.tojson = tojson;\n")

;*---------------------------------------------------------------------*/
;*    print-class ...                                                  */
;*---------------------------------------------------------------------*/
(define (print-class class env)

   (define (tojson name fields)
      (printf "Object.defineProperty( ~a.prototype, 'tojson', { value: function() {\n" name)
      (printf "   return '{ \"__node__\": \"~a\"'" name)
      (for-each (lambda (f)
		   (if (cdr f)
		       (printf "\n      + ', \"~a\":' + (this.~a ? '{ \"__ref__\":' +  this.~a.key + '}' : false)"
			  (car f) (car f) (car f))
		       (printf "\n      + ', \"~a\":' + tojson( this[ \"~a\" ] )"
			  (car f) (car f))))
	 fields)
      (display "\n      + '}';\n")
      (printf "}, enumerable: false } ); \n"))
   
   (match-case class
      ((?- #t . ?-)
       ;; already printed class
       #unspecified)
      ((?name #f #f ?fields)
       ;; root class
       (set-car! (cdr class) #t)
       (printf "function ~a( ~(, ) ) {\n" name (map arg-name fields))
       (printf "   this.__node__ = \"~a\";\n" name)
       (for-each (lambda (f)
		    (printf "   this[ ~s ] = ~a;\n"
		       (symbol->string (car f)) (arg-name f))) fields)
       (printf "}\n")
       (when (any cdr fields)
	  (tojson name fields))
       (printf "exports.~a = ~a;\n" name name)
       (newline))
      ((?name #f ?super ?fields)
       ;; unprinted subclass
       (let* ((fields fields)
	      (superfields (class-superfields super env))
	      (allfields (append superfields fields)))
	  (set-car! (cdr class) #t)
	  (printf "function ~a( ~(, ) ) {\n" name (map arg-name allfields))
	  (if (pair? superfields)
	      (printf "   ~a.call( this, ~(, ) );\n"
		 super (map arg-name superfields))
	      (printf "   ~a.call( this );\n" super))
	  (for-each (lambda (f)
		       (printf "   this[ ~s ] = ~a;\n"
			  (symbol->string (car f)) (arg-name f)))
	     fields)
	  (printf "   this.__node__ = \"~a\";\n" name)
	  (printf "}\n")
	  (printf "~a.prototype = new ~a;\n" name super)
	  (tojson name allfields)
	  (printf "exports.~a = ~a;\n\n" name name)))))

;*---------------------------------------------------------------------*/
;*    subclass? ...                                                    */
;*---------------------------------------------------------------------*/
(define (subclass? c clazz env)
   (let loop ((c c))
      (when c
	 (cond
	    ((eq? c clazz)
	     #t)
	    ((eq? c 'J2SNode)
	     #f)
	    (else
	     (let ((s (assq c env)))
		(when (pair? s)
		   (loop (caddr s)))))))))

;*---------------------------------------------------------------------*/
;*    arg-name ...                                                     */
;*---------------------------------------------------------------------*/
(define (arg-name f)
   (case (car f)
      ((|else|) '_else)
      ((|catch|) '_catch)
      ((|finally|) '_finally)
      ((|import|) '_import)
      ((|export|) '_export)
      ((|method|) '_method)
      ((|function|) '_function)
      ((|super|) '_super)
      ((|static|) '_static)
      (else (string->symbol
	       (string-replace (string-replace (symbol->string (car f)) #\- #\_)
		  #\% #\$)))))
	   
;*---------------------------------------------------------------------*/
;*    class-superfields ...                                            */
;*---------------------------------------------------------------------*/
(define (class-superfields class env)
   (let ((clazz (assq class env)))
      (match-case clazz
	 ((?- ?- #f ?fields)
	  fields)
	 ((?- ?- ?super ?fields)
	  (append (class-superfields super env) fields)))))
   
;*---------------------------------------------------------------------*/
;*    parse-class ...                                                  */
;*---------------------------------------------------------------------*/
(define (parse-class clause)
   (match-case clause
      (((or class abstract-class final-class wide-class) ?name . ?fields)
       (multiple-value-bind (id type)
	  (parse-class-id name)
	  (list id #f type (filter-map parse-class-field fields))))
      (else
       #f)))

;*---------------------------------------------------------------------*/
;*    id-regexp ...                                                    */
;*---------------------------------------------------------------------*/
(define id-regexp (pregexp "([^:]+)::([^:]+)"))

;*---------------------------------------------------------------------*/
;*    parse-class-id ...                                               */
;*---------------------------------------------------------------------*/
(define (parse-class-id id)
   (let ((m (pregexp-match id-regexp (symbol->string id))))
      (if (pair? m)
	  (values (string->symbol (cadr m)) (string->symbol (caddr m)))
	  (values id #f))))

;*---------------------------------------------------------------------*/
;*    parse-class-field ...                                            */
;*---------------------------------------------------------------------*/
(define (parse-class-field field)
   (match-case field
      ((? symbol?)
       (multiple-value-bind (id type)
	  (parse-class-id field)
	  (cons id #f)))
      ((?name . ?opts)
       (let ((info (find (lambda (e) (and (pair? e) (eq? (car e) 'info))) opts)))
	  (if (or (not info) (not (member "nojson" (cadr (cadr info)))))
	      (multiple-value-bind (id type)
		 (parse-class-id name)
		 (cons id (and info (member "jsonref" (cadr (cadr info))))))
	      #f)))
      (else
       (error "parse-class-field" "wrong class field" field))))
