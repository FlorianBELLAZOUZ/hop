;*=====================================================================*/
;*    serrano/prgm/project/hop/3.2.x/node_modules/mkjsast.scm          */
;*    -------------------------------------------------------------    */
;*    Author      :  Manuel Serrano                                    */
;*    Creation    :  Tue Jul  1 16:05:56 2014                          */
;*    Last change :  Tue Jul 17 10:15:07 2018 (serrano)                */
;*    Copyright   :  2014-18 Manuel Serrano                            */
;*    -------------------------------------------------------------    */
;*    Build the JS Ast from the Bigloo type class hierarchy            */
;*=====================================================================*/

;*---------------------------------------------------------------------*/
;*    The module                                                       */
;*---------------------------------------------------------------------*/
(module mkjsast
   (main main))

;*---------------------------------------------------------------------*/
;*    main ...                                                         */
;*---------------------------------------------------------------------*/
(define (main argv)
   (call-with-input-file (string-append (cadr argv) ".scm")
      (lambda (ip)
	 (match-case (read ip)
	    ((module ?- ??- (export . ?clauses) . ?-)
	     (print tojson)
	     (let ((env (filter-map parse-class clauses)))
		(for-each (lambda (c) (print-class c env)) env)))))))

;*---------------------------------------------------------------------*/
;*    tojson ...                                                       */
;*---------------------------------------------------------------------*/
(define tojson
   "function tojson( obj ) {
  if( !(obj instanceof Object) ) {
     return JSON.stringify( obj );
  } else if( 'tojson' in obj ) {
     return obj.tojson();
  } else if( obj instanceof Array ) {
     return '[' + obj.map( tojson ).join( \",\" ) + ']';
  } else if( '__ast__' in obj ) {
     return '{ \"__ast__\": ' + obj.__ast__.tojson() + '}';
  } else if( obj instanceof Object ) {
     return '{' + Object.keys( obj ).map( function( k ) {
          return '\"' + k + '\": ' + tojson( obj[ k ] );
       } ).join( \",\" ) + '}';
  } else {
     return obj.toString();
  }
};
exports.tojson = tojson;\n")

;*---------------------------------------------------------------------*/
;*    print-class ...                                                  */
;*---------------------------------------------------------------------*/
(define (print-class class env)
   (match-case class
      ((?- #t . ?-)
       ;; already printed class
       #unspecified)
      ((?name #f #f ?fields)
       ;; root class
       (set-car! (cdr class) #t)
       (printf "function ~a( ~(, ) ) {\n" name (map arg-name fields))
       (printf "   this.__node__ = \"~a\";\n" name)
       (for-each (lambda (f)
		    (printf "   this[ ~s ] = ~a;\n"
		       (symbol->string f) (arg-name f))) fields)
       (printf "}\n")
       (printf "exports.~a = ~a;\n\n" name name))
      ((?name #f ?super ?fields)
       ;; unprinted subclass
       (let* ((superfields (class-superfields super env))
	      (allfields (append superfields fields)))
	  (set-car! (cdr class) #t)
	  (printf "function ~a( ~(, ) ) {\n" name (map arg-name allfields))
	  (if (pair? superfields)
	      (printf "   ~a.call( this, ~(, ) );\n"
		 super (map arg-name superfields))
	      (printf "   ~a.call( this );\n" super))
	  (for-each (lambda (f)
		       (printf "   this[ ~s ] = ~a;\n"
			  (symbol->string f) (arg-name f)))
	     fields)
	  (printf "   this.__node__ = \"~a\";\n" name)
	  (printf "}\n")
	  (printf "~a.prototype = new ~a;\n" name super)
	  (printf "Object.defineProperty( ~a.prototype, 'tojson', { value: function() {\n" name)
	  (printf "   return '{ \"__node__\": \"~a\"'" name)
	  (for-each (lambda (f)
		       (if (and (eq? f 'decl) (subclass? name 'J2SRef env))
			   (printf "\n      + ', \"~a\": { \"__ref__\":' +  this.decl.key  + '}'"
			      f)
			   (printf "\n      + ', \"~a\":' + tojson( this[ \"~a\" ] )"
			      f f)))
	     allfields)
	  (display "\n      + '}';\n")
	  (printf "}, enumerable: false } ); \n")
	  (printf "exports.~a = ~a;\n\n" name name)))))

;*---------------------------------------------------------------------*/
;*    subclass? ...                                                    */
;*---------------------------------------------------------------------*/
(define (subclass? c clazz env)
   (let loop ((c c))
      (when c
	 (cond
	    ((eq? c clazz)
	     #t)
	    ((eq? c 'J2SNode)
	     #f)
	    (else
	     (let ((s (assq c env)))
		(when (pair? s)
		   (loop (caddr s)))))))))

;*---------------------------------------------------------------------*/
;*    arg-name ...                                                     */
;*---------------------------------------------------------------------*/
(define (arg-name id)
   (case id
      ((|else|) '_else)
      ((|catch|) '_catch)
      ((|finally|) '_finally)
      ((|import|) '_import)
      ((|method|) '_method)
      ((|function|) '_function)
      ((|super|) '_super)
      ((|static|) '_static)
      (else (string->symbol
	       (string-replace (string-replace (symbol->string id) #\- #\_)
		  #\% #\$)))))
	   
;*---------------------------------------------------------------------*/
;*    class-superfields ...                                            */
;*---------------------------------------------------------------------*/
(define (class-superfields class env)
   (let ((clazz (assq class env)))
      (match-case clazz
	 ((?- ?- #f ?fields)
	  fields)
	 ((?- ?- ?super ?fields)
	  (append (class-superfields super env) fields)))))
   
;*---------------------------------------------------------------------*/
;*    parse-class ...                                                  */
;*---------------------------------------------------------------------*/
(define (parse-class clause)
   (match-case clause
      (((or class abstract-class final-class wide-class) ?name . ?fields)
       (multiple-value-bind (id type)
	  (parse-class-id name)
	  (list id #f type (map parse-class-field fields))))
      (else
       #f)))

;*---------------------------------------------------------------------*/
;*    id-regexp ...                                                    */
;*---------------------------------------------------------------------*/
(define id-regexp (pregexp "([^:]+)::([^:]+)"))

;*---------------------------------------------------------------------*/
;*    parse-class-id ...                                               */
;*---------------------------------------------------------------------*/
(define (parse-class-id id)
   (let ((m (pregexp-match id-regexp (symbol->string id))))
      (if (pair? m)
	  (values (string->symbol (cadr m)) (string->symbol (caddr m)))
	  (values id #f))))

;*---------------------------------------------------------------------*/
;*    parse-class-field ...                                            */
;*---------------------------------------------------------------------*/
(define (parse-class-field field)
   (match-case field
      ((? symbol?)
       (multiple-value-bind (id type)
	  (parse-class-id field)
	  id))
      ((?name . ?-)
       (multiple-value-bind (id type)
	  (parse-class-id name)
	  id))
      (else
       (error "parse-class-field" "wrong class field" field))))
